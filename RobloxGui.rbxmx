<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.cat/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="ScreenGui" referent="RBX75017CD694A341B890FFEFEB406DB521">
		<Properties>
			<int name="DisplayOrder">0</int>
			<bool name="Enabled">true</bool>
			<string name="Name">RobloxGui</string>
			<bool name="ResetOnSpawn">true</bool>
		</Properties>
		<Item class="Frame" referent="RBXF9CC2C5967FB4786B1ACF4F8AC61D8A3">
			<Properties>
				<bool name="Active">false</bool>
				<Vector2 name="AnchorPoint">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<Color3 name="BackgroundColor3">4288914085</Color3>
				<float name="BackgroundTransparency">1</float>
				<Color3 name="BorderColor3">4279970357</Color3>
				<int name="BorderSizePixel">1</int>
				<bool name="ClipsDescendants">false</bool>
				<bool name="Draggable">false</bool>
				<string name="Name">ControlFrame</string>
				<Ref name="NextSelectionDown">null</Ref>
				<Ref name="NextSelectionLeft">null</Ref>
				<Ref name="NextSelectionRight">null</Ref>
				<Ref name="NextSelectionUp">null</Ref>
				<UDim2 name="Position">
					<XS>0</XS>
					<XO>0</XO>
					<YS>0</YS>
					<YO>0</YO>
				</UDim2>
				<float name="Rotation">0</float>
				<bool name="Selectable">false</bool>
				<Ref name="SelectionImageObject">null</Ref>
				<UDim2 name="Size">
					<XS>1</XS>
					<XO>0</XO>
					<YS>1</YS>
					<YO>0</YO>
				</UDim2>
				<token name="SizeConstraint">0</token>
				<token name="Style">0</token>
				<bool name="Visible">true</bool>
				<int name="ZIndex">1</int>
			</Properties>
			<Item class="Frame" referent="RBXB0B64C99CB3C4D5294FD27B08FE7642F">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">BottomLeftControl</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>-46</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>130</XO>
						<YS>0</YS>
						<YO>46</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBXEFFD7CD7D1F44689941AFE12C29DB0C2">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">BottomRightControl</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>1</XS>
						<XO>-180</XO>
						<YS>1</YS>
						<YO>-41</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>180</XO>
						<YS>0</YS>
						<YO>41</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBXA99A47476F184B5FBEB70225A2D902C9">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">TopLeftControl</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0.0500000007</XS>
						<XO>0</XO>
						<YS>0.0500000007</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6E8B4361F89B449684BF38C536F4163A">
			<Properties>
				<string name="Name">Modules</string>
			</Properties>
			<Item class="Folder" referent="RBX8215E24D03D04A6EBD501E25D711A5EF">
				<Properties>
					<string name="Name">VR</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX09BD965833B548CB96D253101B5AA253">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VirtualKeyboard</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- VirtualKeyboard.lua --
-- Written by Kip Turner, copyright ROBLOX 2016 --


local CoreGui = game:GetService('CoreGui')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local GuiService = game:GetService('GuiService')
local HttpService = game:GetService('HttpService')
local ContextActionService = game:GetService('ContextActionService')
local PlayersService = game:GetService('Players')
local SoundService = game:GetService('SoundService')
local TextService = game:GetService('TextService')

local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local Util = require(RobloxGui.Modules.Settings.Utility)

local BACKGROUND_OPACITY = 0.3
local NORMAL_KEY_COLOR = Color3.new(49/255,49/255,49/255)
local HOVER_KEY_COLOR = Color3.new(49/255,49/255,49/255)
local PRESSED_KEY_COLOR = Color3.new(0,162/255,1)
local SET_KEY_COLOR = Color3.new(0,162/255,1)

local KEY_TEXT_COLOR = Color3.new(1,1,1)

local useSetTextFromInputSuccess, useSetTextFromInputValue = pcall(function() return settings():GetFFlag("UseSetTextFromInputForVrKeyboard") end)
local useSetTextFromInput = useSetTextFromInputSuccess and useSetTextFromInputValue
---------------------------------------- KEYBOARD LAYOUT --------------------------------------
local MINIMAL_KEYBOARD_LAYOUT = HttpService:JSONDecode([==[
[
  [
    {
      "a": 7,
      "w": 0.8
    },
    "*",
    "Q",
    "W",
    "E",
    "R",
    "T",
    "Y",
    "U",
    "I",
    "O",
    "P",
    {
      "w": 1.8
    },
    "Delete"
  ],
  [
    {
      "w": 1.6
    },
    "Caps",
    "A",
    "S",
    "D",
    "F",
    "G",
    "H",
    "J",
    "K",
    "L",
    "?",
    {
      "h": 2,
      "w2": 2.4,
      "h2": 1,
      "x2": -1.4,
      "y2": 1
    },
    "Enter"
  ],
  [
    {
      "w": 2.2
    },
    "Shift",
    "Z",
    "X",
    "C",
    "V",
    "B",
    "N",
    "M",
    "."
  ],
  [
    {
      "w": 2.2
    },
    "123/sym",
    {
      "w": 8
    },
    "",
    {
      "w": 2.4
    },
    "<Speaker>"
  ]
]
]==])

local MINIMAL_KEYBOARD_LAYOUT_SYMBOLS = HttpService:JSONDecode([==[
[
  [
    {
      "a": 7,
      "w": 0.8
    },
    "*",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "0",
    {
      "w": 1.8
    },
    "Delete"
  ],
  [
    {
      "w": 1.6
    },
    "!",
    "@",
    "#",
    "$",
    "%",
    "^",
    "&",
    "(",
    ")",
    "=",
    "?",
    {
      "h": 2,
      "w2": 2.4,
      "h2": 1,
      "x2": -1.4,
      "y2": 1
    },
    "Enter"
  ],
  [
    {
      "w": 1.2
    },
    "/",
    "-",
    "+",
    "_",
    ":",
    ";",
    "'",
    "\"",
    ",",
    "."
  ],
  [
    {
      "w": 2.2
    },
    "abc",
    {
      "w": 8
    },
    "",
    {
      "w": 2.4
    },
    "<Speaker>"
  ]
]
]==])


---------------------------------------- END KEYBOARD LAYOUT --------------------------------------


local VOICE_STATUS_CODE_ENUM = {}
do
	local STATUS_CODES =
	{
	    'ASR_STATUS_OK',
	    'ASR_STATUS_CANCELLED',
	    'ASR_STATUS_UNKNOWN',
	    'ASR_STATUS_INVALID_ARGUMENTS',
	    'ASR_STATUS_DEADLINE_EXCEEDED',
	    'ASR_STATUS_NOT_FOUND',
	    'ASR_STATUS_ALREADY_EXISTS',
	    'ASR_STATUS_PERMISSION_DENIED',
	    'ASR_STATUS_UNAUTHENTICATED',
	    'ASR_STATUS_RESOURCE_EXHAUSTED',
	    'ASR_STATUS_FAILED_PRECONDITION',
	    'ASR_STATUS_ABORTED',
	    'ASR_STATUS_OUT_OF_RANGE',
	    'ASR_STATUS_UNIMPLEMENTED',
	    'ASR_STATUS_INTERNAL',
	    'ASR_STATUS_UNAVAILABLE',
	    'ASR_STATUS_DATA_LOSS',
	    -- last official google response

	    -- Roblox statuses
	    'ASR_STATUS_NOT_ENABLED',
	    'ASR_STATUS_LOW_CONFIDENCE',
	    'ASR_STATUS_INVALID_JSON'
	};

	for i, code in pairs(STATUS_CODES) do
		VOICE_STATUS_CODE_ENUM[code] = i-1
	end
end

local function tokenizeString(str, tokenChar)
	local words = {}
	for word in string.gmatch(str, '([^' .. tokenChar .. ']+)') do
	    table.insert(words, word)
	end
	return words
end

local function ConvertFontSizeEnumToInt(fontSizeEnum)
	local result = string.match(fontSizeEnum.Name, '%d+')
	return (result and tostring(result)) or 12
end


-- RayPlaneIntersection

-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
local function RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	planeNormal = planeNormal.unit
	ray = ray.Unit
	-- compute Pn (dot) Rd = Vd and check if Vd == 0 then we know ray is parallel to plane
	local Vd = planeNormal:Dot(ray.Direction)
	
	-- could fuzzy equals this a little bit to account for imprecision or very close angles to zero
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd

	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end
	
	return ray.Origin + ray.Direction * t
end

function Clamp(low, high, input)
	return math.max(low, math.min(high, input))
end

-- No rotation as of yet
local function PointInGuiObject(object, x, y)
	local minPt = object.AbsolutePosition
	local maxPt = object.AbsolutePosition + object.AbsoluteSize
	if minPt.X <= x and maxPt.X >= x and minPt.Y <= y and maxPt.Y >= y then
		return true
	end
	return false
end

local function FindAncestorOfType(object, ancestorType)
	if not object then return nil end

	local parent = object.Parent
	if parent and  parent:IsA(ancestorType) then
		return parent
	end

	return FindAncestorOfType(parent, ancestorType)
end

local function ExtendedInstance(instance)
	local this = {}
	do
		local mt =
		{
			__index = function (t, k)
				return instance[k]
			end;

			__newindex = function (t, k, v)
				instance[k] = v
			end;
		}
		setmetatable(this, mt)
	end
	return this
end

local function IsVoiceToTextEnabled()
	local success, flagValue = pcall(function() return settings():GetFFlag("EnableVoiceRecording") end)
	return success and flagValue == true
end

local function CreateVRButton(instance)
	local newButton = ExtendedInstance(instance)

	rawset(newButton, "OnEnter", function(self)
	end)
	rawset(newButton, "OnLeave", function(self)
	end)
	rawset(newButton, "OnDown", function(self)
	end)
	rawset(newButton, "OnUp", function(self)
	end)
	rawset(newButton, "ContainsPoint", function(self, x, y)
		return PointInGuiObject(instance, x, y)
	end)
	rawset(newButton, "Update", function(self)
	end)

	return newButton
end

local selectionRing = Util:Create'ImageLabel'
{
	Name = 'SelectionRing';
	Size = UDim2.new(1, -6, 1, -6);
	Position = UDim2.new(0, 4, 0, 3);
	Image = 'rbxasset://textures/ui/menu/buttonHover.png';
	ScaleType = Enum.ScaleType.Slice;
	SliceCenter = Rect.new(94/2, 94/2, 94/2, 94/2);
	BackgroundTransparency = 1;
}

local KEY_ICONS =
{
	["<Speaker>"] = {Asset = "rbxasset://textures/ui/Keyboard/mic_icon.png", AspectRatio = 0.615};
}

local function CreateKeyboardKey(keyboard, layoutData, keyData)
	local isSpecialShapeKey = layoutData['width2'] and layoutData['height2'] and layoutData['x2'] and layoutData['y2']

	local newKeyElement = Util:Create'ImageButton'
	{
		Name = keyData[1];
		Position = UDim2.new(layoutData['x'], 0, layoutData['y'], 0);
		Size = UDim2.new(layoutData['width'], 0, layoutData['height'], 0);
		BorderSizePixel = 0;
		Image = "";
		BackgroundTransparency = 1;
		ZIndex = 1;
	}
	local keyText = Util:Create'TextLabel'
	{
		Name = "KeyText";
		Text = keyData[#keyData];
		Position = UDim2.new(0, -10, 0, -10);
		Size = UDim2.new(1, 0, 1, 0);
		Font = Enum.Font.SourceSansBold;
		FontSize = Enum.FontSize.Size96;
		TextColor3 = KEY_TEXT_COLOR;
		BackgroundTransparency = 1;
		Selectable = true;
		ZIndex = 2;
		Parent = newKeyElement;
	}
	local backgroundImage = Util:Create'Frame'
	{
		Name = 'KeyBackground';
		Size = UDim2.new(1,-10,1,-10);
		Position = UDim2.new(0,-5,0,-5);
		BackgroundColor3 = NORMAL_KEY_COLOR;
		BackgroundTransparency = BACKGROUND_OPACITY;
		BorderSizePixel = 0;
		Parent = newKeyElement;
	}
	
	local selectionObject = Util:Create'ImageLabel'
	{
		Name = 'SelectionObject';
		Size = UDim2.new(1,0,1,0);
		BackgroundTransparency = 1;
		Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png";
		ImageTransparency = 0;
		ScaleType = Enum.ScaleType.Slice;
		SliceCenter = Rect.new(12,12,52,52);
		BorderSizePixel = 0;
	}

	newKeyElement.SelectionImageObject = Util:Create'ImageLabel'
	{
		Visible = false;
	}

 	-- Special silly enter key nonsense
	local secondBackgroundImage = nil
	local specialSelectionObject, specialSelectionObject2, specialSelectionObject3 = nil, nil, nil
	if isSpecialShapeKey then
		secondBackgroundImage = Util:Create'ImageButton'
		{
			Name = 'KeyBackground';
			Position = UDim2.new(layoutData['x2'] / layoutData['width'], -5, layoutData['y2'] / layoutData['height'], -5);
			Size = UDim2.new(layoutData['width2'] / layoutData['width'], 0, layoutData['height2'] / layoutData['height'], -10);
			BackgroundColor3 = NORMAL_KEY_COLOR;
			BackgroundTransparency = BACKGROUND_OPACITY;
			BorderSizePixel = 0;
			AutoButtonColor = false;
			Parent = newKeyElement;
		}
		if layoutData['x2'] <= 0 then
			keyText.Size = secondBackgroundImage.Size - UDim2.new(0,10,0,0)
			keyText.Position = secondBackgroundImage.Position
			secondBackgroundImage.Size = secondBackgroundImage.Size - UDim2.new(1,0,0,0)
		end

		do
			specialSelectionObject = Util:Create'Frame'
			{
				Name = 'SpecialSelectionObject';
				Size = UDim2.new(1,0,0.5,0);
				Position = UDim2.new(0,0,0.5,0);
				BackgroundTransparency = 1;
				ClipsDescendants = true;
				Util:Create'ImageLabel'
				{
					Name = 'Borders';
					Position = UDim2.new(-1,0,-1,0);
					Size = UDim2.new(2,0,2,0);
					BackgroundTransparency = 1;
					Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png";
					ImageTransparency = 0;
					ScaleType = Enum.ScaleType.Slice;
					SliceCenter = Rect.new(12,12,52,52);
				};
			}
			specialSelectionObject2 = specialSelectionObject:Clone()
			specialSelectionObject2.Size = UDim2.new(1,0,0.5,5)
			specialSelectionObject2.Position = UDim2.new(0,0,0,0)
			specialSelectionObject2.Borders.Size = UDim2.new(1,0,1,30)
			specialSelectionObject2.Borders.Position = UDim2.new(0,0,0,0)

			specialSelectionObject3 = specialSelectionObject:Clone()
			specialSelectionObject3.Size = UDim2.new(1,5,1,0)
			specialSelectionObject3.Position = UDim2.new(0,0,0,0)
			specialSelectionObject3.Borders.Size = UDim2.new(1,30,1,0)
			specialSelectionObject3.Borders.Position = UDim2.new(0,0,0,0)
		end
		-- End of nonsense
	end

	local newKey = CreateVRButton(newKeyElement)

	local hovering = false
	local pressed = false
	local isAlpha = #keyData == 1 and type(keyData[1]) == 'string' and #keyData[1] == 1 and
	                string.byte(keyData[1]) >= string.byte("A") and string.byte(keyData[1]) <= string.byte("z")

	local icon = nil
	if keyData[1] and KEY_ICONS[keyData[1]] then
		keyText.Visible = false
		icon = Util:Create'ImageLabel'
		{
			Name = 'KeyIcon';
			Size = UDim2.new(KEY_ICONS[keyData[1]].AspectRatio, -20, 1, -20);
			SizeConstraint = Enum.SizeConstraint.RelativeYY;
			BackgroundTransparency = 1;
			Image = KEY_ICONS[keyData[1]].Asset;
			Parent = backgroundImage;
		}

		local function onChanged(prop)
			if prop == 'AbsoluteSize' then
				icon.Position = UDim2.new(0.5,-icon.AbsoluteSize.X/2,0.5,-icon.AbsoluteSize.Y/2);
			end
		end
		icon.Changed:connect(onChanged)
		onChanged('AbsoluteSize')
	end

	local function isEnabled()
		if newKey:GetCurrentKeyValue() == "<Speaker>" then
			return IsVoiceToTextEnabled()
		end
		return true
	end

	local function onClicked()
		local keyValue = nil
		local currentKeySetting = newKey:GetCurrentKeyValue()

		if currentKeySetting == 'Shift' then
			keyboard:SetShift(not keyboard:GetShift())
		elseif currentKeySetting == 'Caps' then
			keyboard:SetCaps(not keyboard:GetCaps())
		elseif currentKeySetting == 'Enter' then
			keyboard:SubmitText(true, true)
		elseif currentKeySetting == 'Delete' then
			keyboard:BackspaceAtCursor()
		elseif currentKeySetting == "123/sym" then
			keyboard:SetCurrentKeyset(2)
		elseif currentKeySetting == "abc" then
			keyboard:SetCurrentKeyset(1)
		elseif currentKeySetting == "<Speaker>" then
			keyboard:SetVoiceMode(true)
		elseif currentKeySetting == 'Tab' then
			keyValue = '\t'
		else
			keyValue = currentKeySetting
		end

		if keyValue ~= nil then
			keyboard:SubmitCharacter(keyValue, isAlpha)
		end
	end

	local function setKeyColor(newColor, hovering)
		backgroundImage.BackgroundColor3 = newColor
		if secondBackgroundImage then
			secondBackgroundImage.BackgroundColor3 = newColor
		end
		if isSpecialShapeKey then
			specialSelectionObject.Parent = hovering and backgroundImage or nil
			specialSelectionObject2.Parent = hovering and backgroundImage or nil
			specialSelectionObject3.Parent = hovering and secondBackgroundImage or nil
		else
			selectionObject.Parent = hovering and backgroundImage or nil
		end
	end

	local function update()
		local currentKey = newKey:GetCurrentKeyValue()

		if pressed then
			setKeyColor(PRESSED_KEY_COLOR, false)
		elseif hovering then
			setKeyColor(HOVER_KEY_COLOR, true)
		elseif currentKey == 'Caps' and keyboard:GetCaps() then
			setKeyColor(SET_KEY_COLOR, false)
		elseif currentKey == 'Shift' and keyboard:GetShift() then
			setKeyColor(SET_KEY_COLOR, false)
		elseif currentKey == 'abc' then
			setKeyColor(SET_KEY_COLOR, false)
		else
			setKeyColor(NORMAL_KEY_COLOR, false)
		end

		if icon then
			icon.ImageTransparency = isEnabled() and 0 or 0.5
		end

		keyText.Text = newKey:GetCurrentKeyValue()
	end

	local hoveringGuiElements = {}

	rawset(newKey, "OnEnter", function(self)
		hovering = true
		update()
	end)
	rawset(newKey, "OnLeave", function(self)
		if not next(hoveringGuiElements) then
			hovering = false
			pressed = false
			update()
		end
	end)
	rawset(newKey, "OnDown", function(self)
		pressed = true
		update()
		-- Fire the onclick when pressing down on the button;
		-- pressing down and up on the same button is difficult
		-- in VR because your head is constantly moving around
		onClicked()
	end)
	rawset(newKey, "OnUp", function(self)
		pressed = false
		update()
	end)
	rawset(newKey, "GetCurrentKeyValue", function(self)
		local shiftEnabled = keyboard:GetShift()
		local capsEnabled = keyboard:GetCaps()

		if isAlpha then
			if capsEnabled and shiftEnabled then
				return string.lower(keyData[#keyData])
			elseif capsEnabled or shiftEnabled then
				return keyData[1]
			else
				return string.lower(keyData[#keyData])
			end
		end

		if shiftEnabled then
			return keyData[1]
		end

		return keyData[#keyData]
	end)
	rawset(newKey, "ContainsPoint", function(self, x, y)
		return PointInGuiObject(backgroundImage, x, y) or
		       (secondBackgroundImage and PointInGuiObject(secondBackgroundImage, x, y))
	end)
	rawset(newKey, "Update", function(self)
		update()
	end)
	rawset(newKey, "GetInstance", function(self)
		return newKeyElement
	end)

	newKeyElement.MouseButton1Down:connect(function() newKey:OnDown() end)
	newKeyElement.MouseButton1Up:connect(function() newKey:OnUp() end)
	newKeyElement.SelectionGained:connect(function() hoveringGuiElements[newKeyElement] = true newKey:OnEnter() end)
	newKeyElement.SelectionLost:connect(function() hoveringGuiElements[newKeyElement] = nil newKey:OnLeave() end)
	-- For the time being, we will simulate onClick events in the OnDown() event
	-- newKeyElement.MouseButton1Click:connect(function() onClicked() end)
	if secondBackgroundImage then
		-- For the time being, we will simulate onClick events in the OnDown() event
		-- secondBackgroundImage.MouseButton1Click:connect(onClicked)
		secondBackgroundImage.MouseButton1Down:connect(function() newKey:OnDown() end)
		secondBackgroundImage.MouseButton1Up:connect(function() newKey:OnUp() end)
		secondBackgroundImage.SelectionGained:connect(function()
			hoveringGuiElements[secondBackgroundImage] = true
			newKey:OnEnter()
		end)
		secondBackgroundImage.SelectionLost:connect(function()
			hoveringGuiElements[secondBackgroundImage] = nil
			newKey:OnLeave()
		end)
	end

	update()

	return newKey
end

local function CreateBaseVoiceState()
	local this = {}
	this.Name = "Base"

	function this:TransitionFrom()
	end
	function this:TransitionTo()
	end

	return this
end

local function CreateListeningVoiceState()
	local this = CreateBaseVoiceState()

	this.Name = "Listening"

	function this:TransitionTo()
		pcall(function() SoundService:BeginRecording() end)
	end

	return this
end

local function CreateProcessingVoiceState()
	local this = CreateBaseVoiceState()

	this.Name = "Processing"

	local finished = false
	local result = nil

	function this:TransitionTo()
		coroutine.wrap(function()
			pcall(function() result = SoundService:EndRecording() end)
			finished = true
		end)()
	end

	function this:GetResultAsync()
		while not finished do
			wait()
		end
		return result
	end

	return this
end

local function CreateWaitingVoiceState()
	local this = CreateBaseVoiceState()

	this.Name = "Waiting"

	return this
end

local VoiceTransitions = {Listening = {Processing = true}, Processing = {Waiting = true}, Waiting = {Listening = true}}

local VoiceToTextFSM = {}
do
	VoiceToTextFSM.CurrentState = CreateWaitingVoiceState()

	local stateTransitionedSignal = Instance.new('BindableEvent')

	function VoiceToTextFSM:TransitionState(newState)
		-- If it is a new state then lets cleanup and activate it
		if VoiceTransitions[self.CurrentState.Name][newState.Name] then
			self.CurrentState:TransitionFrom()
			self.CurrentState = newState
			self.CurrentState:TransitionTo()
			stateTransitionedSignal:Fire(self.CurrentState)
			return true
		end
		return false
	end

	function VoiceToTextFSM:GetCurrentState()
		return self.CurrentState
	end

	VoiceToTextFSM.StateTransitionedEvent = stateTransitionedSignal.Event
end



local function ConstructKeyboardUI(keyboardLayoutDefinitions)
	local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
	local panel = Panel3D.Get("Keyboard")
	panel:SetVisible(false)

	-- DEBUG setting
	-- panel:GetGUI().Parent = workspace


	local buttons = {}

	local keyboardContainer = Util:Create'Frame'
	{
		Name = 'VirtualKeyboard';
		Size = UDim2.new(1, 0, 1, 0);
		Position = UDim2.new(0, 0, 0, 0);
		BackgroundTransparency = 1;
		Active = true;
		Visible = false;
	};

	local textEntryBackground = Util:Create'ImageLabel'
	{
		Name = 'TextEntryBackground';
		Size = UDim2.new(0.5,0,0.125,0);
		Position = UDim2.new(0.25,0,0,0);
		Image = "";
		BackgroundTransparency = 0.5;
		BackgroundColor3 = Color3.new(31/255,31/255,31/255);
		BorderSizePixel = 0;
		ClipsDescendants = true;
		Parent = keyboardContainer;
	}
		local textfieldBackground = Util:Create'Frame'
		{
			Name = 'TextfieldBackground';
			Position = UDim2.new(0,2,0,2);
			Size = UDim2.new(1, -4, 1, -4);
			BackgroundTransparency = 0;
			BackgroundColor3 = Color3.new(209/255,216/255,221/255);
			BorderSizePixel = 0;
			Visible = true;
			Parent = textEntryBackground;
		};
			local textEntryField = Util:Create'TextButton'
			{
				Name = "TextEntryField";
				Text = "";
				Position = UDim2.new(0,4,0,4);
				Size = UDim2.new(1, -8, 1, -8);
				Font = Enum.Font.SourceSans;
				FontSize = Enum.FontSize.Size60;
				TextXAlignment = Enum.TextXAlignment.Left;
				BackgroundTransparency = 1;
				BorderSizePixel = 0;
				Parent = textfieldBackground;
			}
				local textfieldCursor = Util:Create'Frame'
				{
					Name = 'TextfieldCursor';
					Size = UDim2.new(0, 5, 0.9, 0);
					Position = UDim2.new(0, 0, 0.05, 0);
					BackgroundTransparency = 0;
					BackgroundColor3 = SET_KEY_COLOR;
					BorderSizePixel = 0;
					Visible = true;
					ZIndex = 2;
					Parent = textEntryField;
				};

	local closeButtonElement = Util:Create'ImageButton'
	{
		Name = 'CloseButton';
		Size = UDim2.new(0.075,-10,0.198,-10);
		Position = UDim2.new(0,-5,0,-35);
		Image = "rbxasset://textures/ui/Keyboard/close_button_background.png";
		BackgroundTransparency = 1;
		AutoButtonColor = false;
		Parent = keyboardContainer;
	}
	do
		closeButtonElement.SelectionImageObject = Util:Create'ImageLabel'
		{
			Name = 'Selection';
			Size = UDim2.new(0.9,0,0.9,0);
			Position = UDim2.new(0.05,0,0.05,0);
			Image = "rbxasset://textures/ui/Keyboard/close_button_selection.png";
			BackgroundTransparency = 1;
		}
		Util:Create'ImageLabel'
		{
			Name = 'Icon';
			Size = UDim2.new(0.5,0,0.5,0);
			Position = UDim2.new(0.25,0,0.25,0);
			Image = "rbxasset://textures/ui/Keyboard/close_button_icon.png";
			BackgroundTransparency = 1;
			Parent = closeButtonElement;
		}
	end
	local closeButton = CreateVRButton(closeButtonElement)
	table.insert(buttons, closeButton)

	local voiceRecognitionContainer = Util:Create'Frame'
	{
		Name = 'VoiceRecognitionContainer';
		Size = UDim2.new(1, 0, 0.85, 0);
		Position = UDim2.new(0, 0, 0.15, 0);
		BackgroundTransparency = 1;
		Active = true;
		Visible = false;
		Parent = keyboardContainer;
	};
	do
		local voiceRecognitionBackground1 = Util:Create'Frame'
		{
			Name = 'voiceRecognitionBackground1';
			Size = UDim2.new(1, 0, 0.75, 0);
			Position = UDim2.new(0, 0, 0, 0);
			BackgroundColor3 = NORMAL_KEY_COLOR;
			BackgroundTransparency = BACKGROUND_OPACITY;
			BorderSizePixel = 0;
			Active = true;
			Parent = voiceRecognitionContainer;
		};
		local voiceRecognitionBackground2 = voiceRecognitionBackground1:Clone()
		voiceRecognitionBackground2.Size = UDim2.new(1 - 0.2, 0, 0.25, 0)
		voiceRecognitionBackground2.Position = UDim2.new(0, 0, 0.75, 0)
		voiceRecognitionBackground2.Parent = voiceRecognitionContainer
	end

	local voiceDoneButton = CreateVRButton(Util:Create'TextButton'
	{
		Name = 'DoneButton';
		Size = UDim2.new(0.2, -5, 0.25, -5);
		Position = UDim2.new(1 - 0.2, 5, 0.75, 5);
		Text = "Done";
		BackgroundColor3 = SET_KEY_COLOR;
		Font = Enum.Font.SourceSansBold;
		FontSize = Enum.FontSize.Size96;
		TextColor3 = KEY_TEXT_COLOR;
		BackgroundTransparency = 0;
		AutoButtonColor = false;
		BorderSizePixel = 0;
		Parent = voiceRecognitionContainer;
	})
	table.insert(buttons, voiceDoneButton)

	local voiceProcessingStatus = Util:Create'TextLabel'
	{
		Name = 'VoiceProcessingStatus';
		Size = UDim2.new(0, 0, 0, 0);
		Position = UDim2.new(0.5, 0, 0.33, 0);
		Text = "";
		Font = Enum.Font.SourceSansBold;
		FontSize = Enum.FontSize.Size96;
		TextColor3 = KEY_TEXT_COLOR;
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		Parent = voiceRecognitionContainer;
	}

	local function CreateVoiceVisualizerWidget()
		local this = {}

		local bars = {}

		local numOfBars = 50
		local numOfWaves = 4
		local waveSpeed = 2.5

		local container = Util:Create'Frame'
		{
			Name = 'VoiceVisualizerContainer';
			Size = UDim2.new(1, 0, 1, 0);
			BackgroundTransparency = 1;
		}
		this.Container = container

		for i = 1, numOfBars do
			local bar = Util:Create'Frame'
			{
				Name = 'Bar';
				Size = UDim2.new(1/numOfBars, -4, 1, 0);
				Position = UDim2.new(i/numOfBars, 0, 0, 0);
				BackgroundTransparency = 0;
				BackgroundColor3 = KEY_TEXT_COLOR;
				Parent = container;
			}
			table.insert(bars, bar)
		end

		function this:StartAnimation()
			RunService:UnbindFromRenderStep("VoiceVisualizerWidget")
			RunService:BindToRenderStep("VoiceVisualizerWidget", Enum.RenderPriority.First.Value,
				function()
					local movementPerBar = (numOfWaves*2*math.pi) / numOfBars
					for i, bar in pairs(bars) do
						local height = math.abs(math.sin(tick() * waveSpeed + i * movementPerBar)) + math.abs(math.cos(tick() * waveSpeed + i * movementPerBar))
						height = ((height / 2) - 0.3) * (1/(1-0.3))
						bar.Size = UDim2.new(1/numOfBars, -4, height, 0)
						bar.Position = UDim2.new(i/numOfBars, 0, (1-height) / 2, 0)
					end
				end)
		end

		function this:StopAnimation()
			RunService:UnbindFromRenderStep("VoiceVisualizerWidget")
		end

		return this
	end

	local voiceVisualizer = CreateVoiceVisualizerWidget()
	voiceVisualizer.Container.Parent = voiceRecognitionContainer
	voiceVisualizer.Container.Size = UDim2.new(0.5,0,0.4,0)
	voiceVisualizer.Container.Position = UDim2.new(0.25,0,0.4,0)

	local newKeyboard = ExtendedInstance(keyboardContainer)

	local keyboardOptions = nil
	local keysets = {}

	local capsLockEnabled = false
	local shiftEnabled = false

	local textfieldCursorPosition = 0

	local openedEvent = Instance.new('BindableEvent')
	local closedEvent = Instance.new('BindableEvent')
	local opened = false

	local function SetTextFieldCursorPosition(newPosition)
		textfieldCursorPosition = Clamp(0, #textEntryField.Text, newPosition)
		if not textEntryField.TextFits then
			textfieldCursorPosition = #textEntryField.Text
		end

		local textSize = TextService:GetTextSize(
			string.sub(textEntryField.Text, 1, textfieldCursorPosition),
			ConvertFontSizeEnumToInt(textEntryField.FontSize),
			textEntryField.Font,
			textEntryField.AbsoluteSize)
		textfieldCursor.Position = UDim2.new(0, textSize.x, textfieldCursor.Position.Y.Scale, textfieldCursor.Position.Y.Offset)
	end

	local function UpdateTextEntryFieldText(newText)
		local textSet = false
		if useSetTextFromInput then
			textSet = pcall(function() textEntryField:SetTextFromInput(newText) end)
		end

		if not textSet then
			textEntryField.Text = newText
		end

		SetTextFieldCursorPosition(textfieldCursorPosition)
	end

	local buffer = ""
	local function getBufferText()
		if keyboardOptions and keyboardOptions.TextBox then
			return keyboardOptions.TextBox.Text
		end
		return buffer
	end
	local function setBufferText(newBufferText)
		if keyboardOptions and keyboardOptions.TextBox then
			keyboardOptions.TextBox.Text = newBufferText
		elseif buffer ~= newBufferText then
			buffer = newBufferText
			UpdateTextEntryFieldText(buffer)
		end
	end

	local function calculateTextCursorPosition(x, y)
		x = x - textEntryField.AbsolutePosition.x
		y = y - textEntryField.AbsolutePosition.y

		for i = 1, #textEntryField.Text do
			local textSize = TextService:GetTextSize(
				string.sub(textEntryField.Text, 1, i),
				ConvertFontSizeEnumToInt(textEntryField.FontSize),
				textEntryField.Font,
				textEntryField.AbsoluteSize)
			if textSize.x > x then
				return i - 1
			end
		end

		return #textEntryField.Text
	end

	local currentKeyset = nil

	rawset(newKeyboard, "OpenedEvent",  openedEvent.Event)
	rawset(newKeyboard, "ClosedEvent",  closedEvent.Event)

	rawset(newKeyboard, "GetCurrentKeyset", function(self)
		return keysets[currentKeyset]
	end)

	rawset(newKeyboard, "SetCurrentKeyset", function(self, newKeyset)
		if newKeyset ~= currentKeyset and keysets[newKeyset] ~= nil then
			if keysets[currentKeyset] and keysets[currentKeyset].container then
				keysets[currentKeyset].container.Visible = false
			end

			currentKeyset = newKeyset

			if keysets[currentKeyset] and keysets[currentKeyset].container then
				keysets[currentKeyset].container.Visible = true
			end
		end
	end)

	rawset(newKeyboard, "SetVoiceMode", function(self, inVoiceMode)
		inVoiceMode = inVoiceMode and IsVoiceToTextEnabled()

		local currentKeysetObject = self:GetCurrentKeyset()
		if currentKeysetObject and currentKeysetObject.container then
			currentKeysetObject.container.Visible = not inVoiceMode
		end

		voiceRecognitionContainer.Visible = inVoiceMode

		if inVoiceMode then
			VoiceToTextFSM:TransitionState(CreateListeningVoiceState())
		end
	end)

	rawset(newKeyboard, "GetCaps", function(self)
		return capsLockEnabled
	end)

	rawset(newKeyboard, "SetCaps", function(self, newCaps)
		capsLockEnabled = newCaps
		for _, key in pairs(self:GetCurrentKeyset().keys) do
			key:Update()
		end
	end)

	rawset(newKeyboard, "GetShift", function(self)
		return shiftEnabled
	end)

	rawset(newKeyboard, "SetShift", function(self, newShift)
		shiftEnabled = newShift
		for _, key in pairs(self:GetCurrentKeyset().keys) do
			key:Update()
		end
	end)

	local ignoreFocusedLost = false

	local textChangedConn = nil
	local textBoxFocusLostConn = nil
	local panelClosedConn = nil

	local function disconnectKeyboardEvents()
		if textChangedConn then textChangedConn:disconnect() end
		textChangedConn = nil
		if textBoxFocusLostConn then textBoxFocusLostConn:disconnect() end
		textBoxFocusLostConn = nil
		if panelClosedConn then panelClosedConn:disconnect() end
		panelClosedConn = nil
	end

	rawset(newKeyboard, "Open", function(self, options)
		if opened then return end
		opened = true

		keyboardOptions = options

		self:SetCurrentKeyset(1)
		self:SetVoiceMode(false)
		keyboardContainer.Visible = true

		panel:ResizeStuds(5.9, 2.25, 320)

		local localCF = CFrame.new()

		disconnectKeyboardEvents()
		if options.TextBox then
			textChangedConn = options.TextBox.Changed:connect(function(prop)
				if prop == 'Text' then
					UpdateTextEntryFieldText(options.TextBox.Text)
				end
			end)
			textBoxFocusLostConn = options.TextBox.FocusLost:connect(function(submitted)
				if not ignoreFocusedLost then
					self:Close(submitted)
				end
			end)
			if options.TextBox.ClearTextOnFocus then
				setBufferText("")
			else
				UpdateTextEntryFieldText(options.TextBox.Text)
			end

			-- Find panel for 2d ui?
			local textboxPanel = Panel3D.FindContainerOf(options.TextBox)
			if textboxPanel then
				panelClosedConn = Panel3D.OnPanelClosed.Event:connect(function(closedPanelName)
					if closedPanelName == textboxPanel.name then
						self:Close(false)
					end
				end)

				-- Attach to it if it's linked to our keyboard panel
				if textboxPanel.linkedTo == panel then
					local panelCF = textboxPanel.localCF
					localCF = panelCF * CFrame.new(0, (-textboxPanel.height / 2) - 0.5, 0) * 
										CFrame.Angles(math.rad(30), 0, 0) * 
										CFrame.new(0, (-panel.height / 2) - 0.5, 0)
				else
					--Otherwise, best-guess where it should go based on the user's head.
					local headForwardCF = Panel3D.GetHeadLookXZ(true)
					localCF = headForwardCF * CFrame.Angles(math.rad(22.5), 0, 0) * CFrame.new(0, -1, 5)
				end
			else -- no panel!
				local headForwardCF = Panel3D.GetHeadLookXZ(true)
				localCF = headForwardCF * CFrame.Angles(math.rad(22.5), 0, 0) * CFrame.new(0, -1, 5)
			end
		else
			setBufferText("")
		end

		ContextActionService:BindCoreAction("VirtualKeyboardControllerInput",
			function(actionName, inputState, inputObject)
				if inputState == Enum.UserInputState.End then
					if inputObject.KeyCode == Enum.KeyCode.ButtonL1 then
						SetTextFieldCursorPosition(textfieldCursorPosition - 1)
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonR1 then
						SetTextFieldCursorPosition(textfieldCursorPosition + 1)
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonX then
						self:BackspaceAtCursor()
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonY then
						self:SubmitCharacter(" ", false)
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonL2 then
						if currentKeyset then
							-- Go to the next keyset
							self:SetCurrentKeyset((currentKeyset % #keysets) + 1)
						end
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonL3 then
						self:SetCaps(not self:GetCaps())
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonB then
						self:Close(false)
					end
				end
			end,
			false,
			Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1, Enum.KeyCode.ButtonL2, Enum.KeyCode.ButtonL3, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonB)

		self.Parent = panel:GetGUI()

		panel:SetType(Panel3D.Type.Fixed, { CFrame = localCF })
		panel:SetCanFade(false)
		panel:SetVisible(true, true)
		panel:ForceShowUntilLookedAt()

		Panel3D.Get("Topbar3D"):SetVisible(false)

		function panel:OnUpdate()
		end

		openedEvent:Fire()
	end)

	rawset(newKeyboard, "Close", function(self, submit)
		submit = (submit == true)

		if not opened then return end
		opened = false

		disconnectKeyboardEvents()

		ContextActionService:UnbindCoreAction("VirtualKeyboardControllerInput")
		-- Clean-up
		panel:OnMouseLeave()
		panel:SetVisible(false, true)
		keyboardContainer.Visible = false

		Panel3D.Get("Topbar3D"):SetVisible(true)
		
		self:SubmitText(submit, false)
		closedEvent:Fire()
	end)

	rawset(newKeyboard, "SubmitText", function(self, submit, keepKeyboardOpen)
		local keyboardTextbox = keyboardOptions and keyboardOptions.TextBox
		if keyboardTextbox then
			if submit then
				keyboardTextbox.Text = getBufferText()
			end
			-- Only keep text boxes open for coreguis, such as chat
			local textboxPanel = Panel3D.FindContainerOf(keyboardTextbox)
			local reopenKeyboard = keepKeyboardOpen and textboxPanel and textboxPanel.linkedTo == panel

			if reopenKeyboard then
				ignoreFocusedLost = true
			end

			keyboardTextbox:ReleaseFocus(submit)

			if reopenKeyboard then
				keyboardTextbox:CaptureFocus()
				ignoreFocusedLost = false
			end
		end
	end)

	rawset(newKeyboard, "GetCurrentOptions", function(self)
		return keyboardOptions
	end)

	rawset(newKeyboard, "BackspaceAtCursor", function(self)
		if textfieldCursorPosition >= 1 then
			local bufferText = getBufferText()
			local newBufferText = string.sub(bufferText, 1, textfieldCursorPosition - 1) .. string.sub(bufferText, textfieldCursorPosition + 1, #bufferText)
			local newCursorPosition = textfieldCursorPosition - 1
			setBufferText(newBufferText)
			SetTextFieldCursorPosition(newCursorPosition)
		end
	end)

	rawset(newKeyboard, "SubmitCharacter", function(self, character, isAnAlphaKey)
		local bufferText = getBufferText()
		local newBufferText = string.sub(bufferText, 1, textfieldCursorPosition) .. character .. string.sub(bufferText, textfieldCursorPosition + 1, #bufferText)
		setBufferText(newBufferText)
		SetTextFieldCursorPosition(textfieldCursorPosition + #character)

		if isAnAlphaKey and self:GetShift() then
			self:SetShift(false)
		end
	end)

	do -- Parse input definition
		for _, keyboardKeyset in pairs(keyboardLayoutDefinitions) do
			local keys = {}
			local keyboardSizeConstrainer = Util:Create'Frame'
			{
				Name = 'KeyboardSizeConstrainer';
				Size = UDim2.new(1, 0, 1, -20);
				Position = UDim2.new(0, 0, 0, 20);
				BackgroundTransparency = 1;
				Parent = keyboardContainer;
			};

			local maxWidth = 0
			local maxHeight = 0
			local y = 0
			for rowNum, rowData in pairs(keyboardKeyset) do
				local x = 0
				local width = 1
				local height = 1
				local width2, height2, x2, y2;
				for columnNum, columnData in pairs(rowData) do
					if type(columnData) == 'table' then
						if columnData['w'] then width = columnData['w'] end
						if columnData['h'] then height = columnData['h'] end
						if columnData['x'] then x = x + columnData['x'] end
						if columnData['y'] then y = y + columnData['y'] end
						if columnData['x2'] then x2 = columnData['x2'] end
						if columnData['y2'] then y2 = columnData['y2'] end
						if columnData['w2'] then width2 = columnData['w2'] end
						if columnData['h2'] then height2 = columnData['h2'] end
					elseif type(columnData) == 'string' then
						if columnData == "" then
							columnData = " "
						end
						-- put key
						local key = CreateKeyboardKey(
							newKeyboard,
							{x = x, y = y, width = width, height = height, x2 = x2, y2 = y2, width2 = width2, height2 = height2},
							tokenizeString(columnData, '\n'))
						table.insert(keys, key)

						x = x + width
						maxWidth = math.max(maxWidth, x)
						maxHeight = math.max(maxHeight, y + height)
						-- reset for the next key
						width = 1
						height = 1
						width2, height2, x2, y2 = nil, nil, nil, nil
					end
				end
				y = y + 1
			end

			-- Fix the positions and sizes to fit in our KeyboardContainer
			for _, element in pairs(keys) do
				element.Position = UDim2.new(element.Position.X.Scale / maxWidth, 0, element.Position.Y.Scale / maxHeight, 0)
				element.Size = UDim2.new(element.Size.X.Scale / maxWidth, 0, element.Size.Y.Scale / maxHeight, 0)
				element.Parent = keyboardSizeConstrainer
			end

			keyboardSizeConstrainer.SizeConstraint = Enum.SizeConstraint.RelativeXX
			keyboardSizeConstrainer.Size = UDim2.new(1, 0, -maxHeight / maxWidth, 0)
			keyboardSizeConstrainer.Position = UDim2.new(0, 0, 1, 0)
			keyboardSizeConstrainer.Visible = false

			table.insert(keysets, {keys = keys, container = keyboardSizeConstrainer})
		end
		newKeyboard:SetCurrentKeyset(1)
	end

	textEntryField.MouseButton1Click:connect(function()
		SetTextFieldCursorPosition(calculateTextCursorPosition(panel.lookAtPixel.X, panel.lookAtPixel.Y))
	end)

	closeButton.MouseButton1Click:connect(function()
		newKeyboard:Close(false)
	end)

	voiceDoneButton.MouseButton1Click:connect(function()
		if VoiceToTextFSM:GetCurrentState().Name == "Listening" then
			VoiceToTextFSM:TransitionState(CreateProcessingVoiceState())
		end
	end)

	local function onVoiceProcessingStateChanged(newState)
		if newState.Name == "Listening" then
			voiceProcessingStatus.Text = "Listening..."
		elseif newState.Name == "Processing" then
			voiceProcessingStatus.Text = "Processing..."
		elseif newState.Name == "Waiting" then
			voiceProcessingStatus.Text = "Done"
		end

		-- Get the result and put it into the textfield
		if newState.Name == "Processing" then
			coroutine.wrap(function()
				voiceVisualizer:StopAnimation()
				local result = newState:GetResultAsync()
				if result and result["Status"] == VOICE_STATUS_CODE_ENUM.ASR_STATUS_OK  then
					setBufferText(result["Response"])
				else
					voiceProcessingStatus.Text = "An error occured, please try again."
					wait(2)
				end
				VoiceToTextFSM:TransitionState(CreateWaitingVoiceState())
			end)()
		elseif newState.Name == "Listening" then
			voiceVisualizer:StartAnimation()
		elseif newState.Name == "Waiting" then
			newKeyboard:SetVoiceMode(false)
		end
	end
	VoiceToTextFSM.StateTransitionedEvent:connect(onVoiceProcessingStateChanged)
	onVoiceProcessingStateChanged(VoiceToTextFSM:GetCurrentState())


	return newKeyboard
end


local Keyboard = nil;
local function GetKeyboard()
	if Keyboard == nil then
		Keyboard = ConstructKeyboardUI({MINIMAL_KEYBOARD_LAYOUT, MINIMAL_KEYBOARD_LAYOUT_SYMBOLS})
	end
	return Keyboard
end



local VirtualKeyboardClass = {}

function VirtualKeyboardClass:CreateVirtualKeyboardOptions(textbox)
	local keyboardOptions = {}

	keyboardOptions.TextBox = textbox

	return keyboardOptions
end

local VirtualKeyboardPlatform = false
do
	-- iOS, Android and Xbox already have platform specific keyboards
	local platform = UserInputService:GetPlatform()
	VirtualKeyboardPlatform = platform == Enum.Platform.Windows or
	                          platform == Enum.Platform.OSX or
	                          platform == Enum.Platform.IOS or 
	                          platform == Enum.Platform.Android
end


function VirtualKeyboardClass:ShowVirtualKeyboard(virtualKeyboardOptions)
	if VirtualKeyboardPlatform and UserInputService.VREnabled then
		GetKeyboard():Open(virtualKeyboardOptions)
	end
end

function VirtualKeyboardClass:CloseVirtualKeyboard()
	if VirtualKeyboardPlatform and UserInputService.VREnabled then
		local currentKeyboard = GetKeyboard()
		currentKeyboard:Close(false)
	end
end

VirtualKeyboardClass.OpenedEvent = GetKeyboard().OpenedEvent
VirtualKeyboardClass.ClosedEvent = GetKeyboard().ClosedEvent


if VirtualKeyboardPlatform then
	UserInputService.TextBoxFocused:connect(function(textbox)
		VirtualKeyboardClass:ShowVirtualKeyboard(VirtualKeyboardClass:CreateVirtualKeyboardOptions(textbox))
	end)
	-- Don't have to hook up to TextBoxFocusReleased because we are already listening to that in keyboard
end


return VirtualKeyboardClass
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0119D14EF6B84BF3BDD1A557E658BB30">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Panel3D</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Panel3D: 3D GUI panels for VR
--written by 0xBAADF00D
--revised/refactored 5/11/16

local UserInputService = game:GetService("UserInputService")
local VRServiceExists, VRService = pcall(function() return game:GetService("VRService") end)
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local PlayersService = game:GetService("Players")
local Utility = require(RobloxGui.Modules.Settings.Utility)

--Panel3D State variables
local renderStepName = "Panel3DRenderStep-" .. game:GetService("HttpService"):GenerateGUID()
local defaultPixelsPerStud = 64
local pointUpCF = CFrame.Angles(math.rad(-90), math.rad(180), 0)
local zeroVector = Vector3.new(0, 0, 0)
local zeroVector2 = Vector2.new(0, 0)
local turnAroundCF = CFrame.Angles(0, math.rad(180), 0)
local fullyOpaqueAtPixelsFromEdge = 10
local fullyTransparentAtPixelsFromEdge = 80
local partThickness = 0.2

local cursorHidden = false
local cursorHideTime = 2.5

local currentModal = nil
local lastModal = nil
local currentMaxDist = math.huge
local currentClosest = nil
local currentCursorParent = nil
local currentCursorPos = zeroVector2
local lastClosest = nil
local currentHeadScale = 1
local panels = {}
local floorRotation = CFrame.new()
local cursor = Utility:Create "ImageLabel" {
	Image = "rbxasset://textures/Cursors/Gamepad/Pointer.png",
	Size = UDim2.new(0, 8, 0, 8),
	BackgroundTransparency = 1,
	ZIndex = 10
}
local partFolder = Utility:Create "Folder" {
	Name = "VRCorePanelParts",
	Archivable = false
}
local effectFolder = Utility:Create "Folder" {
	Name = "VRCoreEffectParts",
	Archivable = false
}
pcall(function()
	GuiService.CoreGuiFolder = partFolder
	GuiService.CoreEffectFolder = effectFolder
end)
--End of Panel3D State variables


--Panel3D Declaration and enumerations
local Panel3D = {}
Panel3D.Type = {
	None = 0,
--	Floor = 1, todo: remove when deemed safe
	Fixed = 2,
	HorizontalFollow = 3,
	FixedToHead = 4
}

Panel3D.OnPanelClosed = Utility:Create 'BindableEvent' {
	Name = 'OnPanelClosed'
}

function Panel3D.GetHeadLookXZ(withTranslation)
	local userHeadCF = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
	local headLook = userHeadCF.lookVector
	local headYaw = math.atan2(-headLook.Z, headLook.X) + math.rad(90)
	local cf = CFrame.Angles(0, headYaw, 0)

	if withTranslation then
		cf = cf + userHeadCF.p
	end
	return cf
end

function Panel3D.FindContainerOf(element)
	for _, panel in pairs(panels) do
		if panel.gui and panel.gui:IsAncestorOf(element) then
			return panel
		end
		for _, subpanel in pairs(panel.subpanels) do
			if subpanel.gui and subpanel.gui:IsAncestorOf(element) then
				return panel
			end
		end
	end
	return nil
end

function Panel3D.SetModalPanel(panel)
	if currentModal == panel then
		return
	end
	if currentModal then
		currentModal:OnModalChanged(false)
	end
	if panel then
		panel:OnModalChanged(true)
	end
	lastModal = currentModal
	currentModal = panel
end

function Panel3D.RaycastOntoPanel(part, parentGui, gui, ray)
	local partSize = part.Size
	local partThickness = partSize.Z
	local partWidth = partSize.X
	local partHeight = partSize.Y

	local planeCF = part:GetRenderCFrame()
	local planeNormal = planeCF.lookVector
	local pointOnPlane = planeCF.p + (planeNormal * partThickness * 0.5)

	--Find where the view ray intersects with the plane in world space
	local worldIntersectPoint = Utility:RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	if worldIntersectPoint then
		local parentGuiWidth, parentGuiHeight = parentGui.AbsoluteSize.X, parentGui.AbsoluteSize.Y
		--now figure out where that intersection point was in the panel's local space
		--and then flip the X axis because the plane is looking back at you (panel's local +X is to the left of the camera)
		--and then offset it by half of the panel's size in X and -Y to move 0,0 to the upper-left of the panel.
		local localIntersectPoint = planeCF:pointToObjectSpace(worldIntersectPoint) * Vector3.new(-1, 1, 1) + Vector3.new(partWidth / 2, -partHeight / 2, 0)
		--now scale it into the gui space on the panel's surface
		local lookAtPixel = Vector2.new((localIntersectPoint.X / partWidth) * parentGuiWidth, (localIntersectPoint.Y / partHeight) * -parentGuiHeight)
		
		--fire mouse enter/leave events if necessary
		local lookX, lookY = lookAtPixel.X, lookAtPixel.Y
		local guiX, guiY = gui.AbsolutePosition.X, gui.AbsolutePosition.Y
		local guiWidth, guiHeight = gui.AbsoluteSize.X, gui.AbsoluteSize.Y
		local isOnGui = false

		if parentGui.Enabled then
			if lookX >= guiX and lookX <= guiX + guiWidth and
			   lookY >= guiY and lookY <= guiY + guiHeight then
			   	isOnGui = true
			end
		end

		return worldIntersectPoint, localIntersectPoint, lookAtPixel, isOnGui
	else
		return nil, nil, nil, false
	end
end

--End of Panel3D Declaration and enumerations


--Cursor autohiding methods
local cursorHidden = false
local hasTool = false
local lastMouseActivity = tick()
local lastMouseBehavior = Enum.MouseBehavior.Default

local function OnCharacterAdded(character)
	hasTool = false
	for i, v in ipairs(character:GetChildren()) do
		if v:IsA("Tool") then
			hasTool = true
		end
	end
	character.ChildAdded:connect(function(child)
		if child:IsA("Tool") then
			hasTool = true
			lastMouseActivity = tick() --kick the mouse when a tool is equipped
		end
	end)
	character.ChildRemoved:connect(function(child)
		if child:IsA("Tool") then
			hasTool = false
		end
	end)
end
spawn(function()
	while not PlayersService.LocalPlayer do wait() end
	PlayersService.LocalPlayer.CharacterAdded:connect(OnCharacterAdded)
	if PlayersService.LocalPlayer.Character then OnCharacterAdded(PlayersService.LocalPlayer.Character) end
end)
local function autoHideCursor(hide)
	if not PlayersService.LocalPlayer then
		cursorHidden = false
		return
	end
	if not UserInputService.VREnabled then
		cursorHidden = false
		return
	end
	if hide then
		--don't hide if there's a tool in the character
		local character = PlayersService.LocalPlayer.Character
		if character and hasTool then
			return
		end
		cursorHidden = true
		UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.ForceHide
	else
		cursorHidden = false
		UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.None
	end
end

local function isCursorVisible()
	--if ForceShow, the cursor is definitely visible at all times
	if UserInputService.OverrideMouseIconBehavior == Enum.OverrideMouseIconBehavior.ForceShow then
		return true
	end
	--if ForceHide, the cursor is definitely NOT visible
	if UserInputService.OverrideMouseIconBehavior == Enum.OverrideMouseIconBehavior.ForceHide then
		return false
	end
	--Otherwise, we need to check if the developer set MouseIconEnabled=false
	if UserInputService.MouseIconEnabled and UserInputService.OverrideMouseIconBehavior == Enum.OverrideMouseIconBehavior.None then
		return true
	end
	return false
end

--End of cursor autohiding methods


--Panel class implementation
local Panel = {}
Panel.__index = Panel
function Panel.new(name)
	local self = {}
	self.name = name

	self.part = false
	self.gui = false

	self.width = 1
	self.height = 1

	self.isVisible = false
	self.isEnabled = false
	self.panelType = Panel3D.Type.None
	self.pixelScale = 1
	self.showCursor = true
	self.canFade = true
	self.shouldFindLookAtGuiElement = false
	self.ignoreModal = false

	self.linkedTo = false
	self.subpanels = {}

	self.transparency = 1
	self.forceShowUntilLookedAt = false
	self.isLookedAt = false
	self.isOffscreen = true
	self.lookAtPixel = Vector2.new(-1, -1)
	self.cursorPos = Vector2.new(-1, -1)
	self.lookAtDistance = math.huge
	self.lookAtGuiElement = false
	self.isClosest = true

	self.localCF = CFrame.new()
	self.angleFromHorizon = false
	self.angleFromForward = false
	self.distance = false

	if panels[name] then
		error("A panel by the name of " .. name .. " already exists.")
	end
	panels[name] = self

	return setmetatable(self, Panel)
end

--Panel accessor methods
function Panel:GetPart()
	if not self.part then
		self.part = Utility:Create "Part" {
			Name = self.name,
			Parent = partFolder,

			Transparency = 1,

			CanCollide = false,
			Anchored = true,

			Size = Vector3.new(1, 1, partThickness)
		}
	end
	return self.part
end

function Panel:GetGUI()
	if not self.gui then
		local part = self:GetPart()
		self.gui = Utility:Create "SurfaceGui" {
			Parent = CoreGui,
			Name = self.name,
			Archivable = false,
			Adornee = part,
			Active = true,
			ToolPunchThroughDistance = 1000,
			CanvasSize = self.CanvasSize or Vector2.new(0, 0),
			Enabled = self.isEnabled,
			AlwaysOnTop = true
		}
	end
	return self.gui
end

function Panel:FindHoveredGuiElement(elements)
	local x, y = self.lookAtPixel.X, self.lookAtPixel.Y
	for i, v in pairs(elements) do
		local minPt = v.AbsolutePosition
		local maxPt = v.AbsolutePosition + v.AbsoluteSize
		if minPt.X <= x and maxPt.X >= x and
		   minPt.Y <= y and maxPt.Y >= y then
			return v, i
		end
	end
end
--End of panel accessor methods


--Panel update methods
function Panel:SetPartCFrame(cframe)
	self:GetPart().CFrame = cframe * CFrame.new(0, 0, -0.5 * partThickness)
end

function Panel:SetEnabled(enabled)
	if self.isEnabled == enabled then
		return
	end

	self.isEnabled = enabled
	if enabled then
		self:GetPart().Parent = partFolder
		self:GetGUI().Enabled = true
		for i, v in pairs(self.subpanels) do
			v:SetEnabled(v:GetEnabled())
		end
	else
		self:GetPart().Parent = nil
		self:GetGUI().Enabled = false
		for i, v in pairs(self.subpanels) do
			v:SetEnabled(v:GetEnabled())
		end
	end

	self:OnEnabled(enabled)
end

function Panel:EvaluatePositioning(cameraCF, cameraRenderCF, userHeadCF)
	if self.panelType == Panel3D.Type.Fixed then
		--Places the panel in the camera's local space, but doesn't follow the user's head.
		--Useful if you know what you're doing. localCF can be updated in PreUpdate for animation.
		local cf = self.localCF - self.localCF.p
		cf = cf + (self.localCF.p * currentHeadScale)
		self:SetPartCFrame(cameraCF * cf)
	elseif self.panelType == Panel3D.Type.HorizontalFollow then
		local headLook = userHeadCF.lookVector
		local headYaw = math.atan2(-headLook.Z, headLook.X) + math.rad(90)
		local headForwardCF = CFrame.Angles(0, headYaw, 0) + userHeadCF.p
		local localCF = (headForwardCF * self.angleFromForward) * --Rotate about Y (left-right)
						self.angleFromHorizon * --Rotate about X (up-down)
						CFrame.new(0, 0, currentHeadScale * self.distance)-- * --Move into scene
						--turnAroundCF --Turn around to face character
		self:SetPartCFrame(cameraCF * localCF)
	elseif self.panelType == Panel3D.Type.FixedToHead then
		--Places the panel in the user's head local space. localCF can be updated in PreUpdate for animation.
		local cf = self.localCF - self.localCF.p
		cf = cf + (self.localCF.p * currentHeadScale)
		self:SetPartCFrame(cameraRenderCF * cf)
	end
end

function Panel:SetLookedAt(lookedAt)
	if not self.isLookedAt and lookedAt then
		self.isLookedAt = true
		self:OnMouseEnter(self.lookAtPixel.X, self.lookAtPixel.Y)
		if self.forceShowUntilLookedAt then
			self.forceShowUntilLookedAt = false
		end
	elseif self.isLookedAt and not lookedAt then
		self.isLookedAt = false
		self:OnMouseLeave(self.lookAtPixel.X, self.lookAtPixel.Y)
	end
end

function Panel:EvaluateGaze(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay)
	--reset distance data
	self.isClosest = false
	self.lookAtPixel = zeroVector2
	self.lookAtDistance = math.huge

	--check all subpanels first, they're usually in front of the panel.
	local highestSubpanel = nil
	local highestSubpanelDepth = 0
	for guiElement, subpanel in pairs(self.subpanels) do
		if subpanel.part and subpanel.guiElement then
			--note that we're passing subpanel.guiElement and not subpanel.gui
			--this is on purpose so we can fall through to the panels underneath since subpanels will rarely take up the whole 
			--panel size.
			local worldIntersectPoint, localIntersectPoint, guiPixelHit, isOnGui = Panel3D.RaycastOntoPanel(subpanel.part, subpanel.gui, subpanel.guiElement, pointerRay)
			if worldIntersectPoint then
				subpanel.lookAtPixel = guiPixelHit
				subpanel.cursorPos = guiPixelHit

				if isOnGui and subpanel.depthOffset > highestSubpanelDepth then
					highestSubpanel = subpanel
					highestSubpanelDepth = subpanel.depthOffset
				end
			end
		end
	end

	if highestSubpanel and highestSubpanel.depthOffset > 0 then
		currentCursorParent = highestSubpanel.gui
		currentCursorPos = highestSubpanel.cursorPos
		currentClosest = highestSubpanel

		for _, subpanel in pairs(self.subpanels) do
			if subpanel ~= highestSubpanel then
				subpanel:SetLookedAt(false)
			end
		end
		highestSubpanel:SetLookedAt(true)
	end

	local gui = self:GetGUI()
	local worldIntersectPoint, localIntersectPoint, guiPixelHit, isOnGui = Panel3D.RaycastOntoPanel(self:GetPart(), gui, gui, pointerRay)
	if worldIntersectPoint then
		self.isOffscreen = false

		--transform worldIntersectPoint to gui space
		self.lookAtPixel = guiPixelHit
		self.cursorPos = guiPixelHit

		--fire mouse enter/leave events if necessary
		self:SetLookedAt(isOnGui)

		--evaluate distance
		self.lookAtDistance = (worldIntersectPoint - cameraRenderCF.p).magnitude
		if self.isLookedAt and self.lookAtDistance < currentMaxDist and self.showCursor then
			currentMaxDist = self.lookAtDistance
			currentClosest = self
			if not highestSubpanel then
				currentCursorParent = self.gui
				currentCursorPos = self.cursorPos
			end
		end
	else
		self.isOffscreen = true

		--Not looking at the plane at all, so fire off mouseleave if necessary.
		if self.isLookedAt then
			self.isLookedAt = false
			self:OnMouseLeave(self.lookAtPixel.X, self.lookAtPixel.Y)
		end
	end
end

function Panel:EvaluateTransparency()
	--Early exit if force shown
	if self.forceShowUntilLookedAt or not self.canFade then
		self.transparency = 0
		return
	end
	--Early exit if we're looking at the panel (no transparency!)
	if self.isLookedAt then
		self.transparency = 0
		return
	end
	--Similarly, exit if we can't possibly see the panel.
	if self.isOffscreen then
		self.transparency = 1
		return
	end
	--Otherwise, we'll want to calculate the transparency.
	self.transparency = self:CalculateTransparency()
end

function Panel:Update(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay, dt)
	if self.forceShowUntilLookedAt and not self.part then
		self:GetPart()
		self:GetGUI()
	end
	if not self.part then
		return
	end

	local isModal = (currentModal == self)
	if not isModal and self.linkedTo and self.linkedTo == currentModal then
		isModal = true
	end
	if currentModal and not isModal then
		self:SetEnabled(false)
		return
	end

	self:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay, dt)
	if self.isVisible then
		self:EvaluatePositioning(cameraCF, cameraRenderCF, userHeadCF)
		for i, v in pairs(self.subpanels) do
			v:Update()
		end
		self:EvaluateGaze(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay)

		self:EvaluateTransparency(cameraCF, cameraRenderCF)
	end
end
--End of Panel update methods

--Panel virtual methods
function Panel:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay, dt) --virtual: handle positioning here
end

function Panel:OnUpdate(dt) --virtual: handle transparency here
end

function Panel:OnMouseEnter(x, y) --virtual
end

function Panel:OnMouseLeave(x, y) --virtual
end

function Panel:OnEnabled(enabled) --virtual
end

function Panel:OnModalChanged(isModal) --virtual
end

function Panel:OnVisibilityChanged(visible) --virtual
end

function Panel:CalculateTransparency() --virtual
	if not self.canFade then
		return 0
	end

	local guiWidth, guiHeight = self.gui.AbsoluteSize.X, self.gui.AbsoluteSize.Y
	local lookX, lookY = self.lookAtPixel.X, self.lookAtPixel.Y

	--Determine the distance from the edge; 
	--if x is negative it's on the left side, meaning the distance is just absolute value
	--if x is positive it's on the right side, meaning the distance is x minus the width
	local xEdgeDist = lookX < 0 and -lookX or (lookX - guiWidth)
	local yEdgeDist = lookY < 0 and -lookY or (lookY - guiHeight)
	if lookX > 0 and lookX < guiWidth then
		xEdgeDist = 0
	end
	if lookY > 0 and lookY < guiHeight then
		yEdgeDist = 0
	end
	local edgeDist = math.sqrt(xEdgeDist ^ 2 + yEdgeDist ^ 2)

	--since transparency is 0-1, we know how many pixels will give us 0 and how many will give us 1.
	local offset = fullyOpaqueAtPixelsFromEdge
	local interval = fullyTransparentAtPixelsFromEdge
	--then we just clamp between 0 and 1.
	return math.max(0, math.min(1, (edgeDist - offset) / interval))
end
--End of Panel virtual methods


--Panel configuration methods
function Panel:ResizeStuds(width, height, pixelsPerStud)
	pixelsPerStud = pixelsPerStud or defaultPixelsPerStud

	self.width = width
	self.height = height

	self.pixelScale = pixelsPerStud / defaultPixelsPerStud

	local part = self:GetPart()
	part.Size = Vector3.new(self.width * currentHeadScale, self.height * currentHeadScale, partThickness)
	local gui = self:GetGUI()
	gui.CanvasSize = Vector2.new(pixelsPerStud * self.width, pixelsPerStud * self.height)

	for i, v in pairs(self.subpanels) do
		if v.part then
			v.part.Size = part.Size
		end
		if v.gui then
			v.gui.CanvasSize = gui.CanvasSize
		end
	end
end

function Panel:ResizePixels(width, height, pixelsPerStud)
	pixelsPerStud = pixelsPerStud or defaultPixelsPerStud

	local widthInStuds = width / pixelsPerStud
	local heightInStuds = height / pixelsPerStud
	self:ResizeStuds(widthInStuds, heightInStuds, pixelsPerStud)
end

function Panel:OnHeadScaleChanged(newHeadScale)
	local pixelsPerStud = self.pixelScale * defaultPixelsPerStud
	self:ResizeStuds(self.width, self.height, pixelsPerStud)
end

function Panel:SetType(panelType, config)
	self.panelType = panelType

	--clear out old type-specific members

	self.localCF = CFrame.new()

	self.angleFromHorizon = false
	self.angleFromForward = false
	self.distance = false

	if not config then
		config = {}
	end

	if panelType == Panel3D.Type.None then
		--nothing to do
		return
	elseif panelType == Panel3D.Type.Floor then
		self.floorPos = config.FloorPosition or Vector3.new(0, 0, 0)
	elseif panelType == Panel3D.Type.Fixed then
		self.localCF = config.CFrame or CFrame.new()
	elseif panelType == Panel3D.Type.HorizontalFollow then
		self.angleFromHorizon = CFrame.Angles(config.angleFromHorizon or 0, 0, 0)
		self.angleFromForward = CFrame.Angles(0, config.angleFromForward or 0, 0)
		self.distance = config.distance or 5
	elseif panelType == Panel3D.Type.FixedToHead then
		self.localCF = config.CFrame or CFrame.new()
	else
		error("Invalid Panel type")
	end
end

function Panel:SetVisible(visible, modal)
	if visible ~= self.isVisible then
		self:OnVisibilityChanged(visible)
		if not visible then
			Panel3D.OnPanelClosed:Fire(self.name)
		end
	end

	self.isVisible = visible
	self:SetEnabled(visible)
	if visible and modal then
		Panel3D.SetModalPanel(self)
	end
	if not visible and currentModal == self then
		if modal and not doNotRestore then
			--restore last modal panel
			Panel3D.SetModalPanel(lastModal)
		else
			Panel3D.SetModalPanel(nil)

			--if the coder explicitly wanted to hide this modal panel,
			--it follows that they don't want it to be restored when the next
			--modal panel is hidden.
			if lastModal == self then
				lastModal = nil
			end
		end
	end

	if not visible and self.forceShowUntilLookedAt then
		self.forceShowUntilLookedAt = false
	end
end

function Panel:IsVisible()
	return self.isVisible
end

function Panel:LinkTo(panelName)
	if type(panelName) == "string" then
		self.linkedTo = Panel3D.Get(panelName)
	else
		self.linkedTo = panelName
	end
end

function Panel:ForceShowUntilLookedAt(makeModal)
	--ensure the part exists
	self:GetPart()
	self:GetGUI()

	self:SetVisible(true, makeModal)
	self.forceShowUntilLookedAt = true
end

function Panel:SetCanFade(canFade)
	self.canFade = canFade
end

--Child class, Subpanel
local Subpanel = {}
Subpanel.__index = Subpanel
function Subpanel.new(parentPanel, guiElement)
	local self = {}
	self.parentPanel = parentPanel
	self.guiElement = guiElement
	self.lastParent = guiElement.Parent
	self.ancestryConn = nil
	self.changedConn = nil

	self.lookAtPixel = Vector2.new(-1, -1)
	self.cursorPos = Vector2.new(-1, -1)
	self.lookedAt = false

	self.isEnabled = true

	self.part = nil
	self.gui = nil
	self.guiSurrogate = nil

	self.depthOffset = 0

	setmetatable(self, Subpanel)


	self:GetGUI()
	self:UpdateSurrogate()
	self:WatchParent(self.lastParent)

	guiElement.Parent = self.guiSurrogate
	
	local function ancestryCallback(parent, child)
		self:GetGUI().Enabled = self.parentPanel:GetGUI():IsAncestorOf(self.lastParent)
		if not self:GetGUI().Enabled then
			self:GetPart().Parent = nil
		else
			self:GetPart().Parent = workspace.CurrentCamera
		end
		if child == guiElement then
			--disconnect the event because we're going to move this element
			self.ancestryConn:disconnect()

			self.lastParent = guiElement.Parent
			guiElement.Parent = self.guiSurrogate
			self:WatchParent(self.lastParent)

			--reconnect it
			self.ancestryConn = guiElement.AncestryChanged:connect(ancestryCallback)
		end
	end
	self.ancestryConn = guiElement.AncestryChanged:connect(ancestryCallback)

	return self
end

function Subpanel:Cleanup()
	self.guiElement.Parent = self.lastParent
	if self.part then
		self.part:Destroy()
		self.part = nil
	end
	spawn(function()
		wait() --wait so anything that's in the gui that doesn't want to be has time to get out (panel cursor for example)
		if self.gui then
			self.gui:Destroy()
			self.gui = nil
		end
	end)
	if self.ancestryConn then
		self.ancestryConn:disconnect()
		self.ancestryConn = nil
	end
	if self.changedConn then
		self.changedConn:disconnect()
		self.changedConn = nil
	end
	self.lastParent = nil
	self.parentPanel = nil
	self.guiElement = nil
	self.guiSurrogate = nil
end

function Subpanel:OnMouseEnter(x, y)
end
function Subpanel:OnMouseLeave(x, y)
end

function Subpanel:SetLookedAt(lookedAt)
	if lookedAt and not self.lookedAt then
		self:OnMouseEnter(self.lookAtPixel.X, self.lookAtPixel.Y)
	elseif not lookedAt and self.lookedAt then
		self:OnMouseLeave(self.lookAtPixel.X, self.lookAtPixel.Y)
	end
	self.lookedAt = lookedAt
end

function Subpanel:WatchParent(parent)
	if self.changedConn then
		self.changedConn:disconnect()
	end
	self.changedConn = parent.Changed:connect(function(prop)
		if prop == "AbsolutePosition" or prop == "AbsoluteSize" or prop == "Parent" then
			self:UpdateSurrogate()
		end
	end)
end

function Subpanel:UpdateSurrogate()
	local lastParent = self.lastParent
	self.guiSurrogate.Position = UDim2.new(0, lastParent.AbsolutePosition.X, 0, lastParent.AbsolutePosition.Y)
	self.guiSurrogate.Size = UDim2.new(0, lastParent.AbsoluteSize.X, 0, lastParent.AbsoluteSize.Y)
end

function Subpanel:GetPart()
	if self.part then
		return self.part
	end

	self.part = self.parentPanel:GetPart():Clone()
	self.part.Parent = partFolder
	return self.part
end

function Subpanel:GetGUI()
	if self.gui then
		return self.gui
	end

	self.gui = Utility:Create "SurfaceGui" {
		Parent = CoreGui,
		Adornee = self:GetPart(),
		Active = true,
		ToolPunchThroughDistance = 1000,
		CanvasSize = self.parentPanel:GetGUI().CanvasSize,
		Enabled = self.parentPanel.isEnabled,
		AlwaysOnTop = false
	}
	self.guiSurrogate = Utility:Create "Frame" {
		Parent = self.gui,

		Active = false,

		Position = UDim2.new(0, 0, 0, 0),
		Size = UDim2.new(1, 0, 1, 0),

		BackgroundTransparency = 1
	}
	return self.gui
end

function Subpanel:SetDepthOffset(offset)
	self.depthOffset = offset
end

function Subpanel:Update()
	local part = self:GetPart()
	local parentPart = self.parentPanel:GetPart()

	if part and parentPart then
		part.CFrame = parentPart.CFrame * CFrame.new(0, 0, -self.depthOffset)
	end
end

function Subpanel:SetEnabled(enabled)
	-- Don't change check here, parentPanel may try to refresh our enabled state
	-- alternatively we could listen to an enabled changed event on our parent panel
	self.isEnabled = enabled
	if enabled and self.parentPanel.isEnabled then
		self:GetPart().Parent = partFolder
		self:GetGUI().Enabled = true
	else
		self:GetPart().Parent = nil
		self:GetGUI().Enabled = false
	end
end

function Subpanel:GetEnabled()
	return self.isEnabled
end

function Subpanel:GetPixelScale()
	return self.parentPanel:GetPixelScale()
end
function Panel:GetPixelScale()
	return self.pixelScale
end

function Panel:AddSubpanel(guiElement)
	local subpanel = Subpanel.new(self, guiElement)
	self.subpanels[guiElement] = subpanel
	return subpanel
end

function Panel:RemoveSubpanel(guiElement)
	local subpanel = self.subpanels[guiElement]
	if subpanel then
		subpanel:Cleanup()
	end
	self.subpanels[guiElement] = nil
end

function Panel:SetSubpanelDepth(guiElement, depth)
	local subpanel = self.subpanels[guiElement]

	if depth == 0 then
		if subpanel then
			self:RemoveSubpanel(guiElement)
		end
		return nil
	end

	if not subpanel then
		subpanel = self:AddSubpanel(guiElement)
	end
	subpanel:SetDepthOffset(depth)

	return subpanel
end

--End of Panel configuration methods
--End of Panel class implementation


--Panel3D API
function Panel3D.Get(name)
	local panel = panels[name] 
	if not panels[name] then
		panels[name] = Panel.new(name)
		panel = panels[name]
	end
	return panel
end
--End of Panel3D API


--Panel3D Setup
local frameStart = tick()
local function onRenderStep()
	if not UserInputService.VREnabled then
		return
	end

	local now = tick()
	local dt = now - frameStart
	frameStart = now
	

	--reset distance info
	currentClosest = nil
	currentMaxDist = math.huge

	--figure out some useful stuff
	local camera = workspace.CurrentCamera
	local cameraCF = camera.CFrame
	local cameraRenderCF = camera:GetRenderCFrame()
	local userHeadCF = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
	local lookRay = Ray.new(cameraRenderCF.p, cameraRenderCF.lookVector)

	local inputUserCFrame = Enum.UserCFrame.Head
	if VRServiceExists then
		inputUserCFrame = VRService.GuiInputUserCFrame
	end
	local inputCF = cameraCF * UserInputService:GetUserCFrame(inputUserCFrame)
	local pointerRay = Ray.new(inputCF.p, inputCF.lookVector)

	--allow all panels to run their own update code
	for i, v in pairs(panels) do
		v:Update(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay, dt)
	end

	--evaluate linked panels
	local processed = {}
	for i, v in pairs(panels) do
		if not processed[v] and v.linkedTo and v.isVisible and v.linkedTo.isVisible then
			processed[v] = true
			processed[v.linkedTo] = true

			local minTransparency = math.min(v.transparency, v.linkedTo.transparency)
			v.transparency = minTransparency
			v.linkedTo.transparency = minTransparency
		end
	end

	--run post update because the distance information hasn't been
	--finalized until now.
	for i, v in pairs(panels) do
		--If the part is fully transparent, we don't want to keep it around in the workspace.
		if v.part and v.gui then
			--check if this panel is the current modal panel
			local isModal = (currentModal == v)
			--but also check if this panel is linked to the current modal panel
			if not isModal and v.linkedTo and v.linkedTo == currentModal then
				isModal = true
			end

			local show = v.isVisible
			if not isModal and currentModal then
				show = false
			end
			if v.transparency >= 1 then
				show = false
			end

			if v.forceShowUntilLookedAt then
				show = true
			end
			if not v.canFade and v.isVisible then
				show = true
			end
			
			v:SetEnabled(show)
		end

		v:OnUpdate(dt)
	end

	--place the cursor on the closest panel (for now)
	if not currentClosest and lastClosest then
		UserInputService.MouseBehavior = lastMouseBehavior
	elseif currentClosest and not lastClosest then
		lastMouseBehavior = UserInputService.MouseBehavior
	end

	if currentClosest then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.ForceHide
		cursor.Parent = currentCursorParent

		local x, y = currentCursorPos.X, currentCursorPos.Y
		local pixelScale = currentClosest:GetPixelScale()
		cursor.Size = UDim2.new(0, 8 * pixelScale, 0, 8 * pixelScale)
		cursor.Position = UDim2.new(0, x - cursor.AbsoluteSize.x * 0.5, 0, y - cursor.AbsoluteSize.y * 0.5)
	else
		cursor.Parent = nil
	end
	lastClosest = currentClosest
end
RunService:BindToRenderStep(renderStepName, Enum.RenderPriority.Last.Value, onRenderStep)

--Implement cursor autohide functionality
UserInputService.InputChanged:connect(function(inputObj, processed)
	if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
		lastMouseActivity = tick()
		autoHideCursor(false)
	end
end)
local function onHeartbeat()
	if isCursorVisible() then
		cursorHidden = false
	end
	if lastMouseActivity + cursorHideTime < tick() and not GuiService.MenuIsOpen and not cursorHidden then
		autoHideCursor(true)
	end
end
RunService.Heartbeat:connect(onHeartbeat)



local cameraChangedConnection = nil
local function onCameraChanged(prop)
	if prop == "HeadScale" then
		pcall(function()
			currentHeadScale = workspace.CurrentCamera.HeadScale
		end)
		for i, v in pairs(panels) do
			v:OnHeadScaleChanged(currentHeadScale)
		end
	end
end

local function onWorkspaceChanged(prop)
	if prop == "CurrentCamera" then
		onCameraChanged("HeadScale")
		if cameraChangedConnection then
			cameraChangedConnection:disconnect()
		end
		cameraChangedConnection = workspace.CurrentCamera.Changed:connect(onCameraChanged)

		if UserInputService.VREnabled then
			partFolder.Parent = workspace.CurrentCamera
			effectFolder.Parent = workspace.CurrentCamera
		end
	end
end

local currentCameraChangedConn = nil
local function onVREnabled(prop)
	if prop == "VREnabled" then
		if UserInputService.VREnabled then
			if workspace.CurrentCamera then
				onWorkspaceChanged("CurrentCamera")
			end
			currentCameraChangedConn = workspace.Changed:connect(onWorkspaceChanged)

			partFolder.Parent = workspace.CurrentCamera
			effectFolder.Parent = workspace.CurrentCamera
		else
			if currentCameraChangedConn then
				currentCameraChangedConn:disconnect()
				currentCameraChangedConn = nil
			end
			partFolder.Parent = nil
			effectFolder.Parent = nil
		end
	end
end
UserInputService.Changed:connect(onVREnabled)
onVREnabled("VREnabled")

return Panel3D]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX81297401E082403585C29801AA0E2AC1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NotificationHub</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local Util = require(RobloxGui.Modules.Settings.Utility)
local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
local VRHub = require(RobloxGui.Modules.VR.VRHub)

local PANEL_OFFSET_CFRAME = CFrame.Angles(math.rad(-5), 0, 0) * CFrame.new(0, 4, 0) * CFrame.Angles(math.rad(-15), 0, 0)

local NO_TRANSITION_ANIMATIONS = false
local ANIMATE_OUT_DISTANCE = -100
local ANIMATE_OUT_DURATION = 0.25
local PIXELS_PER_STUD = 150
local WINDOW_TITLEBAR_HEIGHT = 72
local BLURRED_TITLEBAR_COLOR = Color3.new(78 / 255, 84 / 255, 96 / 255)
local FOCUSED_TITLEBAR_COLOR = Color3.new(82 / 255, 101 / 255, 141 / 255)
local WINDOW_BG_COLOR = Color3.new(20/255, 20/255, 20/255)
local WINDOW_BG_TRANSPARENCY = 0.5
local POPOUT_DISTANCE = 0.25
local POPOUT_DURATION = 0.25

local NOTIFICATION_WIDTH_SCALE = 0.85
local NOTIFICATION_HEIGHT_OFFSET = 80
local NOTIFICATION_PADDING_Y = 20
local NOTIFICATION_PADDING_X_SCALE = (1 - NOTIFICATION_WIDTH_SCALE) / 2
local NOTIFICATION_DEPTH_OFFSET = 0.25
local NOTIFICATION_BG_COLOR = Color3.new(0.2, 0.2, 0.2)
local NOTIFICATION_BG_TRANSPARENCY = 0.1
local MAX_NOTIFICATIONS_SHOWN = 3
local MAX_DETAILS_SHOWN = 2
local DETAILS_PADDING = 20

local BUTTON_1_POS = 0.07
local BUTTON_2_POS = 0.511
local BUTTON_SINGLE_SIZE = 0.86
local BUTTON_DOUBLE_SIZE = 0.415

local BUTTON_Y_POS = 0.55
local BUTTON_Y_SIZE = 0.29

local BUTTON_NORMAL_IMG = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png"
local BUTTON_SELECTED_IMG = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButtonSelected.png"

local CLOSE_BUTTON_IMG = "rbxasset://textures/ui/Keyboard/close_button_icon.png"
local CLOSE_BUTTON_HOVER = "rbxasset://textures/ui/Keyboard/close_button_selection.png"
local CLOSE_BUTTON_SIZE = 32
local CLOSE_BUTTON_OFFSET = 22
local CLOSE_BUTTON_HOVER_OFFSET = 22

local emptySelectionImage = Util:Create "ImageLabel" {
	BackgroundTransparency = 1,
	Image = ""
}


local AVATAR_IMAGE_URL = 'http://www.roblox.com/thumbs/avatar.ashx?userId=%d&x=%d&y=%d'

local TEXT_COLOR = Color3.new(1, 1, 1)

local aspectRatio = 1.62666666
local totalHeight = 3.5
local totalWidth = totalHeight * aspectRatio
local leftPanelWidth = totalWidth * 0.4
local rightPanelWidth = totalWidth * 0.6

local panelOffset = totalWidth / 2
local leftOffset = panelOffset - (leftPanelWidth * 0.5)
local rightOffset = leftOffset - (leftPanelWidth * 0.5) - (rightPanelWidth * 0.5)

local NotificationHubModule = {}
NotificationHubModule.ModuleName = "Notifications"
NotificationHubModule.KeepVRTopbarOpen = true
NotificationHubModule.VRIsExclusive = true
NotificationHubModule.VRClosesNonExclusive = true
NotificationHubModule.UnreadCountChanged = function() end
VRHub:RegisterModule(NotificationHubModule)

local notificationsPanel = Panel3D.Get("Notifications")
local notificationsWindow = nil
local detailsPanel = Panel3D.Get("NotificationDetails")
local detailsWindow = nil

local function IsDeveloperGroupEnabled()
	return false
end

local WindowFrame = {} 
do
	local windows = {}
	local WindowFrame_mt = { __index = WindowFrame }
	function WindowFrame.new(panel, parent, title)
		local instance = {}
		table.insert(windows, instance)
		instance.zeroCF = panel.localCF
		instance.zOffset = 0
		instance.isPopping = false
		instance.isAnimating = false
		instance.tweener = nil
		instance.panel = panel
		instance.panel.OnMouseEnter = function()
			for i, v in pairs(windows) do
				if v ~= instance then
					v:SetPopOut(false)
				end
			end
			instance:SetPopOut(true)
		end

		instance.titlebar = Util:Create "ImageLabel" {
			Parent = parent,
			Name = "TitlebarBackground",

			Position = UDim2.new(0, -1, 0, -1),
			Size = UDim2.new(1, 2, 0, WINDOW_TITLEBAR_HEIGHT + 2),

			BackgroundTransparency = 1,

			Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
			ImageColor3 = BLURRED_TITLEBAR_COLOR,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Rect.new(10, 10, 10, 10)
		}
		instance.titleText = Util:Create "TextLabel" {
			Parent = instance.titlebar,
			Name = "TitleText",

			Position = UDim2.new(0, 1, 0, 1),
			Size = UDim2.new(1, -2, 1, -2),

			Text = title,
			TextColor3 = TEXT_COLOR,
			Font = Enum.Font.SourceSans,
			FontSize = Enum.FontSize.Size36,

			BackgroundTransparency = 1
		}

		instance.content = Util:Create "ImageLabel" {
			Parent = parent,
			Name = "ContentFrame",

			Position = UDim2.new(0, -1, 0, WINDOW_TITLEBAR_HEIGHT + 2),
			Size = UDim2.new(1, 2, 1, -WINDOW_TITLEBAR_HEIGHT - 4),

			BackgroundTransparency = 1,

			Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
			ImageColor3 = WINDOW_BG_COLOR,
			ImageTransparency = WINDOW_BG_TRANSPARENCY,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Rect.new(10, 10, 10, 10)
		}	

		return setmetatable(instance, WindowFrame_mt)
	end

	function WindowFrame:SetTitle(title)
		self.titleText.Text = title
	end

	function WindowFrame:AddCloseButton(callback)
		self.closeButton = Util:Create "ImageButton" {
			Parent = self.titlebar,
			Name = "CloseButton",

			Position = UDim2.new(0, CLOSE_BUTTON_OFFSET, 0, CLOSE_BUTTON_OFFSET),
			Size = UDim2.new(0, CLOSE_BUTTON_SIZE, 0, CLOSE_BUTTON_SIZE),

			BackgroundTransparency = 1, 

			Image = CLOSE_BUTTON_IMG,
			SelectionImageObject = Util:Create "ImageButton" {
				Name = "CloseButtonHover",
				Position = UDim2.new(0, CLOSE_BUTTON_HOVER_OFFSET / -2, 0, CLOSE_BUTTON_HOVER_OFFSET / -2),
				Size = UDim2.new(1, CLOSE_BUTTON_HOVER_OFFSET, 1, CLOSE_BUTTON_HOVER_OFFSET),
				BackgroundTransparency = 1,
				Image = CLOSE_BUTTON_HOVER
			}
		}
		self.closeButton.MouseButton1Click:connect(callback)
	end

	function WindowFrame:TweenZOffsetTo(zOffset, duration, easingFunc, callback)
		if self.tweener and not self.tweener:IsFinished() then
			self.tweener:Cancel()
		end
		self.tweener = Util:TweenProperty(self, "zOffset", self.zOffset, zOffset, duration, easingFunc, callback)
	end

	function WindowFrame:AnimateOut(callback)
		self.isAnimating = true
		self:TweenZOffsetTo(ANIMATE_OUT_DISTANCE, ANIMATE_OUT_DURATION, Util:GetEaseInOutQuad(), function()
			if callback then callback() end
			self.isAnimating = false
		end)
	end

	function WindowFrame:AnimateIn(callback)
		self.zOffset = ANIMATE_OUT_DISTANCE
		self:OnUpdate(0)
		self.isAnimating = true
		self:TweenZOffsetTo(0, ANIMATE_OUT_DURATION, Util:GetEaseInOutQuad(), function()
			if callback then callback() end
			self.isAnimating = false
		end)
	end

	function WindowFrame:SetPopOut(popOut)
		if self.isAnimating then
			return
		end

		if popOut then
			self.isPopping = true
			self:TweenZOffsetTo(POPOUT_DISTANCE, POPOUT_DURATION, Util:GetEaseInOutQuad(), function()
				self.isPopping = false
			end)
		else
			self.isPopping = true
			self:TweenZOffsetTo(0, POPOUT_DURATION, Util:GetEaseInOutQuad(), function()
				self.isPopping = false
			end)
		end
	end

	function WindowFrame:OnUpdate(dt)
		self.panel.localCF = self.zeroCF * CFrame.new(0, 0, -self.zOffset)

		if self.isPopping then
			local alpha = math.max(0, math.min(1, self.zOffset / POPOUT_DISTANCE))
			self.titlebar.ImageColor3 = BLURRED_TITLEBAR_COLOR:lerp(FOCUSED_TITLEBAR_COLOR, alpha)
		end
	end
end

--Notifications panel setup
do
	notificationsPanel:SetType(Panel3D.Type.Fixed)
	notificationsPanel:SetVisible(false)
	notificationsPanel:SetCanFade(false)
	notificationsPanel:ResizeStuds(leftPanelWidth, totalHeight, PIXELS_PER_STUD)
	local notificationsFrame = Util:Create "TextButton" {
		Parent = notificationsPanel:GetGUI(),
		Name = "NotificationsListFrame",

		Position = UDim2.new(0, 0, 0, 0),
		Size = UDim2.new(1, -4, 1, 0),

		BackgroundTransparency = 1,
		Text = "",

		Selectable = true,
		SelectionImageObject = emptySelectionImage
	}
	notificationsWindow = WindowFrame.new(notificationsPanel, notificationsFrame, "Notifications")
	notificationsWindow:AddCloseButton(function()
		NotificationHubModule:SetVisible(false)
	end)
	function notificationsPanel:OnUpdate(dt)
		notificationsWindow:OnUpdate(dt)
	end
end

--Details panel setup
do
	detailsPanel:SetType(Panel3D.Type.Fixed)
	detailsPanel:SetVisible(false)
	detailsPanel:SetCanFade(false)
	detailsPanel:ResizeStuds(rightPanelWidth, totalHeight, PIXELS_PER_STUD)
	local detailsFrame = Util:Create "TextButton" {
		Parent = detailsPanel:GetGUI(),
		Name = "NotificationsDetailFrame",

		Position = UDim2.new(0, 0, 0, 0),
		Size = UDim2.new(1, 0, 1, 0),
		
		BackgroundTransparency = 1,
		Text = "",

		Selectable = true,
		SelectionImageObject = emptySelectionImage
	}
	detailsWindow = WindowFrame.new(detailsPanel, detailsFrame, "Friend Requests")
	function detailsPanel:OnUpdate(dt)
		detailsWindow:OnUpdate(dt)
	end
end

local notificationsGroups = {}
local notificationsGroupsList = {}
local function groupSort(a, b)
	return a.order < b.order
end
local activeGroup = nil

local function layoutNotificationsGroups()
	local y = NOTIFICATION_PADDING_Y
	for _, group in ipairs(notificationsGroupsList) do
		if #group.notifications > 0 then
			local height = NOTIFICATION_HEIGHT_OFFSET + (NOTIFICATION_PADDING_Y * (math.min(MAX_NOTIFICATIONS_SHOWN, #group.notifications) - 1))
			local widthOffset = -((MAX_NOTIFICATIONS_SHOWN - 1) * NOTIFICATION_PADDING_Y)
			group.frame.Position = UDim2.new(NOTIFICATION_PADDING_X_SCALE, 0, 0, y)
			group.frame.Size = UDim2.new(NOTIFICATION_WIDTH_SCALE, widthOffset, 0, height)
			y = y + height + NOTIFICATION_PADDING_Y

			if group.notificationsDirty then
				group.notificationsDirty = false

				local notificationOffset = 0
				local notificationDepth = 0

				local notificationsEnd = #group.notifications
				if notificationsEnd > 0 then
					local notificationsStart = math.max(1, notificationsEnd - MAX_NOTIFICATIONS_SHOWN + 1)
					for i = 1, notificationsEnd do
						local notification = group.notifications[i]
						if i >= notificationsStart then
							notification.frame.Visible = true
							notification.frame.Position = UDim2.new(0, notificationOffset, 0, notificationOffset)
							notificationOffset = notificationOffset + NOTIFICATION_PADDING_Y

							local subpanel = notificationsPanel:SetSubpanelDepth(notification.frame, notificationDepth)
							notificationDepth = notificationDepth + NOTIFICATION_DEPTH_OFFSET
						else
							notification.frame.Visible = false
						end
					end

					if activeGroup == group then
						notificationsStart = math.max(1, notificationsEnd - MAX_DETAILS_SHOWN + 1)
						local detailY = 0
						local fraction = 1 / MAX_DETAILS_SHOWN
						for i = 1, notificationsEnd do
							local notification = group.notifications[i]
							if i >= notificationsStart then
								notification.detailsFrame.Visible = true
								notification.detailsFrame.Position = UDim2.new(0, DETAILS_PADDING, detailY, DETAILS_PADDING)
								notification.detailsFrame.Size = UDim2.new(1, -DETAILS_PADDING * 2, fraction, -DETAILS_PADDING * 2)

								detailY = detailY + fraction
							else
								notification.detailsFrame.Visible = false
							end
						end
					end
				end
			end
		end
	end
end

local NotificationGroup = {} 
do
	local NotificationGroup_mt = { __index = NotificationGroup }
	function NotificationGroup.new(key, title, order) 
		local self = setmetatable({}, NotificationGroup_mt)

		self.key = key
		self.title = title
		self.order = order
		self.notifications = {}
		self.notificationsDirty = false
		self.frame = Util:Create "Frame" {
			Parent = notificationsWindow.content,
			Name = "NotificationGroup",
			BackgroundTransparency = 1
		}
		self.detailsFrame = Util:Create "Frame" {
			Parent = nil,
			BackgroundTransparency = 1,

			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0)
		}

		notificationsGroups[key] = self
		table.insert(notificationsGroupsList, self)

		return self
	end

	function NotificationGroup:Deactivate()
		self.detailsFrame.Parent = nil
		for i, v in pairs(self.detailsFrame:GetChildren()) do
			detailsPanel:RemoveSubpanel(v)
		end
	end

	function NotificationGroup:SwitchTo()
		detailsWindow:SetTitle(self.title)
		for i, v in pairs(notificationsGroups) do
			if v ~= self then
				v:Deactivate()
			end
		end
		self.detailsFrame.Parent = detailsWindow.content

		activeGroup = self
		self.notificationsDirty = true
	end

	function NotificationGroup:BringNotificationToFront(notification)
		if activeGroup ~= self then
			self:SwitchTo()
		end

		if #self.notifications ~= 0 and notification == self.notifications[#self.notifications] then
			layoutNotificationsGroups()
			return --already on top, no point
		end

		for i, v in ipairs(self.notifications) do
			if v == notification then
				--take it out
				table.remove(self.notifications, i)
				break
			end
		end
		--put it back on top
		table.insert(self.notifications, notification)
		self.notificationsDirty = true
		layoutNotificationsGroups()
	end

	function NotificationGroup:RemoveNotification(notification)
		for i, v in ipairs(self.notifications) do
			if v == notification then
				table.remove(self.notifications, i)
				notificationsPanel:RemoveSubpanel(notification.frame)
				detailsPanel:RemoveSubpanel(notification.detailsFrame)
				notification.detailsFrame:Destroy()
				notification.frame:Destroy()

				self.notificationsDirty = true
				layoutNotificationsGroups()
				return
			end
		end
	end

	function NotificationGroup:GetTopNotification()
		local numNotifications = #self.notifications
		if numNotifications <= 0 then
			return nil
		end
		return self.notifications[numNotifications]
	end
end

NotificationGroup.new("Friends",        "Friends",  1)
NotificationGroup.new("BadgeAwards",    "Badges",   2)
NotificationGroup.new("PlayerPoints",   "Points",   3)
if IsDeveloperGroupEnabled() then
	NotificationGroup.new("Developer",      "Other",    4)
end
table.sort(notificationsGroupsList, groupSort)

local function doCallback(callback, ...)
	if not callback then
		return
	end

	if type(callback) == "function" then
		callback(...)
		return
	end
	if callback:IsA("BindableEvent") then
		callback:Fire(...)
		return
	end
	if callback:IsA("BindableFunction") then
		callback:Invoke(...)
		return
	end
end

local Notification = {} 
do
	local Notification_mt = { __index = Notification }
	function Notification.new(group, notificationInfo)
		local self = setmetatable({}, Notification_mt)
		self.group = group
		self.frame = Util:Create "ImageButton" {
			Parent = group.frame,
			Size = UDim2.new(1, 0, 0, NOTIFICATION_HEIGHT_OFFSET),

			SelectionImageObject = emptySelectionImage,

			BackgroundTransparency = 1 --when we have proper frame rendering with AA, we can change this and remove the stand-in background
		}
		self.frame.MouseButton1Click:connect(function()
			self:OnClicked()
		end)
		self.background = Util:Create "ImageLabel" { --this is the stand-in background for that smoooooooth edge rendering
			Parent = self.frame,
			Position = UDim2.new(0, -1, 0, -1),
			Size = UDim2.new(1, 2, 1, 2),

			BackgroundTransparency = 1,
			Image = "rbxasset://textures/ui/vr/rectBackgroundWhite.png",
			ImageColor3 = NOTIFICATION_BG_COLOR,
			ImageTransparency = NOTIFICATION_BG_TRANSPARENCY,

			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Rect.new(10, 10, 10, 10)
		}
		self.imageBackground = Util:Create "ImageLabel" {
			Parent = self.frame,
			Position = UDim2.new(0, 5, 0, 5),
			Size = UDim2.new(0, 70, 0, 70),

			BackgroundTransparency = 1,

			Image = "rbxasset://textures/ui/VR/circleWhite.png",
			ImageColor3 = notificationInfo.imgBackgroundColor or Color3.new(1, 1, 1)
		}
		self.image = Util:Create "ImageLabel" {
			Parent = self.imageBackground,
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),

			BackgroundTransparency = 1,

			Image = notificationInfo.Image
		}

		local text = notificationInfo.Text
		if notificationInfo.Title and notificationInfo.Text then
			text = ("%s\n%s"):format(notificationInfo.Title, notificationInfo.Text)
		end
		self.text = Util:Create "TextLabel" {
			Parent = self.frame,

			Position = UDim2.new(0, NOTIFICATION_HEIGHT_OFFSET, 0, 0),
			Size = UDim2.new(1, -NOTIFICATION_HEIGHT_OFFSET, 1, 0),

			BackgroundTransparency = 1,

			TextXAlignment = Enum.TextXAlignment.Left,
			Text = text,
			TextWrapped = true,
			Font = Enum.Font.SourceSans,
			FontSize = Enum.FontSize.Size18,
			TextColor3 = TEXT_COLOR
		}

		self.detailsFrame = Util:Create "Frame" {
			Parent = group.detailsFrame,
			BackgroundTransparency = 1
		}
		self.detailsFrame.MouseEnter:connect(function()
			detailsPanel:SetSubpanelDepth(self.detailsFrame, 0.25)
		end)
		self.detailsFrame.MouseLeave:connect(function()
			detailsPanel:SetSubpanelDepth(self.detailsFrame, 0)
		end)
		self.detailsBackground = Util:Create "ImageLabel" {
			Parent = self.detailsFrame,
			Position = UDim2.new(0, -1, 0, -1),
			Size = UDim2.new(1, 2, 1, 2),

			BackgroundTransparency = 1,

			Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
			ImageColor3 = Color3.new(0.2, 0.2, 0.2),
			ImageTransparency = 0.1,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Rect.new(10,10,10,10)
		}

		self.detailsIconBackground = Util:Create "ImageLabel" {
			Parent = self.detailsFrame,
			Position = UDim2.new(0, 20, 0, 10),
			Size = UDim2.new(0, 80, 0, 80),

			BackgroundTransparency = 1,

			Image = "rbxasset://textures/ui/VR/circleWhite.png",
			ImageColor3 = notificationInfo.imgBackgroundColor or Color3.new(1, 1, 1)
		}
		self.detailsIcon = Util:Create "ImageLabel" {
			Parent = self.detailsIconBackground,
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),

			BackgroundTransparency = 1,

			Image = notificationInfo.Image
		}

		local detailText = notificationInfo.DetailText or notificationInfo.Title
		self.detailsText = Util:Create "TextLabel" {
			Parent = self.detailsFrame,
			Position = UDim2.new(0, 110, 0, 10),
			Size = UDim2.new(1, -120, 0, 90),

			BackgroundTransparency = 1,

			Text = detailText, 
			TextWrapped = true,
			TextColor3 = TEXT_COLOR,
			TextXAlignment = Enum.TextXAlignment.Left,
			Font = Enum.Font.SourceSansBold,
			FontSize = Enum.FontSize.Size36
		}

		local function createButton(xPosScale, xSizeScale, text)
			local button, text = Util:Create "ImageButton" {
				Parent = self.detailsFrame,
				Position = UDim2.new(xPosScale, 0, BUTTON_Y_POS, 0),
				Size = UDim2.new(xSizeScale, 0, BUTTON_Y_SIZE, 0),

				BackgroundTransparency = 1,

				Image = BUTTON_NORMAL_IMG,
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(8,6,46,44),

				SelectionImageObject = emptySelectionImage
			}, Util:Create "TextLabel" {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 1, -6),

				BackgroundTransparency = 1,

				Text = text,
				TextColor3 = TEXT_COLOR,
				Font = Enum.Font.SourceSansBold,
				FontSize = Enum.FontSize.Size24
			}
			text.Parent = button

			button.SelectionGained:connect(function()
				button.Image = BUTTON_SELECTED_IMG
			end)
			button.SelectionLost:connect(function()
				button.Image = BUTTON_NORMAL_IMG
			end)
			return button, text
		end

		if notificationInfo.Button1Text and notificationInfo.Button2Text then
			self.detailsButton1, self.detailsButton1Text = createButton(BUTTON_1_POS, BUTTON_DOUBLE_SIZE, notificationInfo.Button1Text)
			self.detailsButton2, self.detailsButton2Text = createButton(BUTTON_2_POS, BUTTON_DOUBLE_SIZE, notificationInfo.Button2Text)

			self.detailsButton1.MouseButton1Click:connect(function() 
				doCallback(notificationInfo.Callback, notificationInfo.Button1Text)
				self:Dismiss() 
			end)
			self.detailsButton2.MouseButton1Click:connect(function() 
				doCallback(notificationInfo.Callback, notificationInfo.Button2Text)
				self:Dismiss() 
			end)
		elseif not notificationInfo.button2Text then
			local text = notificationInfo.Button1Text or "Dismiss"
			self.detailsButton1, self.detailsButton1Text = createButton(BUTTON_1_POS, BUTTON_SINGLE_SIZE, text)
			self.detailsButton1.MouseButton1Click:connect(function() 
				doCallback(notificationInfo.Callback, notificationInfo.Button1Text)
				self:Dismiss() 
			end)
		end

		table.insert(group.notifications, self)
		group.notificationsDirty = true
		layoutNotificationsGroups()

		return self
	end

	function Notification:OnClicked()
		--We don't want this functionality anymore, but I'd like to keep this commented
		--out for now since this design is still in a state of flux
		--self.group:BringNotificationToFront(self)
		self.group:SwitchTo()
		layoutNotificationsGroups()
	end

	function Notification:Dismiss()
		self.group:RemoveNotification(self)
	end
end

--NotificationHubModule API and state management
do
	local pendingNotifications = {}
	local isVisible = false
	local unreadCount = 0

	local SendNotificationInfoEvent = RobloxGui:WaitForChild("SendNotificationInfo")
	SendNotificationInfoEvent.Event:connect(function(notificationInfo)
		local group = notificationInfo.GroupName and notificationsGroups[notificationInfo.GroupName] --avoid error by nil index
		if not group then
			if IsDeveloperGroupEnabled() then
				group = notificationsGroups.Developer 
			else
				return --ignore it, invalid group
			end
		end

		Notification.new(group, notificationInfo)

		if not isVisible then
			unreadCount = unreadCount + 1
			NotificationHubModule.UnreadCountChanged(unreadCount)
		end
	end)

	local menuCloseShortcutBindName = "NotificationsMenuCloseShortcut"
	local function onMenuCloseShortcut(actionName, inputState, inputObj)
		if inputState == Enum.UserInputState.Begin then
			NotificationHubModule:SetVisible(false)
		end
	end

	NotificationHubModule.VisibilityStateChanged = Util:Create "BindableEvent" {
		Name = "VisibilityStateChanged"
	}

	function NotificationHubModule:GetNumberOfPendingNotifications()
		return #pendingNotifications
	end

	function NotificationHubModule:IsVisible()
		return isVisible
	end

	function NotificationHubModule:SetVisible(visible)
		if isVisible == visible then
			return
		end
		isVisible = visible

		local topbarPanel = Panel3D.Get("Topbar3D")
		topbarPanel:SetCanFade(not visible)
		if visible then
			unreadCount = 0
			NotificationHubModule.UnreadCountChanged(unreadCount)

			local hubSpace = topbarPanel.localCF * PANEL_OFFSET_CFRAME

			notificationsPanel.localCF = hubSpace * CFrame.new(leftOffset, 0, 0)
			notificationsWindow.zeroCF = notificationsPanel.localCF
			if not NO_TRANSITION_ANIMATIONS then
				notificationsWindow:AnimateIn(nil)
			end

			detailsPanel.localCF = hubSpace * CFrame.new(rightOffset, 0, 0)
			detailsWindow.zeroCF = detailsPanel.localCF
			if not NO_TRANSITION_ANIMATIONS then
				detailsWindow:AnimateIn(nil)
			end
			
			notificationsPanel:SetVisible(true)
			detailsPanel:SetVisible(true)

			ContextActionService:BindCoreAction(menuCloseShortcutBindName, onMenuCloseShortcut, false, Enum.KeyCode.ButtonB)

			VRHub:FireModuleOpened(NotificationHubModule.ModuleName)
		else
			if not NO_TRANSITION_ANIMATIONS then
				spawn(function()
					cancelAnimation = false
					notificationsWindow:AnimateOut(function()
						notificationsPanel:SetVisible(false)
					end)
					detailsWindow:AnimateOut(function()
						detailsPanel:SetVisible(false)
					end)
				end)
			else
				notificationsPanel:SetVisible(false)
				detailsPanel:SetVisible(false)
			end

			ContextActionService:UnbindCoreAction(menuCloseShortcutBindName)

			VRHub:FireModuleClosed(NotificationHubModule.ModuleName)
		end

		NotificationHubModule.VisibilityStateChanged:Fire(visible)
	end

	
	VRHub.ModuleOpened.Event:connect(function(moduleName, isExclusive, shouldCloseNonExclusive, shouldKeepTopbarOpen)
		if moduleName ~= NotificationHubModule.ModuleName then
			NotificationHubModule:SetVisible(false)
		end
	end)
end

return NotificationHubModule]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE548E2A146FB4355BEAF730D09815802">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LaserPointer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--LaserPointer.lua
--Implements the visual part of the VR laser pointer
--Written by Kyle, September 2016
local CoreGui = game.CoreGui
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local SoundService = game:GetService("SoundService")
local PathfindingService = game:GetService("PathfindingService")
local GuiService = game:GetService("GuiService")
local VRServiceExists, VRService = pcall(function() return game:GetService("VRService") end)
local Utility = require(RobloxGui.Modules.Settings.Utility) --todo: use common utility module when it's done

local getRaycastWhitelistSuccess, getRaycastWhitelistEnabled = pcall(function() return settings():GetFFlag("EnableGetHitWhitelist") end)
local isRaycastWhitelistEnabled = getRaycastWhitelistSuccess and getRaycastWhitelistEnabled

local getTestControlSchemesSuccess, getTestControlSchemesEnabled = pcall(function() return settings():GetFFlag("VRTestControlSchemes") end)
local areTestControlSchemesEnabled = getTestControlSchemesSuccess and getTestControlSchemesEnabled

local LocalPlayer = Players.LocalPlayer

--Pathfinding sort of works, but it's very slow and does not handle slopes very well.
--Use at your own risk.
local usePathfinding = false

local gamma, invGamma = 2.2, 1/2.2
local function fromLinearRGB(color)
	return Color3.new(color.r ^ gamma, color.g ^ gamma, color.b ^ gamma)
end
local function toLinearRGB(color)
	return Color3.new(color.r ^ invGamma, color.g ^ invGamma, color.b ^ invGamma)
end

local function setPartInGame(part, inGame)
	if not part then
		return
	end
	if inGame and not part:IsDescendantOf(game) then
		local container = GuiService.CoreEffectFolder
		if not container then
			coroutine.wrap(function()
				while GuiService.Changed:wait() ~= "CoreEffectFolder" and GuiService.CoreEffectFolder == nil do
				end
				part.Parent = GuiService.CoreEffectFolder
			end)()
		else
			part.Parent = container
		end
	else
		part.Parent = nil
	end
end

local function getLocalHumanoid()
	local character = LocalPlayer.Character
	if not character then
		return
	end

	for _, child in pairs(character:GetChildren()) do
		if child:IsA("Humanoid") then
			return child
		end
	end
end	

local function applyExpCurve(x, exp)
	local y = x ^ exp
	if y ~= y then
		y = math.abs(x) ^ exp
	end
	return y
end

local HEAD_MOUNT_OFFSET = Vector3.new(0.5, 0.5, 0)
local HEAD_MOUNT_THICKNESS_MULTIPLIER = 0.25

--Teleport visual configuration
local TELEPORT = {
	MODE_ENABLED = true,

	ARC_COLOR_GOOD = fromLinearRGB(Color3.fromRGB(0, 162, 255)),
	ARC_COLOR_BAD = fromLinearRGB(Color3.fromRGB(253, 68, 72)),
	ARC_THICKNESS = 0.05,

	PLOP_GOOD = "rbxasset://textures/ui/VR/VRPointerDiscBlue.png",
	PLOP_BAD = "rbxasset://textures/ui/VR/VRPointerDiscRed.png",
	PLOP_BALL_COLOR_GOOD = BrickColor.new("Bright green"),
	PLOP_BALL_COLOR_BAD = BrickColor.new("Bright red"),
	PLOP_BALL_SIZE = 0.5,
	PLOP_SIZE = 2,
	PLOP_PULSE_MIN_SIZE = 0,
	PLOP_PULSE_MAX_SIZE = 2,

	MAX_VALID_DISTANCE = 48,

	BUTTON_DOWN_THRESHOLD = 0.95,
	BUTTON_UP_THRESHOLD = 0.5,

	MIN_VELOCITY = 10,
	RANGE_T_EXP = 2,
	G = 50, -- Gravity constant for parabola

	PULSE_DURATION = 0.8,
	PULSE_PERIOD = 1,
	PULSE_EXP = 2,
	PULSE_SIZE_0 = 0.25,
	PULSE_SIZE_1 = 2,

	BALL_WAVE_PERIOD = 2,
	BALL_WAVE_AMPLITUDE = 0.5,
	BALL_WAVE_START = 0.25,
	BALL_WAVE_EXP = 0.8,

	FLOOR_OFFSET = 4.5,

	FADE_OUT_DURATION = 0.125,
	FADE_IN_DURATION = 0.125,

	CLEAR_AABB_SIZE = Vector3.new(2.5, 4, 2.5),
	CLEAR_TEST_ENABLED = false,

	SUCCESS_SOUND = "", --Unused for now
	FAIL_SOUND = "", --Unused for now
	SOUNDS_ENABLED = false,

	PATH_RECOMPUTE_DIST_THRESHOLD = 4,

	TRANSITION_DURATION = 0.25,
	TRANSITION_FUNC = Utility:GetEaseInOutQuad()
}

local LASER = {
	MODE_ENABLED = true,

	ARC_COLOR_GOOD = TELEPORT.ARC_COLOR_GOOD,
	ARC_COLOR_BAD = TELEPORT.ARC_COLOR_BAD,
	ARC_THICKNESS = 0.025,

	MAX_DISTANCE = 100,

	G = 0, -- Gravity constant for parabola; in this case we want a laser/straight line

	--Couldn't figure out a good name for this. This is the maximum angle that the parabola's hit point
	--can be from the laser's hit point when switching to laser pointer mode solely from the parabola hitting
	--a gui part. 
	SWITCH_AIM_THRESHOLD = math.rad(15),

	TRANSITION_DURATION = 0.075,
	TRANSITION_FUNC = Utility:GetEaseInOutQuad()
}

local zeroVector2, identityVector2 = Vector2.new(0, 0), Vector2.new(1, 1)
local zeroVector3, identityVector3 = Vector3.new(0, 0, 0), Vector3.new(1, 1, 1)
local flattenMask = Vector3.new(1, 0, 1) --flattens a direction vector when multiplied by removing the vertical component
local minimumPartSize = Vector3.new(0.2, 0.2, 0.2)
local identity = CFrame.new()

local aimableStates = {
	[Enum.HumanoidStateType.Running] = true,
	[Enum.HumanoidStateType.RunningNoPhysics] = true,
	[Enum.HumanoidStateType.None] = true
}

local LaserPointer = {}
LaserPointer.__index = LaserPointer

function LaserPointer.new()
	local self = setmetatable({}, LaserPointer)

	self.enabled = false

	self.inputUserCFrame = Enum.UserCFrame.Head
	self.equippedTool = false

	self.tweener = false
	self.transitionAlpha = 0
	self.lengthAlpha = 1
	self.lastLaserModeHit = tick()

	self.forceLaserMode = false
	self.teleportMode = true
	self.teleportRangeT = 0
	self.teleportPoint = zeroVector3
	self.teleportNormal = Vector3.new(0, 1, 0)
	self.teleportPart = nil
	self.teleportValid = false
	self.lastTeleportValidityChange = tick()
	self.teleportButtonDown = false
	self.teleporting = false
	self.teleportBounceStart = tick()

	self.pathValid = false
	self.computingPath = false
	self.pathStart = zeroVector3
	self.pathEnd = zeroVector3

	self.testWalkToMode = false

	do --Create the instances that make up the Laser Pointer
		--Create the ParabolaAdornment first; if the class doesn't exist, we'll exit early.
		if not pcall(function()
			self.parabola = Utility:Create("ParabolaAdornment") {
				Name = "LaserPointerParabola",
				Parent = CoreGui,
				A = -1,
				B = 2,
				C = 0,
				Color3 = TELEPORT.COLOR_GOOD,
				Thickness = TELEPORT.ARC_THICKNESS
			}
			end) then
			return nil
		end

		self.originPart = Utility:Create("Part") {
			Name = "LaserPointerOrigin",
			Anchored = true,
			CanCollide = false,
			TopSurface = Enum.SurfaceType.SmoothNoOutlines,
			BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
			Material = Enum.Material.SmoothPlastic,
			Size = minimumPartSize,
			Transparency = 1 --smallest size possible
		}
		self.parabola.Adornee = self.originPart
		

		self.plopPart = Utility:Create("Part") {
			Name = "LaserPointerTeleportPlop",
			Anchored = true,
			CanCollide = false,
			Size = minimumPartSize,
			Transparency = 1
		}
		self.plopBall = Utility:Create("Part") {
			Name = "LaserPointerTeleportPlopBall",
			Anchored = true,
			CanCollide = false,
			TopSurface = Enum.SurfaceType.SmoothNoOutlines,
			BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
			Material = Enum.Material.Neon,
			BrickColor = TELEPORT.PLOP_BALL_COLOR_GOOD,
			Shape = Enum.PartType.Ball,
			Size = identityVector3 * TELEPORT.PLOP_BALL_SIZE
		}
		self.plopAdorn = Utility:Create("ImageHandleAdornment") {
			Name = "LaserPointerTeleportPlopAdorn",
			Parent = self.plopPart,
			Adornee = self.plopPart,
			Size = identityVector2 * TELEPORT.PLOP_SIZE,
			Image = TELEPORT.PLOP_GOOD
		}
		self.plopAdornPulse = Utility:Create("ImageHandleAdornment") {
			Name = "LaserPointerTeleportPlopAdornPulse",
			Parent = self.plopPart,
			Adornee = self.plopPart,
			Size = zeroVector2,
			Image = TELEPORT.PLOP_GOOD,
			Transparency = 0.5
		}

		if TELEPORT.CLEAR_TEST_ENABLED then
			--TODO: Before re-enabling CLEAR_TEST_ENABLED, find a better solution
			self.collisionTestPart = Utility:Create("Part") {
				Name = "LaserPointerTeleportCollisionTester",
				Size = TELEPORT.CLEAR_AABB_SIZE,
				Transparency = 1,
				Anchored = true,
				CanCollide = true,
				Parent = workspace.CurrentCamera,
				CFrame = CFrame.new(1e10, 1e10, 1e10)
			}
		end

		if TELEPORT.SOUNDS_ENABLED then
			self.teleportSuccessSound = Utility:Create("Sound") {
				Name = "TeleportSuccessSound",
				SoundId = TELEPORT.SUCCESS_SOUND,
				Parent = self.originPart
			}
			self.teleportFailSound = Utility:Create("Sound") {
				Name = "TeleportFailSound",
				SoundId = TELEPORT.FAIL_SOUND,
				Parent = self.originPart
			}
		end
	end

	do --Event connections and final setup
		if LocalPlayer.Character then
			self:onCharacterAdded(LocalPlayer.Character)
		end
		LocalPlayer.CharacterAdded:connect(function(character)
			self:onCharacterAdded(character)
		end)

		GuiService.MenuOpened:connect(function()
			self.forceLaserMode = true
		end)
		GuiService.MenuClosed:connect(function()
			self.forceLaserMode = false
		end)

		if VRServiceExists then
			self.inputUserCFrame = VRService.GuiInputUserCFrame
			VRService.Changed:connect(function(prop)
				if prop == "GuiInputUserCFrame" and self.enabled then
					self:tweenLaserLength(0, 0.25)

					wait(0.25)

					self.inputUserCFrame = VRService.GuiInputUserCFrame
					self:setTriggerActionEnabled(self.inputUserCFrame ~= Enum.UserCFrame.Head)
					self:setButtonActionEnabled(self.inputUserCFrame == Enum.UserCFrame.Head)

					if self:shouldShowLaser() then
						self:tweenLaserLength(1)
					end
				end
			end)
		end

		if areTestControlSchemesEnabled then
			ContextActionService:BindCoreAction("Head Mounted", function(actionName, inputState, inputObj)
				if inputState ~= Enum.UserInputState.End then return end
				VRService.GuiInputUserCFrame = Enum.UserCFrame.Head
			end, false, Enum.KeyCode.KeypadOne)
			ContextActionService:BindCoreAction("Right Hand Mounted", function(actionName, inputState, inputObj)
				if inputState ~= Enum.UserInputState.End then return end
				VRService.GuiInputUserCFrame = Enum.UserCFrame.RightHand
				self.testWalkToMode = false
			end, false, Enum.KeyCode.KeypadTwo)
			ContextActionService:BindCoreAction("Parabola Walkto", function(actionName, inputState, inputObj)
				if inputState ~= Enum.UserInputState.End then return end
				VRService.GuiInputUserCFrame = Enum.UserCFrame.RightHand
				self.testWalkToMode = true
			end, false, Enum.KeyCode.KeypadThree)
		end

		self:setTeleportMode(false)
	end

	return self
end

do --Helper functions

	function LaserPointer:calculateLaunchVelocity(gravity, launchAngle)
		local maxVelocity = TELEPORT.MAX_VALID_DISTANCE
		if self.testWalkToMode then
			return maxVelocity
		end
		local minVelocity = TELEPORT.MIN_VELOCITY
		local velocityRange = math.max(0, maxVelocity - minVelocity)
		return ((self.teleportRangeT ^ TELEPORT.RANGE_T_EXP) * velocityRange) + minVelocity
	end

	function LaserPointer:isHeadMounted()
		return self.inputUserCFrame == Enum.UserCFrame.Head
	end

	function LaserPointer:shouldShowLaser()
		if not self.enabled then
			return false
		end
		if self:isHeadMounted() then
			return self.equippedTool == false
		end

		return true
	end

	function LaserPointer:shouldWalk()
		return self:isHeadMounted() or self.testWalkToMode
	end
end

do --Input handlers - can we eventually move this stuff to PlayerScripts? CoreScripts shouldn't need to handle input ideally...

	function LaserPointer:onTeleportTriggerAction(actionName, inputState, inputObj)
		if self.teleporting or not self.teleportMode then
			return
		end

		local state = inputObj.Position.Z
		if self.teleportButtonDown and state < TELEPORT.BUTTON_UP_THRESHOLD then
			self.teleportButtonDown = false
			coroutine.wrap(function()
				if self:shouldWalk() then
					self:doWalkTo(self.teleportPoint)
				else
					 self:doTeleport()
				end
			end)()
			return
		end

		if not self.teleportButtonDown and state > TELEPORT.BUTTON_DOWN_THRESHOLD then
			self.teleportButtonDown = true
		end
	end

	function LaserPointer:onTeleportButtonAction(actionName, inputState, inputObj)
		if inputState == Enum.UserInputState.Begin then
			if self.equippedTool and UserInputService.TouchEnabled then
				self.equippedTool:Activate()
			else
				if self.teleportMode then
					self:doWalkTo(self.teleportPoint)
				end
			end
		end
	end

	function LaserPointer:setTriggerActionEnabled(enabled)
		if enabled then
			ContextActionService:BindCoreAction("TeleportTriggerImpl", function(...) self:onTeleportTriggerAction(...) end, false, self.inputUserCFrame == Enum.UserCFrame.RightHand and Enum.KeyCode.ButtonA or Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindCoreAction("TeleportTriggerImpl")
		end
	end

	function LaserPointer:setButtonActionEnabled(enabled)
		if enabled then
			ContextActionService:BindCoreAction("TeleportButtonImpl", function(...) self:onTeleportButtonAction(...) end, false, Enum.KeyCode.ButtonA)
		else
			ContextActionService:UnbindCoreAction("TeleportButtonImpl")
		end
	end
end

do --Configuration functions

	function LaserPointer:setEnabled(enabled)
		if enabled == self.enabled then return end
		self.enabled = enabled
		if self.enabled then
			self:setTriggerActionEnabled(self.inputUserCFrame ~= Enum.UserCFrame.Head)
			self:setButtonActionEnabled(self.inputUserCFrame == Enum.UserCFrame.Head)

			setPartInGame(self.originPart, true)

			self:setTeleportMode(false)
			if self.clickToMoveModule then
				self.clickToMoveModule:Start(true)
			end
		else
			self:setTriggerActionEnabled(not self.inputUserCFrame ~= Enum.UserCFrame.Head)
			self:setButtonActionEnabled(not self.inputUserCFrame == Enum.UserCFrame.Head)

			setPartInGame(self.originPart, false)
			
			if self.clickToMoveModule then
				self.clickToMoveModule:Stop()
			end
		end
	end

	function LaserPointer:setTeleportMode(enabled)
		if enabled == self.teleportMode then return	end

		self.teleportMode = enabled

		local alpha0, alpha1, duration, easingFunc
		if self.teleportMode then
			setPartInGame(self.plopPart, true)
			setPartInGame(self.plopBall, true)

			self:tweenLaserLength(1)
		else
			setPartInGame(self.plopPart, false)
			setPartInGame(self.plopBall, false)
		end
	end

	function LaserPointer:setArcLaunchParams(launchAngle, launchVelocity, gravity)
		local velocityX = math.cos(launchAngle) * launchVelocity
		local velocityY = math.sin(launchAngle) * launchVelocity

		--don't let velocityX = 0 or we get a divide-by-zero and bad things happen
		if velocityX == 0 then
			velocityX = 1e-6
		end

		self.parabola.A = (-0.5 * gravity) / (velocityX ^ 2)
		self.parabola.B = velocityY / velocityX
		self.parabola.C = 0
		self.parabola.Range = velocityX
	end

	function LaserPointer:renderAsParabola(origin, lookDir)
		local lookFlat = lookDir * flattenMask
		self.originPart.CFrame = CFrame.new(origin, origin + lookFlat) * CFrame.Angles(0, math.pi / 2, 0)
	end

	function LaserPointer:renderAsLaser(laserOriginPos, laserEndpoint)
		self.originPart.CFrame = CFrame.new(laserOriginPos, laserEndpoint) * CFrame.Angles(0, math.pi / 2, 0)
		self.parabola.A = 0
		self.parabola.B = 1e-6
		self.parabola.C = 0
		self.parabola.Range = (laserEndpoint - laserOriginPos).magnitude * self.lengthAlpha
	end

end

do --Raycasting functions
	function LaserPointer:getArcHit(pos, look, ignore)
		if self.parabola.A == 0 then
			--Just skip the parabola since this is effectively a line without the x^2 term
			return self:getLaserHit(pos, look, ignore)
		end

		self:renderAsParabola(pos, look)

		local parabHitPart, parabHitPoint, parabHitNormal, parabHitMaterial, t = self.parabola:FindPartOnParabola(ignore)
		return parabHitPart, parabHitPoint, parabHitNormal, t
	end

	function LaserPointer:getLaserHit(pos, look, ignore)
		local ray = Ray.new(pos, look * LASER.MAX_DISTANCE)
		local laserHitPart, laserHitPoint, laserHitNormal, laserHitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignore)
		local t = (laserHitPoint - pos).magnitude / LASER.MAX_DISTANCE
		return laserHitPart, laserHitPoint, laserHitNormal, t
	end
end

do --Pathfinding functions

	function LaserPointer:recomputePath(startPos, endPos)
		self.computingPath = true

		self.pathStart = startPos
		self.pathEnd = endPos
		coroutine.wrap(function()
			self.lastPath = PathfindingService:ComputeRawPathAsync(startPos, endPos, TELEPORT.MAX_VALID_DISTANCE)
			self.computingPath = false
		end)()
	end

	function LaserPointer:checkLastPath()
		if not self.lastPath then
			self.pathValid = true
			return
		end
		if self.lastPath.Status ~= Enum.PathStatus.Success then
			self.pathValid = false
			return
		end
		local occludedPoint = self.lastPath:CheckOcclusionAsync(0)
		if occludedPoint < 0 then
			self.pathValid = true
		end
	end
end

do --Action functions

	function LaserPointer:doTeleport()
		self.teleportRangeT = 0

		local teleportValid = self.teleportValid
		local teleportPoint = self.teleportPoint
		local teleportNormal = self.teleportNormal

		local character = LocalPlayer.Character
		if not character then
			return
		end

		if teleportValid then
			--play teleport success sound
			if TELEPORT.SOUNDS_ENABLED then
				self.teleportSuccessSound:Play()
			end
			self.teleporting = true

			wait(FADE_OUT_DURATION)

			local camera = workspace.CurrentCamera
			local flatLookDir = camera.CFrame.lookVector * flattenMask
			local pos = teleportPoint + (teleportNormal * TELEPORT.FLOOR_OFFSET)
			character:SetPrimaryPartCFrame(CFrame.new(pos, pos + flatLookDir))

			wait(FADE_IN_DURATION)
			self.teleporting = false
		else
			--play teleport failed sound
			if TELEPORT.SOUNDS_ENABLED then
				self.teleportFailSound:Play()
			end
		end
	end

	function LaserPointer:doToolAim(aimPoint)
		if not aimPoint then
			return
		end
		if self.equippedTool then
			local humanoid = getLocalHumanoid()
			if not humanoid then return end

			if not aimableStates[humanoid:GetState()] then return end

			local rootPart = humanoid.Torso
			if not rootPart then return end

			local rootPos = rootPart.CFrame.p
			local vecToAimPoint = ((aimPoint - rootPos) * flattenMask).unit
			local desiredRotation = CFrame.new(zeroVector3, vecToAimPoint)

			rootPart.CFrame = CFrame.new(rootPos) * desiredRotation
		end
	end

	function LaserPointer:doWalkTo(point)
		local humanoid = getLocalHumanoid()
		if not humanoid then return end

		if humanoid:GetState() == Enum.HumanoidStateType.Seated and self:isHeadMounted() then
			--No jump button on one-button VR, so just jump out of seats for now.
			humanoid.Jump = true
		end

		if self.clickToMoveModule then
			self.clickToMoveModule:ForceGoTo(point)
		else
			--fall back
			humanoid:MoveTo(point)
		end
	end
end

do --Laser/teleport functions
	function LaserPointer:canTeleportTo(cameraPos, part, point, normal)
		local character = LocalPlayer.Character
		if not character then
			return false
		end
		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if not humanoidRootPart then
			return false
		end

		if self:isHeadMounted() then
			return true
		end

		if not part then
			return false
		end

		if normal.Y < 0 then
			return false
		end

		if self.inputUserCFrame == Enum.UserCFrame.Head then
			return true
		end

		local dist = (point - humanoidRootPart.Position).magnitude
		if dist > TELEPORT.MAX_VALID_DISTANCE and not self.testWalkToMode then
			return false
		end

		if TELEPORT.CLEAR_TEST_ENABLED then
			local bbPos = point
			local halfBbSize = TELEPORT.CLEAR_AABB_SIZE * 0.5
			local minBound = Vector3.new(bbPos.X - halfBbSize.X, bbPos.Y, bbPos.Z - halfBbSize.Z)
			local maxBound = minBound + TELEPORT.CLEAR_AABB_SIZE

			local theta = math.rad(90) - math.asin(normal.Y)
			local slopeOffset = math.sin(theta) * math.sqrt(halfBbSize.X^2 + halfBbSize.Z^2)
			self.collisionTestPart.CFrame = CFrame.new(bbPos + Vector3.new(0, (TELEPORT.CLEAR_AABB_SIZE.Y / 2) + slopeOffset + 0.1, 0))
			
			--workspace:FindPartsInRegion3 uses AABBs of parts, which means slopes make really big boxes. No good for checking occlusion.
			--Using an arbitary part here sounds nasty as an implementation detail, but the concept seems sound.
			--Getting the part out of the workspace entirely would be a good long-term solution.
			local foundParts = self.collisionTestPart:GetTouchingParts()
			--send it far away so it doesn't interfere with devs (I really hate doing this)
			self.collisionTestPart.CFrame = CFrame.new(1e10, 1e10, 1e10)

			for i, v in pairs(foundParts) do
				if v ~= self.plopPart and v ~= self.plopBall and not v:IsDescendantOf(LocalPlayer.Character) then
					return false
				end
			end
		end

		if usePathfinding then
			self:checkLastPath()
			if not self.computingPath then
				local startPos = humanoidRootPart.Position
				local endPos = point + Vector3.new(0, 4, 0)

				local startDist = (self.pathStart - startPos).magnitude
				local endDist = (self.pathEnd - endPos).magnitude
				if startDist > TELEPORT.PATH_RECOMPUTE_DIST_THRESHOLD or endDist > TELEPORT.PATH_RECOMPUTE_DIST_THRESHOLD or not self.pathValid then
					self:recomputePath(startPos, endPos)
				end
			end
			
			if not self.pathValid then
				return false
			end
		end

		return true
	end

	function LaserPointer:checkHeadMountedTeleportMode(originPos, originLook)
		local ray = Ray.new(originPos, originLook * 999)
		local hitPart = nil
		if isRaycastWhitelistEnabled then
			hitPart = workspace:FindPartOnRayWithWhitelist(ray, { GuiService.CoreGuiFolder })
		else
			hitPart = workspace:FindPartOnRayWithIgnoreList(ray, { LocalPlayer.Character })
		end
		if hitPart and self:shouldShowLaser() then
			self:setTeleportMode(false)
			self:tweenLaserLength(1)
			return
		end
		if not self.equippedTool then
			self:setTeleportMode(true)
		end
	end

	function LaserPointer:checkTeleportMode(originPos, parabHitPart, parabHitPoint, laserHitPart, laserHitPoint)
		if self.forceLaserMode then
			if self.teleportMode then
				self:setTeleportMode(false)
			else
				return
			end
		end
		if self.teleportMode and not LASER.MODE_ENABLED then
			return
		end
		if not self.teleportMode and not TELEPORT.MODE_ENABLED then
			return
		end

		local angleBetween = 0

		--only check the angle between these two if the hit points aren't exactly equal
		if parabHitPoint ~= laserHitPoint then
			local toParabHit = (parabHitPoint - originPos).unit
			local toLaserHit = (laserHitPoint - originPos).unit
			angleBetween = math.acos(toParabHit:Dot(toLaserHit))
		end

		--todo: update this when we move the parts; also update it so that it can work with user surfaceguis
		--we may need to be more creative about that since we can't easily tell if a part has a surfacegui from Lua
		local coreGuiPartContainer = GuiService.CoreGuiFolder
		local laserHitGui = laserHitPart and laserHitPart:IsDescendantOf(coreGuiPartContainer)	
		local parabHitGui = laserHitGui
		--only check parab hit part if it's not the same as the laser hit part
		if parabHitPart ~= laserHitPart then
			parabHitGui = parabHitPart and parabHitPart:IsDescendantOf(coreGuiPartContainer)
		end

		local newTeleportMode = self.teleportMode

		if laserHitGui then
			self.lastLaserModeHit = tick()
		end

		--If we are teleporting and the parabola hits a gui part, we switch to laser pointer if the laser pointer is close enough
		--If we are teleporting and the laser hits a gui part, we switch to laser pointer regardless of where the parabola is
		if self.teleportMode and laserHitGui then
			if self:isHeadMounted() or ((parabHitGui and angleBetween < LASER.SWITCH_AIM_THRESHOLD) or laserHitGui) then
				newTeleportMode = false
			end
		end

		--If we are in laser pointer mode but neither the parabola nor the laser hit any gui parts, we switch back to teleport mode.
		if not self.teleportMode and not laserHitGui and not parabHitGui and tick() - self.lastLaserModeHit > 0.2 then
			newTeleportMode = true
		end

		self:setTeleportMode(newTeleportMode)
	end


	function LaserPointer:tweenLaserLength(target, duration)
		duration = duration or 0.5
		if self.tweener then
			if self.tweener:GetFinal() == target then
				return
			end
			self.tweener:Cancel()
			self.tweener = false
		end
		if target ~= self.lengthAlpha then
			self.tweener = Utility:TweenProperty(self, "lengthAlpha", self.lengthAlpha, target, duration, Utility:GetEaseInOutQuad(), function()
				self.tweener = false
			end)
		end
	end

	function LaserPointer:setTeleportValidState(valid)
		if valid == self.teleportValid then return end
		self.teleportValid = valid
		self.lastTeleportValidityChange = tick()

		if not self.inputUserCFrame == Enum.UserCFrame.Head and self.tweener ~= false then
			valid = true
		end

		self:tweenLaserLength(1)

		if valid then
			self.teleportBounceStart = tick()
			self.parabola.Color3 = TELEPORT.ARC_COLOR_GOOD
			self.plopAdorn.Visible = true
			self.plopAdorn.Image = TELEPORT.PLOP_GOOD
			self.plopAdornPulse.Visible = true
			self.plopAdornPulse.Image = TELEPORT.PLOP_GOOD
			self.plopBall.BrickColor = TELEPORT.PLOP_BALL_COLOR_GOOD
		else
			self.parabola.Color3 = TELEPORT.ARC_COLOR_BAD
			self.plopAdorn.Visible = false
			self.plopAdorn.Image = TELEPORT.PLOP_BAD
			self.plopAdornPulse.Visible = false
			self.plopAdornPulse.Image = TELEPORT.PLOP_BAD
			self.plopBall.BrickColor = TELEPORT.PLOP_BALL_COLOR_BAD
		end
	end

	function LaserPointer:updateTeleportPlop(parabHitPoint, parabHitNormal)
		local now = tick() - self.teleportBounceStart

		--Make a CFrame out of our hit point and normal; tangent doesn't matter because it's all circular!
		local plopCF = CFrame.new(parabHitPoint, parabHitPoint + parabHitNormal)

		--Calculate the height of the ball from a sine wave raised to a configurable exponent
		if self.teleportValid then
			local ballWave = applyExpCurve(math.sin((now * 2 * math.pi) / TELEPORT.BALL_WAVE_PERIOD), TELEPORT.BALL_WAVE_EXP)
			ballHeight = TELEPORT.BALL_WAVE_START + (ballWave * TELEPORT.BALL_WAVE_AMPLITUDE)
		else
			--If the teleport isn't valid, just lock the ball in place.
			ballHeight = 0
		end

		self.plopPart.CFrame = plopCF
		self.plopBall.CFrame = plopCF * CFrame.new(0, 0, -ballHeight)

		--Handle the pulse animation
		--We're scheduling it to begin every TELEPORT.PULSE_PERIOD seconds
		--and the animation runs for TELEPORT.PULSE_DURATION seconds. TELEPORT.PULSE_EXP
		--affects the growth rate of the pulse size; ^2 is a good look, starts slow and accelerates.
		local timeSincePulseStart = now % TELEPORT.PULSE_PERIOD
		if timeSincePulseStart > 0 then
			local pulseSize = timeSincePulseStart / TELEPORT.PULSE_DURATION
			if pulseSize < 1 then
				self.plopAdornPulse.Visible = true
				self.plopAdornPulse.Size = identityVector2 * (TELEPORT.PULSE_SIZE_0 + applyExpCurve(pulseSize, TELEPORT.PULSE_EXP) * (TELEPORT.PULSE_SIZE_1 - TELEPORT.PULSE_SIZE_0))
				self.plopAdornPulse.Transparency = 0.5 + (pulseSize * 0.5)
			else
				self.plopAdornPulse.Visible = false
				self.plopAdornPulse.Size = zeroVector2
				self.pulseStartTime = tick() + TELEPORT.PULSE_PERIOD
			end
		end
	end


	function LaserPointer:updateTeleportHoldState(dt)
		--Increase launch velocity if teleport button is held
		if self.teleportButtonDown and self.teleportMode then
			self.teleportRangeT = math.min(1, self.teleportRangeT + dt)
		else
			self.teleportRangeT = 0
		end
	end

	function LaserPointer:updateTeleportMode(hitPoint, hitNormal, hitPart)
		self.teleportPoint = hitPoint
		self.teleportNormal = hitNormal
		self.teleportPart = hitPart

		self:updateTeleportPlop(hitPoint, hitNormal)
		self:setTeleportValidState(self:canTeleportTo(workspace.CurrentCamera.CFrame.p, self.teleportPart, self.teleportPoint, self.teleportNormal))
	end
end

do --Event callbacks/update loop
	function LaserPointer:update(dt)
		if not self.enabled then
			return
		end
		local ignore = { game.Players.LocalPlayer.Character, self.originPart, self.plopPart, self.plopBall }
		local cameraSpace = workspace.CurrentCamera.CFrame
		local thickness0, thickness1 = LASER.ARC_THICKNESS, TELEPORT.ARC_THICKNESS
		local gravity0, gravity1 = LASER.G, TELEPORT.G

		if self:isHeadMounted() then
			self.parabola.Thickness = LASER.ARC_THICKNESS * HEAD_MOUNT_THICKNESS_MULTIPLIER

			--cast ray from center of camera, then render laser going from offset point to hit point
			local originCFrame = cameraSpace * UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
			local originPos, originLook = originCFrame.p, originCFrame.lookVector

			local laserHitPart, laserHitPoint, laserHitNormal, laserHitT = self:getLaserHit(originPos, originLook, ignore)
			self:checkHeadMountedTeleportMode(originPos, originLook)

			--we actually want to render the laser from an offset from the head though
			local offsetPosition = originCFrame:pointToWorldSpace(HEAD_MOUNT_OFFSET * workspace.CurrentCamera.HeadScale)
			self:renderAsLaser(offsetPosition, laserHitPoint)

			if self.teleportMode then
				self:updateTeleportMode(laserHitPoint, laserHitNormal, laserHitPart)
			else
				self.parabola.Color3 = LASER.ARC_COLOR_GOOD
				self:doToolAim(laserHitPoint)
			end
		else
			self:updateTeleportHoldState(dt)

			local originCFrame = cameraSpace * UserInputService:GetUserCFrame(self.inputUserCFrame)
			local originPos, originLook = originCFrame.p, originCFrame.lookVector

			local gravity = TELEPORT.G

			local launchAngle = math.asin(originLook.Y)
			local launchVelocity = self:calculateLaunchVelocity(gravity, launchAngle)

			self:setArcLaunchParams(launchAngle, launchVelocity, gravity)
			
			--Always check for both parabola and laser hits so we can use it to judge when to transition
			ignore[5] = GuiService.CoreGuiFolder
			ignore[6] = GuiService.CoreEffectFolder
			local parabHitPart, parabHitPoint, parabHitNormal, parabHitT = self:getArcHit(originPos, originLook, ignore)

			--Clear the camera out of our ignore table and cast so we might hit SurfaceGuis
			ignore[5] = nil
			ignore[6] = nil
			local laserHitPart, laserHitPoint, laserHitNormal, laserHitT = self:getLaserHit(originPos, originLook, ignore)

			self:checkTeleportMode(originPos, parabHitPart, parabHitPoint, laserHitPart, laserHitPoint)

			if self.teleportMode then
				self.parabola.Range = parabHitT * math.cos(launchAngle) * launchVelocity * self.lengthAlpha
				self.parabola.Thickness = TELEPORT.ARC_THICKNESS
				self:updateTeleportMode(parabHitPoint, parabHitNormal, parabHitPart)

				local lookCFrame = workspace.CurrentCamera:GetRenderCFrame()
				local lookRay = Ray.new(lookCFrame.p, lookCFrame.lookVector * 999)
				local _, lookHitPoint = workspace:FindPartOnRayWithIgnoreList(lookRay, { workspace.CurrentCamera, LocalPlayer.Character })
				self:doToolAim(lookHitPoint)
			else
				self.parabola.Color3 = LASER.ARC_COLOR_GOOD
				self.parabola.Thickness = LASER.ARC_THICKNESS
				self:renderAsLaser(originPos, laserHitPoint)
			end
		end
	end

	function LaserPointer:onCharacterAdded(character)
		self.equippedTool = false

		character.ChildAdded:connect(function(child)
			if child:IsA("Tool") then
				self.equippedTool = child
				self:setTeleportMode(false)
				self:tweenLaserLength(0)
			end
		end)
		character.ChildRemoved:connect(function(child)
			if child == self.equippedTool then
				self.equippedTool = false
				self:setTeleportMode(false)
				self:tweenLaserLength(1)
			end
		end)
	end
end

return LaserPointer]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX52B6F806F91A4CFFA9C6A11F688E5B47">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Dialog</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Dialog: 3D dialogs for ROBLOX in VR
--written by 0xBAADF00D
--6/30/2016

local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local InputService = game:GetService("UserInputService")
local Utility = require(RobloxGui.Modules.Settings.Utility)
local Panel3D = require(RobloxGui.Modules.VR.Panel3D)

local DIALOG_BG_COLOR = Color3.new(0.2, 0.2, 0.2)
local DIALOG_BG_TRANSPARENCY = 0.3
local DIALOG_TITLE_HEIGHT = 66
local DIALOG_COLOR_HEIGHT = 8
local DIALOG_TITLE_TEXT_SIZE = Enum.FontSize.Size36
local DIALOG_CONTENT_PADDING = 48
local TITLE_COLOR = Color3.new(1, 1, 1)

local PANEL_OFFSET_CF = CFrame.new(0, 0, -7) * CFrame.Angles(0, math.pi, 0)

local emptySelectionImage = Utility:Create "ImageLabel" { 
	Name = "EmptySelectionImage", 
	Image = "", 
	BackgroundTransparency = 1, 
	ImageTransparency = 1 
}

local DialogPanel = Panel3D.Get("Dialog")
DialogPanel:SetType(Panel3D.Type.Fixed)
DialogPanel.localCF = PANEL_OFFSET_CF
DialogPanel:SetCanFade(true)

local dialogPanelAngle = 0
local opacityLookup = {}
local resetBaseAngle = false
local baseAngle = 0


local PANEL_FADE_ANGLE_0, PANEL_FADE_ANGLE_1 = math.rad(37.5), math.rad(44)
local PANEL_FADE_RANGE = PANEL_FADE_ANGLE_1 - PANEL_FADE_ANGLE_0
local PANEL_REAPPEAR_ANGLE = math.rad(90)

local function positionDialogPanel(desiredAngle)
	dialogPanelAngle = desiredAngle
	local headCF = InputService:GetUserCFrame(Enum.UserCFrame.Head)
	local headPos = headCF.p
	DialogPanel.localCF = CFrame.new(headPos) * CFrame.Angles(0, desiredAngle, 0) * PANEL_OFFSET_CF
end

function DialogPanel:CalculateTransparency()
	local headCF = InputService:GetUserCFrame(Enum.UserCFrame.Head)
	local headLook = headCF.lookVector * Vector3.new(1, 0, 1)
	local vertAngle = math.asin(headCF.lookVector.Y)
	local vectorToPanel = Vector3.new(math.cos(baseAngle + dialogPanelAngle + math.rad(90)), 0, -math.sin(baseAngle + dialogPanelAngle + math.rad(90)))

	if math.abs(vertAngle) > PANEL_FADE_ANGLE_1 then
		resetBaseAngle = true
	end

	local angleToPanel = math.acos(headLook:Dot(vectorToPanel))
	
	return math.min(math.max(0, (angleToPanel - PANEL_FADE_ANGLE_0) / PANEL_FADE_RANGE), 1)
end


local function updatePanelPosition()
	local headCF = InputService:GetUserCFrame(Enum.UserCFrame.Head)
	local headLook = headCF.lookVector * Vector3.new(1, 0, 1)
	local headAngle = (math.atan2(-headLook.Z, headLook.X) - math.rad(90)) % math.rad(360)
	local newPanelAngle = baseAngle + math.floor((headAngle / PANEL_REAPPEAR_ANGLE) + 0.5) * PANEL_REAPPEAR_ANGLE

	if resetBaseAngle then
		resetBaseAngle = false
		baseAngle = headAngle
	end

	positionDialogPanel(newPanelAngle)
end


game:GetService("RunService"):BindToRenderStep("DialogPanel", Enum.RenderPriority.First.Value, function()
	if DialogPanel.transparency == 1 or resetBaseAngle then
		updatePanelPosition()
	end

	--update the transparency of gui elements
	local opacityMult = 1 - DialogPanel.transparency
	for guiElement, baseOpacity in pairs(opacityLookup) do
		local transparency = 1 - (baseOpacity * opacityMult)
		if guiElement:IsA("TextLabel") or guiElement:IsA("TextButton") then
			guiElement.TextTransparency = transparency
		elseif guiElement:IsA("ImageLabel") or guiElement:IsA("ImageButton") then
			guiElement.ImageTransparency = transparency
		elseif guiElement:IsA("Frame") then
			guiElement.BackgroundTransparency = transparency
		end
	end
end)

local DialogQueue = {}

local currentDescendantConn = nil
local lastDialogShown = nil
local function updatePanel()
	local currentDialog = DialogQueue[1]
	if lastDialogShown and lastDialogShown.content then
		lastDialogShown.content.Parent = nil
	end
	if not currentDialog or not currentDialog.content then
		DialogPanel:SetVisible(false)
		opacityLookup = {}
		if currentDescendantConn then
			currentDescendantConn:disconnect()
			currentDescendantConn = nil
		end
	else
		currentDialog.content.Parent = DialogPanel:GetGUI()
		lastDialogShown = currentDialog

		local contentSize = currentDialog.content.AbsoluteSize
		DialogPanel:ResizePixels(contentSize.X, contentSize.Y, 100)
		
		resetBaseAngle = true
		updatePanelPosition()
		DialogPanel:SetVisible(true)

		opacityLookup = {}
		local function search(parent)
			if parent:IsA("ImageLabel") or parent:IsA("ImageButton") then
				opacityLookup[parent] = 1 - parent.ImageTransparency
			elseif parent:IsA("TextLabel") or parent:IsA("TextButton") then
				opacityLookup[parent] = 1 - parent.TextTransparency
			elseif parent:IsA("Frame") then
				opacityLookup[parent] = 1 - parent.BackgroundTransparency
			end
			for i, v in pairs(parent:GetChildren()) do
				search(v)
			end
		end
		search(DialogPanel:GetGUI())
		if currentDescendantConn then
			currentDescendantConn:disconnect()
			currentDescendantConn = nil
		end
		currentDescendantConn = DialogPanel:GetGUI().DescendantAdded:connect(function(descendant)
			search(descendant)
		end)


	end
end



local Dialog = {}
Dialog.__index = Dialog
function Dialog.new(content)
	local self = setmetatable({}, Dialog)
	self.content = content
	return self
end

function Dialog:SetContent(guiElement)
	if not guiElement and self.content then
		self.content.Parent = nil
	end
	self.content = guiElement
end

function Dialog:Show(shouldTakeover)
	if shouldTakeover then
		table.insert(DialogQueue, 1, self)
	else
		table.insert(DialogQueue, self)
	end
	updatePanel()
end

function Dialog:Close()
	for idx, dialog in pairs(DialogQueue) do
		if dialog == self then
			table.remove(DialogQueue, idx)
			break
		end
	end
	updatePanel()
end

return Dialog]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB0445141BA8F4EA0B78E0E86D051641B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UserGui</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local InputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
local VRHub = require(RobloxGui.Modules.VR.VRHub)
local VRKeyboard = require(RobloxGui.Modules.VR.VirtualKeyboard)

local PANEL_OFFSET_CFRAME = CFrame.Angles(math.rad(-5), 0, 0) * CFrame.new(0, 5, 0) * CFrame.Angles(math.rad(-15), 0, 0)

local UserGuiModule = {}
UserGuiModule.ModuleName = "UserGui"
UserGuiModule.KeepVRTopbarOpen = false
UserGuiModule.VRIsExclusive = false
UserGuiModule.VRClosesNonExclusive = false
VRHub:RegisterModule(UserGuiModule)

local userGuiPanel = Panel3D.Get(UserGuiModule.ModuleName)
userGuiPanel:SetType(Panel3D.Type.Fixed)
userGuiPanel:ResizeStuds(4, 4, 128)
userGuiPanel:SetVisible(false)

VRHub.ModuleOpened.Event:connect(function(moduleName)
	if moduleName ~= UserGuiModule.ModuleName then
		local module = VRHub:GetModule(moduleName)
		if module.VRClosesNonExclusive and userGuiPanel:IsVisible() then
			UserGuiModule:SetVisible(false)
		end
	end
end)

local KeyboardOpen = false
local GuiVisible = false

function UserGuiModule:SetVisible(visible)
	GuiVisible = visible
	userGuiPanel:SetVisible(GuiVisible)
	if GuiVisible then
		local topbarPanel = Panel3D.Get("Topbar3D")
		local userGuiModuleCFrame = topbarPanel.localCF * PANEL_OFFSET_CFRAME

		userGuiPanel.localCF = userGuiModuleCFrame
		VRHub:FireModuleOpened(UserGuiModule.ModuleName)
	else
		VRHub:FireModuleClosed(UserGuiModule.ModuleName)
	end

	local success, msg = pcall(function()
		-- We need to hide the UserGui when typing on the keyboard so that the textbox doesn't sink events from the keyboard
		local showGui = GuiVisible and not KeyboardOpen
		CoreGui:SetUserGuiRendering(true, showGui and userGuiPanel:GetPart() or nil, Enum.NormalId.Front)
	end)
end

function UserGuiModule:Update()
	self:SetVisible(GuiVisible)
end

local function OnVREnabled(prop)
	if prop == 'VREnabled' then
		local guiPart = nil
		if InputService.VREnabled then
			if userGuiPanel.isVisible then
				guiPart = userGuiPanel:GetPart()
			end
		else
			userGuiPanel:SetVisible(false)
		end
		local success, msg = pcall(function()
			CoreGui:SetUserGuiRendering(InputService.VREnabled, guiPart, Enum.NormalId.Front)
		end)

		VRKeyboard.OpenedEvent:connect(function()
			KeyboardOpen = true
			UserGuiModule:Update()
		end)

		VRKeyboard.ClosedEvent:connect(function()
			KeyboardOpen = false
			UserGuiModule:Update()
		end)

	end
end
InputService.Changed:connect(OnVREnabled)
spawn(function() OnVREnabled("VREnabled") end)

return UserGuiModule
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4E02044C282B490892E4BDD89719CEBD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Recenter</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local InputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
local VRHub = require(RobloxGui.Modules.VR.VRHub)
local Util = require(RobloxGui.Modules.Settings.Utility)

local cancelShortcutName = "CancelRecenterShortcut"

local RecenterModule = {}
RecenterModule.ModuleName = "Recenter"
RecenterModule.KeepVRTopbarOpen = true
RecenterModule.VRIsExclusive = true
RecenterModule.VRClosesNonExclusive = false
VRHub:RegisterModule(RecenterModule)

local countdownPanel = Panel3D.Get("RecenterCountdown")
countdownPanel:SetType(Panel3D.Type.HorizontalFollow)
countdownPanel:ResizeStuds(5, 3, 128)
countdownPanel:SetCanFade(false)

local countdown = Util:Create "TextLabel" {
	Parent = countdownPanel:GetGUI(),

	Position = UDim2.new(0.5, -64, 0.5, -64),
	Size = UDim2.new(0, 128, 0, 128),

	BackgroundTransparency = 0.9,
	BackgroundColor3 = Color3.new(0.2, 0.2, 0.2),

	TextColor3 = Color3.new(1, 1, 1),
	Text = "",
	TextScaled = true,
	Font = Enum.Font.SourceSansBold,

	Visible = true
}
local recenterFrame = Util:Create "ImageLabel" {
	Parent = countdownPanel:GetGUI(),

	Position = UDim2.new(0, 0, 0, 0),
	Size = UDim2.new(1, 0, 1, 0),

	BackgroundTransparency = 1,

	Image = "rbxasset://textures/ui/VR/recenterFrame.png"
}

countdownPanel:SetVisible(false)

local isCountingDown = false
local function cancelCountdown()
	isCountingDown = false
	countdownPanel:SetVisible(false)
end

VRHub.ModuleOpened.Event:connect(function(moduleName)
	if moduleName ~= RecenterModule.ModuleName then
		local module = VRHub:GetModule(moduleName)
		if module.VRIsExclusive then
			cancelCountdown()
		end
	end
end)

function RecenterModule:SetVisible(visible)
	if visible then
		if isCountingDown then
			cancelCountdown()
			VRHub:FireModuleClosed(RecenterModule.ModuleName)
			return
		else
			VRHub:FireModuleOpened(RecenterModule.ModuleName)
		end

		spawn(function()
			isCountingDown = true
			countdownPanel:SetVisible(true)

			ContextActionService:BindCoreAction(cancelShortcutName, function(actionName, inputState, inputObj)
				if inputState == Enum.UserInputState.Begin then
					cancelCountdown()
				end
			end, false, Enum.KeyCode.ButtonB)

			for i = 3, 1, -1 do
				if isCountingDown then
					countdown.Text = tostring(i)
					wait(1)
				end
			end

			if isCountingDown then
				InputService:RecenterUserHeadCFrame() 
			end

			countdownPanel:SetVisible(false)
			isCountingDown = false

			ContextActionService:UnbindCoreAction(cancelShortcutName)

			VRHub:FireModuleClosed(RecenterModule.ModuleName)
		end)
	else
		cancelCountdown()
		VRHub:FireModuleClosed(RecenterModule.ModuleName)
	end
end


return RecenterModule]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE64E5558E42D48768744DB880DF06B7E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VRHub</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Modules/VR/VRHub.lua
--Handles all global VR state that isn't built into a specific module.
--Written by 0xBAADF00D (Kyle) on 6/10/16
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local Util = require(RobloxGui.Modules.Settings.Utility)

local LaserPointer = require(RobloxGui.Modules.VR.LaserPointer)
local useLaserPointerSuccess, useLaserPointerValue = pcall(function() return settings():GetFFlag("UseLaserPointerVR") end)
local useLaserPointerFlag = useLaserPointerSuccess and useLaserPointerValue

local VRHub = {}
local RegisteredModules = {}
local OpenModules = {}

--VR Setup
local vrUpdateRenderstepName = HttpService:GenerateGUID(true)

VRHub.LaserPointer = nil

local start = tick()
local function onRenderSteppedLast()
	local now = tick()
	local dt = now - start
	start = now

	if VRHub.LaserPointer then
		VRHub.LaserPointer:update(dt)
	end
end

local function onVREnabled(property)
	if property ~= "VREnabled" then
		return
	end
	
	if UserInputService.VREnabled then
		if useLaserPointerFlag then
			if not VRHub.LaserPointer then
				VRHub.LaserPointer = LaserPointer.new()
			end

			--Check again in case creating the laser pointer gracefully failed (instance hasn't shipped to some platforms yet for example)
			if VRHub.LaserPointer then
				VRHub.LaserPointer:setEnabled(true)
			end
		end
		RunService:BindToRenderStep(vrUpdateRenderstepName, Enum.RenderPriority.Last.Value, onRenderSteppedLast)
	else
		if VRHub.LaserPointer then
			VRHub.LaserPointer:setEnabled(false)
		end
		RunService:UnbindFromRenderStep(vrUpdateRenderstepName)
	end
end
onVREnabled("VREnabled")
UserInputService.Changed:connect(onVREnabled)

--VRHub API
function VRHub:RegisterModule(module)
	RegisteredModules[module.ModuleName] = module
end

function VRHub:GetModule(moduleName)
	return RegisteredModules[moduleName]
end

function VRHub:IsModuleOpened(moduleName)
	return OpenModules[moduleName] ~= nil
end

function VRHub:GetOpenedModules()
	local result = {}

	for _, openModule in pairs(OpenModules) do
		table.insert(result, openModule)
	end

	return result
end

VRHub.ModuleOpened = Util:Create "BindableEvent" {
	Name = "VRModuleOpened"
}
--Wrapper function to document the arguments to the event
function VRHub:FireModuleOpened(moduleName)
	if not RegisteredModules[moduleName] then
		error("Tried to open module that is not registered: " .. moduleName)
	end

	if OpenModules[moduleName] ~= RegisteredModules[moduleName] then
		OpenModules[moduleName] = RegisteredModules[moduleName]
		VRHub.ModuleOpened:Fire(moduleName)
	end
end

VRHub.ModuleClosed = Util:Create "BindableEvent" {
	Name = "VRModuleClosed"
}
--Wrapper function to document the arguments to the event
function VRHub:FireModuleClosed(moduleName)
	if not RegisteredModules[moduleName] then
		error("Tried to close module that is not registered: " .. moduleName)
	end

	if OpenModules[moduleName] ~= nil then
		OpenModules[moduleName] = nil
		VRHub.ModuleClosed:Fire(moduleName)
	end
end

function VRHub:KeepVRTopbarOpen()
	for moduleName, openModule in pairs(OpenModules) do
		if openModule.KeepVRTopbarOpen then
			return true
		end
	end
	return false
end

return VRHub]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD1CD0BA3A1DC48B0BEED56DE45DF4B62">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NotifierHint3D</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- NotifierHint3D.lua --
-- Written by Kip Turner, copyright ROBLOX 2016 --

local NotifierHint = {}

local CoreGui = game:GetService('CoreGui')
local RunService = game:GetService('RunService')

local RobloxGui = CoreGui:WaitForChild("RobloxGui")

local Util = require(RobloxGui.Modules.Settings.Utility)


local NotificationObject = Util:Create'ImageLabel'
{
	Name = 'NotificationObject';
	-- These numbers are a bit funny to fit the screen of ROBLOX VR
	Position = UDim2.new(0.5, -860, 1, -1 - 300);
	Size = UDim2.new(0, 1700,0, 700 + 300);
	BackgroundTransparency = 1;
	Image = "rbxasset://textures/ui/VR/notifier_glow.png";
	ImageTransparency = 0;
	BorderSizePixel = 0;
}

NotifierHint.DEFAULT_DURATION = 5

local function CreateNotificationEffect()
	local this = {}

	local speed = 2.5
	local MAX_OPACITY = 0.5
	local WAVE_START_SHIFT = math.pi/2

	local renderConn = nil

	function this:Init(duration)
		local start = tick()
		local endTime = start + duration

		if renderConn then
			renderConn:disconnect()
			renderConn = nil
		end
		renderConn = RunService.RenderStepped:connect(function()
			local now = tick()
			if now >= endTime then
				self:Cancel()
				return
			end
			NotificationObject.Parent = RobloxGui
			local tweenPositionOnSineWave = math.sin((tick() - start) * speed + WAVE_START_SHIFT)
			-- Restrict the sine wave to only positive values
			tweenPositionOnSineWave = (tweenPositionOnSineWave + 1) / 2
			-- Keep the transparency in the range
			NotificationObject.ImageTransparency = tweenPositionOnSineWave * (1 - MAX_OPACITY) + MAX_OPACITY
		end)
	end

	function this:Cancel()
		if renderConn then
			renderConn:disconnect()
			renderConn = nil
		end
		NotificationObject.Parent = nil
	end

	return this
end

local NotifierEffect = CreateNotificationEffect()

function NotifierHint:BeginNotification(duration)
	self:CancelNotification()
	NotifierEffect:Init(duration or self.DEFAULT_DURATION)
end

function NotifierHint:CancelNotification()
	NotifierEffect:Cancel()
end




return NotifierHint
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9A85BF38EEE6479F9263A034246B8DC0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Healthbar3D</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[
-- Written by SolarCrane

local HEALTH_BACKGROUND_COLOR = Color3.new(228/255, 236/255, 246/255)
local HEALTH_RED_COLOR = Color3.new(255/255, 28/255, 0/255)
local HEALTH_YELLOW_COLOR = Color3.new(250/255, 235/255, 0)
local HEALTH_GREEN_COLOR = Color3.new(27/255, 252/255, 107/255)

local MIN_COLOR_POSITION = 0.1
local MIN_COLOR = HEALTH_RED_COLOR
local MID_COLOR_POSITION = 0.5
local MAX_COLOR_POSITION = 0.8
local MAX_COLOR = HEALTH_GREEN_COLOR

local NAME_SPACE = 14

local PlayersService = game:GetService('Players')
local CoreGui = game:GetService('CoreGui')
local StarterGui = game:GetService('StarterGui')
local UserInputService = game:GetService('UserInputService')

local RobloxGui = CoreGui:WaitForChild("RobloxGui")



local healthbarContainer = Instance.new('Frame')
healthbarContainer.Name = 'HealthbarContainer'
healthbarContainer.BackgroundTransparency = 1
healthbarContainer.Size = UDim2.new(1,0,1,0)

local healthbarBack = Instance.new('ImageLabel')
healthbarBack.ImageColor3 = HEALTH_BACKGROUND_COLOR
healthbarBack.BackgroundTransparency = 1
healthbarBack.ScaleType = Enum.ScaleType.Slice
healthbarBack.SliceCenter = Rect.new(10, 10, 10, 10)
healthbarBack.Name = 'HealthbarBack'
healthbarBack.Image = 'rbxasset://textures/ui/VR/rectBackgroundWhite.png'
healthbarBack.Size = UDim2.new(1,0,0.3,0)
healthbarBack.Position = UDim2.new(0,0,0.7,0)
healthbarBack.Parent = healthbarContainer

local healthbarFront = Instance.new('ImageLabel')
healthbarFront.ImageColor3 = HEALTH_GREEN_COLOR
healthbarFront.BackgroundTransparency = 1
healthbarFront.ScaleType = Enum.ScaleType.Slice
healthbarFront.SliceCenter = Rect.new(10, 10, 10, 10)
healthbarFront.Size = UDim2.new(1, 0, 1, 0)
healthbarFront.Position = UDim2.new(0, 0, 0, 0)
healthbarFront.Name = 'HealthbarFill'
healthbarFront.Image = 'rbxasset://textures/ui/VR/rectBackgroundWhite.png'
healthbarFront.Parent = healthbarBack

local playerName = Instance.new('TextLabel')
playerName.Name = 'PlayerName'
playerName.BackgroundTransparency = 1
playerName.TextColor3 = Color3.new(1, 1, 1)
playerName.Text = ''
playerName.Font = Enum.Font.SourceSansBold
playerName.FontSize = Enum.FontSize.Size24
playerName.TextXAlignment = Enum.TextXAlignment.Left
playerName.Size = UDim2.new(1, 0, 0, NAME_SPACE)
playerName.Parent = healthbarContainer


local function Color3ToVec3(color)
	return Vector3.new(color.r, color.g, color.b)
end

local function FindChildOfType(object, className)
	for _, child in pairs(object:GetChildren()) do
		if child:IsA(className) then
			return child
		end
	end
end


local HEALTH_COLOR_TO_POSITION = {
	[Color3ToVec3(MIN_COLOR)] = MIN_COLOR_POSITION;
	[Color3ToVec3(HEALTH_YELLOW_COLOR)] = MID_COLOR_POSITION;
	[Color3ToVec3(MAX_COLOR)] = MAX_COLOR_POSITION;
}


local function HealthbarColorTransferFunction(healthPercent)
	if healthPercent <= MIN_COLOR_POSITION then
		return MIN_COLOR
	elseif healthPercent >= MAX_COLOR_POSITION then
		return MAX_COLOR
	end

	-- Shepard's Interpolation
	local numeratorSum = Vector3.new(0,0,0)
	local denominatorSum = 0
	for colorSampleValue, samplePoint in pairs(HEALTH_COLOR_TO_POSITION) do
		local distance = healthPercent - samplePoint
		if distance == 0 then
			-- If we are exactly on an existing sample value then we don't need to interpolate
			return Color3.new(colorSampleValue.x, colorSampleValue.y, colorSampleValue.z)
		else
			local wi = 1 / (distance*distance)
			numeratorSum = numeratorSum + wi * colorSampleValue
			denominatorSum = denominatorSum + wi
		end
	end

	local result = numeratorSum / denominatorSum
	return Color3.new(result.x, result.y, result.z)
end

local function UpdateHealth(humanoid)
	local percentHealth = humanoid.Health / humanoid.MaxHealth
	if percentHealth ~= percentHealth then
		percentHealth = 1
	end
	healthbarFront.ImageColor3 = HealthbarColorTransferFunction(percentHealth)
	healthbarFront.Size = UDim2.new(percentHealth, 0, 1, 0)
end

local HumanoidChangedConn = nil
local HumanoidAncestryChangedConn = nil
local function RegisterHumanoid(humanoid)
	if HumanoidAncestryChangedConn then
		HumanoidAncestryChangedConn:disconnect()
		HumanoidAncestryChangedConn = nil
	end
	if HumanoidChangedConn then
		HumanoidChangedConn:disconnect()
		HumanoidChangedConn = nil
	end

	if humanoid then
		HumanoidAncestryChangedConn = humanoid.AncestryChanged:connect(function(child, parent)
			local player = PlayersService.LocalPlayer
			if child == humanoid and (not player or parent ~= player.Character) then
				RegisterHumanoid(nil)
			end
		end)
		HumanoidChangedConn = humanoid.HealthChanged:connect(function() UpdateHealth(humanoid) end)
		UpdateHealth(humanoid)
	end
end

local function OnCharacterChildAdded(child)
	local player = PlayersService.LocalPlayer
	if player and child.Parent == player.Character and child:IsA('Humanoid') then
		RegisterHumanoid(child)
	end
end

local CharacterChildAddedConn = nil
local function OnCharacterAdded(character)
	local humanoid = FindChildOfType(character, 'Humanoid')
	if humanoid then
		RegisterHumanoid(humanoid)
	end
	
	if CharacterChildAddedConn then
		CharacterChildAddedConn:disconnect()
		CharacterChildAddedConn = nil
	end
	CharacterChildAddedConn = character.ChildAdded:connect(OnCharacterChildAdded)
end

local function OnPlayerAdded(player)
	playerName.Text = player.Name

	player.CharacterAdded:connect(OnCharacterAdded)
	if player.Character then
		OnCharacterAdded(player.Character)
	end
end

if PlayersService.LocalPlayer then
	OnPlayerAdded(PlayersService.LocalPlayer)
else
	spawn(function()
		while not PlayersService.LocalPlayer do
			PlayersService.ChildAdded:wait()
		end
		OnPlayerAdded(PlayersService.LocalPlayer)
	end)
end

local Healthbar = {}

Healthbar.ModuleName = "Healthbar"
Healthbar.KeepVRTopbarOpen = false
Healthbar.VRIsExclusive = false
Healthbar.VRClosesNonExclusive = false

local CoreGuiChangedConn, VRModuleOpenedConn, VRModuleClosedConn;
local function OnVREnabled(prop)
	if prop == "VREnabled" then
		if UserInputService.VREnabled then
			local VRHub = require(RobloxGui.Modules.VR.VRHub)
			local Panel3D = require(RobloxGui.Modules.VR.Panel3D)

			local HealthbarPanel = Panel3D.Get("Healthbar")
			HealthbarPanel:ResizeStuds(1.5, 0.25, 128)
			HealthbarPanel:SetType(Panel3D.Type.Fixed, { CFrame = CFrame.new(0, 0, -5) })
			HealthbarPanel:SetVisible(true)


			function HealthbarPanel:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay)
				local relativePanel = Panel3D.Get("Backpack") or Panel3D.Get("Topbar3D")
				local topbarPanel = Panel3D.Get("Topbar3D")
				if relativePanel and topbarPanel then
					local panelOriginCF = relativePanel.localCF or CFrame.new()
					-- Line up the Healthbar with the backpack icons, which are set 0.11 inwards
					self.localCF = panelOriginCF * CFrame.new(math.max(topbarPanel.width, relativePanel.width)/2 - HealthbarPanel.width/2 - 0.11, 0.25, 0.1)
				end
			end

			function HealthbarPanel:CalculateTransparency()
				local backpackPanel = Panel3D.Get("Backpack")
				local topbarPanel = Panel3D.Get("Topbar3D")
				local transparency = math.min(
					backpackPanel and backpackPanel:IsVisible() and backpackPanel:CalculateTransparency() or 1,
					topbarPanel and topbarPanel:IsVisible() and topbarPanel:CalculateTransparency() or 1)

				healthbarBack.ImageTransparency = transparency
				healthbarFront.ImageTransparency = transparency
				playerName.TextTransparency = transparency

				return transparency
			end

			local OtherPanelOpen = false
			local function UpdateExclusivePanelOpen()
				for _, openModule in pairs(VRHub:GetOpenedModules()) do
					if openModule.VRIsExclusive then
						OtherPanelOpen = true
						return
					end
				end
				OtherPanelOpen = false
			end

			local function CalculateVisibility()
				return StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Health) and
					not OtherPanelOpen
			end


			CoreGuiChangedConn = StarterGui.CoreGuiChangedSignal:connect(function()
				HealthbarPanel:SetVisible(CalculateVisibility())
			end)

			VRModuleOpenedConn = VRHub.ModuleOpened.Event:connect(function(moduleName)
				UpdateExclusivePanelOpen()
				HealthbarPanel:SetVisible(CalculateVisibility())
			end)
			VRModuleClosedConn = VRHub.ModuleClosed.Event:connect(function(moduleName)
				UpdateExclusivePanelOpen()
				HealthbarPanel:SetVisible(CalculateVisibility())
			end)

			-- Initialize OtherPanelOpen variable
			UpdateExclusivePanelOpen()
			HealthbarPanel:SetVisible(CalculateVisibility())
			healthbarContainer.Parent = HealthbarPanel:GetGUI()

			VRHub:RegisterModule(Healthbar)
		else
			if CoreGuiChangedConn then
				CoreGuiChangedConn:disconnect()
				CoreGuiChangedConn = nil
			end
			if VRModuleOpenedConn then
				VRModuleOpenedConn:disconnect()
				VRModuleOpenedConn = nil
			end
			if VRModuleClosedConn then
				VRModuleClosedConn:disconnect()
				VRModuleClosedConn = nil
			end
			healthbarContainer.Parent = nil
		end
	end
end




UserInputService.Changed:connect(OnVREnabled)
if UserInputService.VREnabled then
	OnVREnabled("VREnabled")
end

return Healthbar
]]></ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXC2224D3CB8834BA29E5527876532AD5A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TopbarConstants</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	// FileName: Topbar.lua
	// Written by: SolarCrane
	// Description: Code for lua side Top Menu items in ROBLOX.
]]


--[[ CONSTANTS ]]

local TopbarConstants = {}

TopbarConstants.TOPBAR_THICKNESS = 36
TopbarConstants.USERNAME_CONTAINER_WIDTH = 170
TopbarConstants.COLUMN_WIDTH = 75
TopbarConstants.NAME_LEADERBOARD_SEP_WIDTH = 2

TopbarConstants.ITEM_SPACING = 0
TopbarConstants.VR_ITEM_SPACING = 3

TopbarConstants.FONT_COLOR = Color3.new(1,1,1)
TopbarConstants.TOPBAR_BACKGROUND_COLOR = Color3.new(31/255,31/255,31/255)
TopbarConstants.TOPBAR_OPAQUE_TRANSPARENCY = 0
TopbarConstants.TOPBAR_TRANSLUCENT_TRANSPARENCY = 0.5

TopbarConstants.HEALTH_BACKGROUND_COLOR = Color3.new(228/255, 236/255, 246/255)
TopbarConstants.HEALTH_RED_COLOR = Color3.new(255/255, 28/255, 0/255)
TopbarConstants.HEALTH_YELLOW_COLOR = Color3.new(250/255, 235/255, 0)
TopbarConstants.HEALTH_GREEN_COLOR = Color3.new(27/255, 252/255, 107/255)

TopbarConstants.HEALTH_PERCANTAGE_FOR_OVERLAY = 5 / 100

TopbarConstants.HURT_OVERLAY_IMAGE = "https://www.roblox.com/asset/?id=34854607"

TopbarConstants.DEBOUNCE_TIME = 0.25

TopbarConstants.TOPBAR_LOCAL_CFRAME_3D = CFrame.new(0, -5, 5) * CFrame.Angles(math.rad(25), 0, 0)

return TopbarConstants]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0F1F36FDFB9F4603A058035320A56145">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TenFootInterface</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
		Filename: TenFootInterface.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Setups up some special UI for ROBLOX TV gaming
--]]
-------------- CONSTANTS --------------
local HEALTH_GREEN_COLOR = Color3.new(27/255, 252/255, 107/255)
local DISPLAY_POS_INIT_INSET = 0
local DISPLAY_ITEM_OFFSET = 4
local FORCE_TEN_FOOT_INTERFACE = false

-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

------------------ VARIABLES --------------------
local tenFootInterfaceEnabled = false
do
	local platform = UserInputService:GetPlatform()

	tenFootInterfaceEnabled = (platform == Enum.Platform.XBoxOne or platform == Enum.Platform.WiiU or platform == Enum.Platform.PS4 or 
		platform == Enum.Platform.AndroidTV or platform == Enum.Platform.XBox360 or platform == Enum.Platform.PS3 or
		platform == Enum.Platform.Ouya or platform == Enum.Platform.SteamOS)
end

if FORCE_TEN_FOOT_INTERFACE then
	tenFootInterfaceEnabled = true
end

local Util = {}
do
	function Util.Create(instanceType)
		return function(data)
			local obj = Instance.new(instanceType)
			for k, v in pairs(data) do
				if type(k) == 'number' then
					v.Parent = obj
				else
					obj[k] = v
				end
			end
			return obj
		end
	end
end

local function CreateModule()
	local this = {}
	local nextObjectDisplayYPos = DISPLAY_POS_INIT_INSET
	local displayStack = {}

	-- setup base gui
	local function createContainer()
		if not this.Container then
			this.Container = Util.Create'ImageButton'
			{
				Name = "TopRightContainer";
				Size = UDim2.new(0, 350, 0, 100);
				Position = UDim2.new(1,-360,0,10);
				AutoButtonColor = false;
				Image = "";
				Active = false;
				BackgroundTransparency = 1;
				Parent = RobloxGui;
			};
		end
	end

	function removeFromDisplayStack(displayObject)
		local moveUpFromHere = nil

		for i = 1, #displayStack do
			if displayStack[i] == displayObject then
				moveUpFromHere = i + 1
				break
			end
		end

		local prevObject = displayObject
		for i = moveUpFromHere, #displayStack do
			local objectToMoveUp = displayStack[i]
			objectToMoveUp.Position = UDim2.new(objectToMoveUp.Position.X.Scale, objectToMoveUp.Position.X.Offset,
												objectToMoveUp.Position.Y.Scale, prevObject.AbsolutePosition.Y)
			prevObject = objectToMoveUp
		end
	end

	function addBackToDisplayStack(displayObject)
		for i = 1, #displayStack do
			if displayStack[i] == displayObject then
				moveDownFromHere = i + 1
				break
			end
		end

		local prevObject = displayObject
		for i = moveDownFromHere, #displayStack do
			local objectToMoveDown = displayStack[i]
			local nextDisplayPos = prevObject.AbsolutePosition.Y + prevObject.AbsoluteSize.Y + DISPLAY_ITEM_OFFSET
			objectToMoveDown.Position = UDim2.new(objectToMoveDown.Position.X.Scale, objectToMoveDown.Position.X.Offset,
												objectToMoveDown.Position.Y.Scale, nextDisplayPos)
			prevObject = objectToMoveDown
		end
	end

	function addToDisplayStack(displayObject)
		local lastDisplayed = nil
		if #displayStack > 0 then
			lastDisplayed = displayStack[#displayStack]
		end
		displayStack[#displayStack + 1] = displayObject

		local nextDisplayPos = DISPLAY_POS_INIT_INSET
		if lastDisplayed then
			nextDisplayPos = lastDisplayed.AbsolutePosition.Y + lastDisplayed.AbsoluteSize.Y + DISPLAY_ITEM_OFFSET
		end

		displayObject.Position = UDim2.new(displayObject.Position.X.Scale, displayObject.Position.X.Offset,
											displayObject.Position.Y.Scale, nextDisplayPos)

		createContainer()
		displayObject.Parent = this.Container

		displayObject.Changed:connect(function(prop)
			if prop == "Visible" then
				if not displayObject.Visible then
					removeFromDisplayStack(displayObject)
				else
					addBackToDisplayStack(displayObject)
				end
			end
		end)
	end

	function this:CreateHealthBar()
		this.HealthContainer = Util.Create'Frame'{
			Name = "HealthContainer";
			Size = UDim2.new(1, -86, 0, 50);
			Position = UDim2.new(0, 92, 0, 0);
			BorderSizePixel = 0;
			BackgroundColor3 = Color3.new(0,0,0);
			BackgroundTransparency = 0.5;
		};

		local healthFillHolder = Util.Create'Frame'{
			Name = "HealthFillHolder";
			Size = UDim2.new(1, -10, 1, -10);
			Position = UDim2.new(0, 5, 0, 5);
			BorderSizePixel = 0;
			BackgroundColor3 = Color3.new(1,1,1);
			BackgroundTransparency = 1.0;
			Parent = this.HealthContainer;
		};

		local healthFill = Util.Create'Frame'{
			Name = "HealthFill";
			Size = UDim2.new(1, 0, 1, 0);
			Position = UDim2.new(0, 0, 0, 0);
			BorderSizePixel = 0;
			BackgroundTransparency = 0.0;
			BackgroundColor3 = HEALTH_GREEN_COLOR;
			Parent = healthFillHolder;
		};
		
		local healthText = Util.Create'TextLabel'{
			Name = "HealthText";
			Size = UDim2.new(0, 98, 0, 50);
			Position = UDim2.new(0, -100, 0, 0);
			BackgroundTransparency = 0.5;
			BackgroundColor3 = Color3.new(0,0,0);
			Font = Enum.Font.SourceSans;
			FontSize = Enum.FontSize.Size36;
			Text = "Health";
			TextColor3 = Color3.new(1,1,1);
			BorderSizePixel = 0;
			Parent = this.HealthContainer;
		};

		local username = Util.Create'TextLabel'{
			Visible = false
		}

		addToDisplayStack(this.HealthContainer)
		createContainer()
		
		return this.Container, username, this.HealthContainer, healthFill
	end

	function this:SetupTopStat()
		local topStatEnabled = true
		local displayedStat = nil
		local displayedStatChangedCon = nil
		local displayedStatParentedCon = nil
		local leaderstatsChildAddedCon = nil
		local tenFootInterfaceStat = nil

		local function makeTenFootInterfaceStat()
			if tenFootInterfaceStat then return end

			tenFootInterfaceStat = Util.Create'Frame'{
				Name = "OneStatFrame";
				Size = UDim2.new(1, 0, 0, 36);
				Position = UDim2.new(0, 0, 0, 0);
				BorderSizePixel = 0;
				BackgroundTransparency = 1;
			};
			local statName = Util.Create'TextLabel'{
				Name = "StatName";
				Size = UDim2.new(0.5,0,0,36);
				BackgroundTransparency = 1;
				Font = Enum.Font.SourceSans;
				FontSize = Enum.FontSize.Size36;
				TextStrokeColor3 = Color3.new(104/255, 104/255, 104/255);
				TextStrokeTransparency = 0;
				Text = " StatName:";
				TextColor3 = Color3.new(1,1,1);
				TextXAlignment = Enum.TextXAlignment.Left;
				BorderSizePixel = 0;
				ClipsDescendants = true;
				Parent = tenFootInterfaceStat;
			};
			local statValue = statName:clone()
			statValue.Position = UDim2.new(0.5,0,0,0)
			statValue.Name = "StatValue"
			statValue.Text = "123,643,231"
			statValue.TextXAlignment = Enum.TextXAlignment.Right
			statValue.Parent = tenFootInterfaceStat

			addToDisplayStack(tenFootInterfaceStat)
		end

		local function setDisplayedStat(newStat)
			if displayedStatChangedCon then displayedStatChangedCon:disconnect() displayedStatChangedCon = nil end
			if displayedStatParentedCon then displayedStatParentedCon:disconnect() displayedStatParentedCon = nil end

			displayedStat = newStat

			if displayedStat then
				makeTenFootInterfaceStat()
				updateTenFootStat(displayedStat)
				displayedStatParentedCon = displayedStat.AncestryChanged:connect(function() updateTenFootStat(displayedStat, "Parent") end)
				displayedStatChangedCon = displayedStat.Changed:connect(function(prop) updateTenFootStat(displayedStat, prop) end)
			end
		end

		function updateTenFootStat(statObj, property)
			if property and property == "Parent" then
				tenFootInterfaceStat.StatName.Text = ""
				tenFootInterfaceStat.StatValue.Text = ""
				setDisplayedStat(nil)

				tenFootInterfaceChanged()
			else
				if topStatEnabled then
					tenFootInterfaceStat.StatName.Text = " " .. tostring(statObj.Name) .. ":"
					tenFootInterfaceStat.StatValue.Text = tostring(statObj.Value)
				else
					tenFootInterfaceStat.StatName.Text = ""
					tenFootInterfaceStat.StatValue.Text = ""
				end
			end
		end

		local function isValidStat(obj)
			return obj:IsA('StringValue') or obj:IsA('IntValue') or obj:IsA('BoolValue') or obj:IsA('NumberValue') or
				obj:IsA('DoubleConstrainedValue') or obj:IsA('IntConstrainedValue')
		end

		local function tenFootInterfaceNewStat( newStat )
			if not displayedStat and isValidStat(newStat) then
				setDisplayedStat(newStat)
			end
		end

		function tenFootInterfaceChanged()
			game:WaitForChild("Players")
			while not game.Players.LocalPlayer do
				wait()
			end

			local leaderstats = game.Players.LocalPlayer:FindFirstChild('leaderstats')
			if leaderstats then
				local statChildren = leaderstats:GetChildren()
				for i = 1, #statChildren do
					tenFootInterfaceNewStat(statChildren[i])
				end
				if leaderstatsChildAddedCon then leaderstatsChildAddedCon:disconnect() end
				leaderstatsChildAddedCon = leaderstats.ChildAdded:connect(function(newStat)
					tenFootInterfaceNewStat(newStat)
				end)
			end
		end

		game:WaitForChild("Players")
		while not game.Players.LocalPlayer do
			wait()
		end

		local leaderstats = game.Players.LocalPlayer:FindFirstChild('leaderstats')
		if leaderstats then
			tenFootInterfaceChanged()
		else
			game.Players.LocalPlayer.ChildAdded:connect(tenFootInterfaceChanged)
		end
		
		--Top Stat Public API
		
		local topStatApiTable = {}
		
		function topStatApiTable:SetTopStatEnabled(value)
			topStatEnabled = value
			if displayedStat then
				updateTenFootStat(displayedStat, "")
			end
		end
		
		return topStatApiTable
	end

	return this
end


-- Public API

local moduleApiTable = {}

	local TenFootInterfaceModule = CreateModule()

	function moduleApiTable:IsEnabled()
		return tenFootInterfaceEnabled
	end

	function moduleApiTable:CreateHealthBar()
		return TenFootInterfaceModule:CreateHealthBar()
	end

	function moduleApiTable:SetupTopStat()
		return TenFootInterfaceModule:SetupTopStat()
	end

return moduleApiTable]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCEB371EEBF3D4DD8884855854B38DB8B">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StyleWidgets</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
  Filename: StyleWidgets.lua
  Written by: dbanks
  Version 1.0
  Description: Widgets with common style elements that can be shared across
      different GUIS.
--]]
----------------- SERVICES ------------------------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)

----------- CLASS DECLARATION --------------
--[[ Classes ]]--
local StyleWidgets = {}

----------- CONSTANTS --------------
StyleWidgets.TabSelectionHeight = 6

function StyleWidgets.MakeTabSelectionWidget(parent)
  local tabSelection = utility:Create'ImageLabel'
  {
    Name = "TabSelection",
    Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuSelection.png",
    ScaleType = Enum.ScaleType.Slice,
    SliceCenter = Rect.new(3,1,4,5),
    Visible = false,
    BackgroundTransparency = 1,
    Size = UDim2.new(1,0,0,StyleWidgets.TabSelectionHeight ),
    Position = UDim2.new(0,0,1,-StyleWidgets.TabSelectionHeight ),
    Parent = parent
  };

  return tabSelection
end


return StyleWidgets]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX7609AAA6C5E0490FBF30F82F3C6D8534">
				<Properties>
					<string name="Name">Stats</string>
				</Properties>
				<Item class="ModuleScript" referent="RBXA263B5770CEC405FB309AE6A32F75B88">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsViewer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: StatsButtonViewer.lua
  Written by: dbanks
  Description: Widget that displays one or more stats in closeup view:
      text and graphics.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)
local StatsTextPanelClass = require(CoreGuiService.RobloxGui.Modules.Stats.StatsTextPanel)
local StatsAnnotatedGraphClass = require(CoreGuiService.RobloxGui.Modules.Stats.StatsAnnotatedGraph)

--[[ Globals ]]--
local TextPanelXFraction = 0.4
local GraphXFraction = 1 - TextPanelXFraction

local TextPanelPosition = UDim2.new(0, 0, 0, 0)
local TextPanelSize = UDim2.new(TextPanelXFraction, 0, 1, 0)
local GraphPosition = UDim2.new(TextPanelXFraction, 0, 0, 0)
local GraphSize = UDim2.new(GraphXFraction, 0, 1, 0)

--[[ Classes ]]--
local StatsViewerClass = {}
StatsViewerClass.__index = StatsViewerClass


function StatsViewerClass.new() 
  local self = {}
  setmetatable(self, StatsViewerClass)
  
  self._frameImageLabel = Instance.new("ImageLabel")
  self._frameImageLabel.Name = "PS_Viewer"
	self._frameImageLabel.Image = 'rbxasset://textures/ui/PerformanceStats/BackgroundRounded.png'
  self._frameImageLabel.ScaleType = Enum.ScaleType.Slice
  self._frameImageLabel.SliceCenter = Rect.new(10, 10, 22, 22)
  self._frameImageLabel.BackgroundTransparency = 1
  self._frameImageLabel.ImageColor3 = StatsUtils.NormalColor
  self._frameImageLabel.ImageTransparency = StatsUtils.Transparency 
  
  self._textPanel = nil
  self._statType = nil
  self._graph = nil

  return self
end

function StatsViewerClass:OnVisibilityChanged()
  if self._graph then 
    self._graph:OnVisibilityChanged()
  end
  if self._textPanel then 
    self._textPanel:OnVisibilityChanged()
  end
end

function StatsViewerClass:GetIsVisible()
  return self._frameImageLabel.Visible
end

function StatsViewerClass:GetStatType()
  return self._statType
end

function StatsViewerClass:SetSizeAndPosition(size, position)
  self._frameImageLabel.Size = size;
  self._frameImageLabel.Position = position;
end

function StatsViewerClass:SetParent(parent)
  self._frameImageLabel.Parent = parent
end
  
function StatsViewerClass:SetVisible(visible)
  self._frameImageLabel.Visible = visible;
end

function StatsViewerClass:SetStatType(statType) 
  self._statType = statType
  self._frameImageLabel:ClearAllChildren()
  self._textPanel = nil  
  
  self._textPanel = StatsTextPanelClass.new(statType, true)
  self._textPanel:PlaceInParent(self._frameImageLabel,
    TextPanelSize, 
    TextPanelPosition)
  
  self._graph = StatsAnnotatedGraphClass.new(statType, true)
  self._graph:PlaceInParent(self._frameImageLabel, 
    GraphSize, 
    GraphPosition)
  
  self._textPanel:SetZIndex(StatsUtils.TextZIndex)
  self._graph:SetZIndex(StatsUtils.GraphZIndex)
  
  self:_applyStatsAggregator();
end

function StatsViewerClass:_applyStatsAggregator()
  if (self._aggregator == nil) then 
    return
  end
  
  if (self._textPanel) then 
    self._textPanel:SetStatsAggregator(self._aggregator)
  end
  if (self._graph) then 
      self._graph:SetStatsAggregator(self._aggregator)
  end
end
  

function StatsViewerClass:SetStatsAggregator(aggregator) 
  self._aggregator = aggregator
  self:_applyStatsAggregator();
 end

return StatsViewerClass]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX427D7439B342469DA242F512C64F9E71">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsUtils</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: StatsUtils.lua
  Written by: dbanks
  Description: Common work in the performance stats world.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')
local PlayersService = game:GetService("Players")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings


--[[ Modules ]]--
local TopbarConstants = require(CoreGuiService.RobloxGui.Modules.TopbarConstants)
local StyleWidgets = require(CoreGuiService.RobloxGui.Modules.StyleWidgets)

--[[ Classes ]]--
local StatsUtils = {}

-- Colors
StatsUtils.SelectedBackgroundColor = Color3.new(0.4, 0.4, 0.4)
StatsUtils.FontColor = Color3.new(1, 1, 1)
StatsUtils.GraphBarGreenColor = Color3.new(126/255.0, 211/255.0, 33/255.0)
StatsUtils.GraphBarYellowColor = Color3.new(209/255.0, 211/255.0, 33/255.0)
StatsUtils.GraphBarRedColor = Color3.new(211/255.0, 88/255.0, 33/255.0)
StatsUtils.GraphAverageLineColor = Color3.new(208/255.0, 1/255.0, 27/255.0)
StatsUtils.GraphAverageLineBorderColor = Color3.new(1, 1, 1)
StatsUtils.NormalColor = TopbarConstants.TOPBAR_BACKGROUND_COLOR
StatsUtils.Transparency = TopbarConstants.TOPBAR_TRANSLUCENT_TRANSPARENCY;

-- Font Sizes
StatsUtils.MiniPanelTitleFontSize = Enum.FontSize.Size12
StatsUtils.MiniPanelValueFontSize = Enum.FontSize.Size10
StatsUtils.PanelTitleFontSize = Enum.FontSize.Size24
StatsUtils.PanelValueFontSize = Enum.FontSize.Size14
StatsUtils.PanelGraphFontSize = Enum.FontSize.Size10

-- Layout
-- Layout: Buttons
StatsUtils.ButtonHeight = 36 + StyleWidgets.TabSelectionHeight

-- Layout: Viewer
StatsUtils.ViewerTopMargin = 10
StatsUtils.ViewerHeight = 144
StatsUtils.ViewerWidth = 306

StatsUtils.TextZIndex =  5
StatsUtils.GraphZIndex = 2

-- Layout: Graph
StatsUtils.GraphTargetLineInnerThickness = 2
StatsUtils.GraphAverageLineInnerThickness = 2
StatsUtils.GraphAverageLineBorderThickness = 1
StatsUtils.GraphAverageLineTotalThickness = (StatsUtils.GraphAverageLineInnerThickness + 
  2 * StatsUtils.GraphAverageLineBorderThickness)
      
-- Layout: Main Text Panel
StatsUtils.TextPanelTitleHeightY = 52
StatsUtils.TextPanelLegendItemHeightY = 20

StatsUtils.TextPanelLeftMarginPix = 10
StatsUtils.TextPanelTopMarginPix = 10

-- Layout: Graph Legend
StatsUtils.DecorationSize = 12
StatsUtils.OvalKeySize = 8
StatsUtils.TargetKeyWidth = 11
StatsUtils.TargetKeyHeight = 2
StatsUtils.DecorationMargin = 6


-- Enums
StatsUtils.StatType_Memory =            "st_Memory"
StatsUtils.StatType_CPU =               "st_CPU"
StatsUtils.StatType_GPU =               "st_GPU"
StatsUtils.StatType_NetworkSent =       "st_NetworkSent"
StatsUtils.StatType_NetworkReceived =   "st_NetworkReceived"
StatsUtils.StatType_Physics =           "st_Physics"
      
StatsUtils.AllStatTypes = {
  StatsUtils.StatType_Memory,
  StatsUtils.StatType_CPU,
  StatsUtils.StatType_GPU,
  StatsUtils.StatType_NetworkSent,
  StatsUtils.StatType_NetworkReceived,
  StatsUtils.StatType_Physics,
}

StatsUtils.StatNames = {
  [StatsUtils.StatType_Memory] = "Memory",
  [StatsUtils.StatType_CPU] = "CPU",
  [StatsUtils.StatType_GPU] = "GPU",
  [StatsUtils.StatType_NetworkSent] = "NetworkSent",
  [StatsUtils.StatType_NetworkReceived] = "NetworkReceived",
  [StatsUtils.StatType_Physics] = "Physics",
}

StatsUtils.StatMaxNames = {
  [StatsUtils.StatType_Memory] = "MaxMemory",
  [StatsUtils.StatType_CPU] = "MaxCPU",
  [StatsUtils.StatType_GPU] = "MaxGPU",
  [StatsUtils.StatType_NetworkSent] = "MaxNetworkSent",
  [StatsUtils.StatType_NetworkReceived] = "MaxNetworkReceived",
  [StatsUtils.StatType_Physics] = "MaxPhysics",
}

StatsUtils.NumButtonTypes = table.getn(StatsUtils.AllStatTypes)

StatsUtils.TypeToName = {
  [StatsUtils.StatType_Memory] = "Memory",
  [StatsUtils.StatType_CPU] = "CPU",
  [StatsUtils.StatType_GPU] = "GPU",
  [StatsUtils.StatType_NetworkSent] = "Sent\n(Network)",
  [StatsUtils.StatType_NetworkReceived] = "Received\n(Network)",
  [StatsUtils.StatType_Physics] = "Physics",
}

StatsUtils.TypeToShortName = {
  [StatsUtils.StatType_Memory] = "Mem",
  [StatsUtils.StatType_CPU] = "CPU",
  [StatsUtils.StatType_GPU] = "GPU",
  [StatsUtils.StatType_NetworkSent] = "Sent",
  [StatsUtils.StatType_NetworkReceived] = "Recv",
  [StatsUtils.StatType_Physics] = "Phys",
}

function StatsUtils.StyleFrame(frame)
  frame.BackgroundColor3 = StatsUtils.NormalColor
  frame.BackgroundTransparency = StatsUtils.Transparency
end

function StatsUtils.StyleButton(button)
  button.BackgroundColor3 = StatsUtils.NormalColor
  button.BackgroundTransparency = StatsUtils.Transparency
end

function StatsUtils.StyleTextWidget(textLabel)
  textLabel.BackgroundTransparency = 1.0
  textLabel.TextColor3 = StatsUtils.FontColor
  textLabel.Font = Enum.Font.SourceSansBold
end

function StatsUtils.StyleButtonSelected(frame, isSelected)
  StatsUtils.StyleButton(frame)
  if (isSelected) then 
    frame.BackgroundColor3 = StatsUtils.SelectedBackgroundColor
  end
end

function StatsUtils.FormatTypedValue(value, statType)   
  if statType == StatsUtils.StatType_Memory then 
    return string.format("%.2f MB", value)
  elseif statType == StatsUtils.StatType_CPU then
    return string.format("%.2f ms", value)
  elseif statType == StatsUtils.StatType_GPU then
    return string.format("%.2f ms", value)
  elseif statType == StatsUtils.StatType_NetworkSent then
    return string.format("%.2f KB/s", value)
  elseif statType == StatsUtils.StatType_NetworkReceived then
    return string.format("%.2f KB/s", value)
  elseif statType == StatsUtils.StatType_Physics then
    return string.format("%.2f ms", value)
  end
end

function StatsUtils.StyleAverageLine(frame)
  frame.BackgroundColor3 = StatsUtils.GraphAverageLineColor
  frame.BorderSizePixel = StatsUtils.GraphAverageLineBorderThickness
  frame.BorderColor3 = StatsUtils.GraphAverageLineBorderColor
end
  
function StatsUtils.GetColorForValue(value, target) 
  if value < 0.666 * target then 
    return StatsUtils.GraphBarGreenColor
  elseif value < 1.333 * target then 
    return StatsUtils.GraphBarYellowColor
  else
    return StatsUtils.GraphBarRedColor
  end
end
  
function StatsUtils.PerformanceStatsShouldBeVisible()
  local localPlayer = PlayersService.LocalPlayer
  return (GameSettings.PerformanceStatsVisible and localPlayer ~= nil)
end
  
return StatsUtils]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6E66E2E2F32C4AC18ECFF14E49884525">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsTextPanel</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: StatsTextPanel.lua
  Written by: dbanks
  Description: Panel that shows a "Legend" for a graph, including:
      - name of stat being displayed.
      - current value of stat.
      - target (suggested max) value of stat.
      - average value of stat over the whole graph. 
      particular stat.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)
local StatsAggregatorClass = require(CoreGuiService.RobloxGui.Modules.Stats.StatsAggregator)
local DecoratedValueLabelClass = require(CoreGuiService.RobloxGui.Modules.Stats.DecoratedValueLabel)

--[[ Globals ]]--
-- Positions
local top = StatsUtils.TextPanelTopMarginPix
local TitlePosition = UDim2.new(0, 
  StatsUtils.TextPanelLeftMarginPix, 
  0, 
  top)
top = top + StatsUtils.TextPanelTitleHeightY
local CurrentValuePosition = UDim2.new(0,
  StatsUtils.TextPanelLeftMarginPix, 
  0, 
  top)
top = top + StatsUtils.TextPanelLegendItemHeightY
local TargetValuePosition = UDim2.new(0,
  StatsUtils.TextPanelLeftMarginPix, 
  0, 
  top)
top = top + StatsUtils.TextPanelLegendItemHeightY
local AverageValuePosition = UDim2.new(0,
  StatsUtils.TextPanelLeftMarginPix, 
  0, 
  top)

-- Sizes
local TitleSize = UDim2.new(1, 
  -StatsUtils.TextPanelLeftMarginPix * 2, 
  0, 
  StatsUtils.TextPanelTitleHeightY)
local LegendItemValueSize = UDim2.new(1, 
  -StatsUtils.TextPanelLeftMarginPix * 2,
  0,
  StatsUtils.TextPanelLegendItemHeightY)

--[[ Classes ]]--
local StatsTextPanelClass = {}
StatsTextPanelClass.__index = StatsTextPanelClass

function StatsTextPanelClass.new(statType) 
  local self = {}
  setmetatable(self, StatsTextPanelClass)

  self._statType = statType
  
  self._frame = Instance.new("Frame")
  self._frame.BackgroundTransparency = 1.0
  self._frame.ZIndex = StatsUtils.TextPanelZIndex
  
  self._titleLabel = Instance.new("TextLabel")

  StatsUtils.StyleTextWidget(self._titleLabel)
  
  self._titleLabel.FontSize = StatsUtils.PanelTitleFontSize
  self._titleLabel.Text = self:_getTitle()
  
  self._titleLabel.Parent = self._frame
  self._titleLabel.Size = TitleSize
  self._titleLabel.Position = TitlePosition
  self._titleLabel.TextXAlignment = Enum.TextXAlignment.Left
  self._titleLabel.TextYAlignment = Enum.TextYAlignment.Top
  
  -- Icon + text widgets to show the current value of this stat.
  self:_addCurrentValueWidget()
  -- Icon + text widgets to show the suggested max value of this stat.
  self:_addTargetValueWidget()
  -- Icon + text widgets to show the average value of this stat.
  self:_addAverageValueWidget()
  
  return self
end

function StatsTextPanelClass:_getTarget()
  -- Get the current target value for the graphed stat.
  if self._performanceStats == nil then
    return 0
  end  
  
  local maxItemStats = self._performanceStats:FindFirstChild(self._statMaxName)
  if maxItemStats == nil then
    return 0
  end
  
  return maxItemStats:GetValue()
end


function StatsTextPanelClass:_addCurrentValueWidget()
  self._currentValueWidget = DecoratedValueLabelClass.new(self._statType, 
    "Current")
    
  self._currentValueWidget:PlaceInParent(self._frame, 
    LegendItemValueSize, 
    CurrentValuePosition)

  local decorationFrame = self._currentValueWidget:GetDecorationFrame()    
  local decoration = Instance.new("ImageLabel")
  decoration.Position = UDim2.new(0.5, -StatsUtils.OvalKeySize/2, 
    0.5, -StatsUtils.OvalKeySize/2)
  decoration.Size = UDim2.new(0, StatsUtils.OvalKeySize,
    0, StatsUtils.OvalKeySize)  
  
  decoration.Parent = decorationFrame
  decoration.BackgroundTransparency = 1
	decoration.Image = 'rbxasset://textures/ui/PerformanceStats/OvalKey.png'
  decoration.BorderSizePixel = 0
  self._currentValueDecoration = decoration
end

function StatsTextPanelClass:_addTargetValueWidget()
  self._targetValueWidget = DecoratedValueLabelClass.new(self._statType, 
    "Target")
    
  self._targetValueWidget:PlaceInParent(self._frame, 
    LegendItemValueSize, 
    TargetValuePosition)

  local decorationFrame = self._targetValueWidget:GetDecorationFrame()    
  local decoration = Instance.new("ImageLabel")
  decoration.Position = UDim2.new(0.5, -StatsUtils.TargetKeyWidth/2, 
    0.5, -StatsUtils.TargetKeyHeight/2)
  decoration.Size = UDim2.new(0, StatsUtils.TargetKeyWidth,
    0, StatsUtils.TargetKeyHeight)  
  
  decoration.Parent = decorationFrame
  decoration.BackgroundTransparency = 1
	decoration.Image = 'rbxasset://textures/ui/PerformanceStats/TargetKey.png'
end

function StatsTextPanelClass:_addAverageValueWidget()
  self._averageValueWidget = DecoratedValueLabelClass.new(self._statType, 
    "Average")
    
  self._averageValueWidget:PlaceInParent(self._frame, 
    LegendItemValueSize, 
    AverageValuePosition)

  local decorationFrame = self._averageValueWidget:GetDecorationFrame()
  
  local decoration = Instance.new("Frame")
  decoration.Position = UDim2.new(0, 0, 0.5, -StatsUtils.GraphAverageLineTotalThickness/2)
  decoration.Size = UDim2.new(1, 0, 0, StatsUtils.GraphAverageLineInnerThickness)  
  decoration.Parent = decorationFrame
  
  StatsUtils.StyleAverageLine(decoration)
end

function StatsTextPanelClass:_getTitle()
  return StatsUtils.TypeToName[self._statType]
end

function StatsTextPanelClass:PlaceInParent(parent, size, position) 
  self._frame.Position = position
  self._frame.Size = size
  self._frame.Parent = parent  
end


function StatsTextPanelClass:SetStatsAggregator(aggregator)
  if (self._aggregator) then
    self._aggregator:RemoveListener(self._listenerId)
    self._listenerId = nil
    self._aggregator = nil
  end
  
  self._aggregator = aggregator
    
  self:OnVisibilityChanged()
end


function StatsTextPanelClass:_stopListening()
  if (self._aggregator == nil) then
    return
  end
  
  if (self._listenerId == nil) then 
    return
  end
  
  self._aggregator:RemoveListener(self._listenerId)
  self._listenerId = nil  
end

function StatsTextPanelClass:_startListening()
  if (self._aggregator == nil) then
    return
  end
  
  if (self._listenerId ~= nil) then 
    return
  end
  
  self._listenerId = self._aggregator:AddListener(function()
      self:_updateFromAggregator()
  end)  
end

function StatsTextPanelClass:OnVisibilityChanged()
  if StatsUtils.PerformanceStatsShouldBeVisible() then
    self:_startListening()
    self:_updateFromAggregator()
  else
    self:_stopListening()
  end
end

function StatsTextPanelClass:_updateFromAggregator()
  local value = 0
  local average = 0
  local target = 0
    
  if self._aggregator ~= nil then 
    value = self._aggregator:GetLatestValue()
    average = self._aggregator:GetAverage()
    target = self._aggregator:GetTarget()
  end
  
  self._currentValueWidget:SetValue(value)
  self._targetValueWidget:SetValue(target)
  self._averageValueWidget:SetValue(average)
  
  self._currentValueDecoration.ImageColor3 = StatsUtils.GetColorForValue(value, target) 
end

function StatsTextPanelClass:SetZIndex(zIndex)
  -- Pass through to all children.
  self._frame.ZIndex = zIndex
  self._titleLabel.ZIndex = zIndex
  self._currentValueWidget:SetZIndex(zIndex)
  self._averageValueWidget:SetZIndex(zIndex)
end

return StatsTextPanelClass]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8E3DEC138CCD4D1C958EC722A3B3109E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsMiniTextPanel</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: StatsMiniTextPanel.lua
  Written by: dbanks
  Description: Panel that shows title and current value for a given stat.
--]]

--[[ Globals ]]--
local TitleHeightYFraction = 0.4
local ValueHeightYFraction = 0.3
local TitleTopYFraction = (1 - TitleHeightYFraction - 
  ValueHeightYFraction)/2
local LeftMarginPix = 10

local TitlePosition = UDim2.new(0, 
  LeftMarginPix, 
  TitleTopYFraction, 
  0)
local TitleSize = UDim2.new(1, 
  -LeftMarginPix * 2, 
  TitleHeightYFraction, 
  0)
local ValuePosition = UDim2.new(0,
  LeftMarginPix, 
  TitleTopYFraction + TitleHeightYFraction, 
  0)
local ValueSize = UDim2.new(1, 
  -LeftMarginPix * 2,
  ValueHeightYFraction, 
  0)

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)
local StatsAggregatorClass = require(CoreGuiService.RobloxGui.Modules.Stats.StatsAggregator)

--[[ Classes ]]--
local StatsMiniTextPanelClass = {}
StatsMiniTextPanelClass.__index = StatsMiniTextPanelClass

function StatsMiniTextPanelClass.new(statType) 
  local self = {}
  setmetatable(self, StatsMiniTextPanelClass)

  self._statType = statType
  
  self._frame = Instance.new("Frame")
  self._frame.Name = "StatsMiniTextPanelClass"
  
  self._frame.BackgroundTransparency = 1.0
  self._frame.ZIndex = StatsUtils.TextPanelZIndex
  
  self._titleLabel = Instance.new("TextLabel")
  self._titleLabel.Name = "TitleLabel"
  self._valueLabel = Instance.new("TextLabel")
  self._valueLabel.Name = "ValueLabel"

  StatsUtils.StyleTextWidget(self._titleLabel)
  StatsUtils.StyleTextWidget(self._valueLabel)
  
  self._titleLabel.FontSize = StatsUtils.MiniPanelTitleFontSize
  self._titleLabel.Text = self:_getTitle()
  self._titleLabel.Parent = self._frame
  self._titleLabel.Size = TitleSize
  self._titleLabel.Position = TitlePosition
  self._titleLabel.TextXAlignment = Enum.TextXAlignment.Left
  
  self._valueLabel.FontSize = StatsUtils.MiniPanelValueFontSize
  self._valueLabel.Text = "0"
  self._valueLabel.Parent = self._frame
  self._valueLabel.Size = ValueSize
  self._valueLabel.Position = ValuePosition
  self._valueLabel.TextXAlignment = Enum.TextXAlignment.Left
  
  return self
end

function StatsMiniTextPanelClass:SetZIndex(zIndex)
  self._frame.ZIndex = zIndex
  self._titleLabel.ZIndex = zIndex
  self.ZIndex = zIndex
end

function StatsMiniTextPanelClass:_getTitle()
  return StatsUtils.TypeToShortName[self._statType]
end

function StatsMiniTextPanelClass:PlaceInParent(parent, size, position) 
  self._frame.Position = position
  self._frame.Size = size
  self._frame.Parent = parent  
end

function StatsMiniTextPanelClass:SetStatsAggregator(aggregator)
  if (self._aggregator) then
    self._aggregator:RemoveListener(self._listenerId)
    self._listenerId = nil
    self._aggregator = nil
  end
  
  self._aggregator = aggregator
    
  self:OnVisibilityChanged()
end


function StatsMiniTextPanelClass:_stopListening()
  if (self._aggregator == nil) then
    return
  end
  
  if (self._listenerId == nil) then 
    return
  end
  
  self._aggregator:RemoveListener(self._listenerId)
  self._listenerId = nil  
end

function StatsMiniTextPanelClass:_startListening()
  if (self._aggregator == nil) then
    return
  end
  
  if (self._listenerId ~= nil) then 
    return
  end
  
  self._listenerId = self._aggregator:AddListener(function()
      self:_updateFromAggregator()
  end)  
end

function StatsMiniTextPanelClass:OnVisibilityChanged()
  if StatsUtils.PerformanceStatsShouldBeVisible() then
    self:_startListening()
    self:_updateFromAggregator()
  else
    self:_stopListening()
  end
end

function StatsMiniTextPanelClass:_updateFromAggregator()
  local value
  
  if self._aggregator ~= nil then 
    value = self._aggregator:GetLatestValue()
  else
    value = 0
  end
  
  self._valueLabel.Text = StatsUtils.FormatTypedValue(value, self._statType)
end



return StatsMiniTextPanelClass]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2D477477CC604AAE85D4791DC56F3353">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsButton</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: StatsButton.lua
  Written by: dbanks
  Description: Button that displays latest deets of one or two 
    particular stats.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Modules ]]--
local StyleWidgets = require(CoreGuiService.RobloxGui.Modules.StyleWidgets)
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)
local StatsMiniTextPanelClass = require(CoreGuiService.RobloxGui.Modules.Stats.StatsMiniTextPanel)
local StatsAnnotatedGraphClass = require(CoreGuiService.RobloxGui.Modules.Stats.StatsAnnotatedGraph)

--[[ Globals ]]--
local TextPanelXFraction = 0.5
local GraphXFraction = 1 - TextPanelXFraction

local TextPanelPosition = UDim2.new(0, 0, 0, 0)
local TextPanelSize = UDim2.new(TextPanelXFraction, 0, 1, -StyleWidgets.TabSelectionHeight)
local GraphPosition = UDim2.new(TextPanelXFraction, 0, 0, 0)
local GraphSize = UDim2.new(GraphXFraction, 0, 1, -StyleWidgets.TabSelectionHeight)

--[[ Classes ]]--
local StatsButtonClass = {}
StatsButtonClass.__index = StatsButtonClass

function StatsButtonClass.new(statType) 
  local self = {}
  setmetatable(self, StatsButtonClass)

  self._statType = statType
  self._button = Instance.new("TextButton")
  self._button.Name = "PS_Button"
  self._button.Text = ""
  
  StatsUtils.StyleButton(self._button)

  self._textPanel = StatsMiniTextPanelClass.new(statType)
  self._textPanel:PlaceInParent(self._button,
    TextPanelSize, 
    TextPanelPosition)
        
  self._graph = StatsAnnotatedGraphClass.new(statType, false)
  self._graph:PlaceInParent(self._button, 
    GraphSize, 
    GraphPosition)
  
  self._textPanel:SetZIndex(StatsUtils.TextZIndex)
  self._graph:SetZIndex(StatsUtils.GraphZIndex)

  self._tabSelection = StyleWidgets.MakeTabSelectionWidget(self._button)

  self._isSelected = false
  
  self:_updateTabSelectionState();
  
  return self
end

function StatsButtonClass:OnVisibilityChanged()
  if self._graph then 
    self._graph:OnVisibilityChanged()
  end
  
  if self._textPanel then 
    self._textPanel:OnVisibilityChanged()
  end
end

function StatsButtonClass:SetToggleCallbackFunction(callbackFunction) 
    self._button.MouseButton1Click:connect(function() 
          callbackFunction(self._statType)
        end)
end

function StatsButtonClass:SetSizeAndPosition(size, position)
  self._button.Size = size;
  self._button.Position = position;
end

function StatsButtonClass:SetIsSelected(isSelected)
  self._isSelected = isSelected
  self:_updateTabSelectionState();
end

function StatsButtonClass:_updateTabSelectionState()
  self._tabSelection.Visible = self._isSelected
end

function StatsButtonClass:SetParent(parent)
  self._button.Parent = parent
end
  
function StatsButtonClass:SetStatsAggregator(aggregator) 
  self._textPanel:SetStatsAggregator(aggregator)
  self._graph:SetStatsAggregator(aggregator)
end
  
return StatsButtonClass]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF1F880B3019D4846B0A8E050AE1098AA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsAggregator</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: StatsAggregator.lua
  Written by: dbanks
  Description: Gather and store stats on regular heartbeat.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)

--[[ Classes ]]--
local StatsAggregatorClass = {}
StatsAggregatorClass.__index = StatsAggregatorClass

function StatsAggregatorClass.new(statType, numSamples, pauseBetweenSamples) 
  local self = {}
  setmetatable(self, StatsAggregatorClass)
  
  self._statType = statType
  self._numSamples = numSamples
  self._pauseBetweenSamples = pauseBetweenSamples
  
  self._statName = StatsUtils.StatNames[self._statType]
  self._statMaxName = StatsUtils.StatMaxNames[self._statType]
  
  -- init our circular buffer.
  self._samples = {}
  for i = 0, numSamples-1, 1 do 
    self._samples[i] = 0
  end
  self._oldestIndex = 0
  
  self._listeners = {}
  
  -- FIXME(dbanks)
  -- Just want to be real clear this is a key, not an array index.
  self._nextListenerId = 1001
  
  return self
end

function StatsAggregatorClass:AddListener(callbackFunction)
  local id = self._nextListenerId
  self._nextListenerId = self._nextListenerId+1
  self._listeners[id] = callbackFunction
  return id
end

function StatsAggregatorClass:RemoveListener(listenerId)
  self._listeners[listenerId] = nil
end

function StatsAggregatorClass:_notifyAllListeners()
  for listenerId, listenerCallback in pairs(self._listeners) do
    listenerCallback()
  end
end

function StatsAggregatorClass:StartListening()
  -- On a regular heartbeat, wake up and read the latest
  -- value into circular buffer.
  -- Don't bother if we're already listening.
  if (self._listening == true) then 
    return
  end
  
  spawn(function()
      self._listening = true
      while(self._listening) do          
          local statValue = self:_getStatValue()
          self:_storeStatValue(statValue)
          self:_notifyAllListeners()
          wait(self._pauseBetweenSamples)
      end
    end)
end

function StatsAggregatorClass:StopListening()
  self._listening = false
end

function StatsAggregatorClass:GetValues()
  -- Get the past N values, from oldest to newest.
  local retval = {}
  for i = 0, self._numSamples-1, 1 do
    actualIndex = (self._oldestIndex + i) % self._numSamples
    retval[i+1] = self._samples[actualIndex]
  end
  return retval
end

function StatsAggregatorClass:GetAverage()
  -- Get average of past N values.
  local retval = 0.0
  for i = 0, self._numSamples-1, 1 do
    retval = retval + self._samples[i]
  end
  return retval / self._numSamples  
end

function StatsAggregatorClass:GetLatestValue()
  -- Get latest value.
  local index = (self._oldestIndex + self._numSamples -1) % self._numSamples
  return self._samples[index]
end

function StatsAggregatorClass:_storeStatValue(value)
  -- Store this as the latest value in our circular buffer.
  self._samples[self._oldestIndex] = value
  self._oldestIndex = (self._oldestIndex + 1) % self._numSamples
end

function StatsAggregatorClass:_getStatValue()
  -- Look up and return the statistic we care about.
  local statsService = game:GetService("Stats")
  if statsService == nil then
    return 0
  end
  
  local performanceStats = statsService:FindFirstChild("PerformanceStats")
  if performanceStats == nil then
    return 0
  end  
  
  local itemStats = performanceStats:FindFirstChild(self._statName)
  if itemStats == nil then
    return 0
  end
  
  return itemStats:GetValue()
end

function StatsAggregatorClass:GetTarget()
  -- Look up and return the statistic we care about.
  local statsService = game:GetService("Stats")
  if statsService == nil then
    return 0
  end
  
  local performanceStats = statsService:FindFirstChild("PerformanceStats")
  if performanceStats == nil then
    return 0
  end  
  
  local itemStats = performanceStats:FindFirstChild(self._statMaxName)
  if itemStats == nil then
    return 0
  end
  
  return itemStats:GetValue()
end

return StatsAggregatorClass
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX96BF6ACB80EE4FB290B9F9DFE9298C5A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BarGraph</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: BarGraph.lua
  Written by: dbanks
  Description: A simple bar graph.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Globals ]]--
local BarZIndex = 1
local LineZIndex = 2


--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)

--[[ Classes ]]--
local BarGraphClass = {}
BarGraphClass.__index = BarGraphClass

function BarGraphClass.new(showExtras) 
  local self = {}
  setmetatable(self, BarGraphClass)

  self._barFrame = Instance.new("Frame")
  self._barFrame.Name = "PS_BarFrame"
  self._barFrame.BackgroundTransparency = 1.0

  self._lineFrame = Instance.new("Frame")
  self._lineFrame.Name = "PS_LineFrame"
  self._lineFrame.BackgroundTransparency = 1.0

  self._showExtras = showExtras

  -- All of the values we are showing in the bar graph, in order.
  self._values = {}
  self._bars = {}
  -- Average of these values.
  self._average = 0
  -- Suggested max for these values.
  self._target = 0

  if self._showExtras then
    self:_addGraphTarget()
    self:_addGraphAverage()
  end

  return self
end

function BarGraphClass:SetZIndex(zIndex)
  self._barFrame.ZIndex = zIndex
  self._lineFrame.ZIndex = zIndex + 1
  if self._showExtras then
    self._targetLine.ZIndex = self._lineFrame.ZIndex
    self._averageLine.ZIndex = self._lineFrame.ZIndex
  end
end

function BarGraphClass:PlaceInParent(parent, size, position) 
  self._barFrame.Position = position
  self._barFrame.Size = size
  self._barFrame.Parent = parent
  self._lineFrame.Position = position
  self._lineFrame.Size = size
  self._lineFrame.Parent = parent
end

function BarGraphClass:SetAxisMax(axisMax) 
  self._axisMax = axisMax
end

function BarGraphClass:SetValues(values) 
  self._values = values
end

function BarGraphClass:SetAverage(average) 
  self._average = average
end

function BarGraphClass:SetTarget(target) 
  -- Set the target value, move corresponding graph line 
  -- accordingly (if present).
  self._target = target
  self:_moveGraphTarget()
end

function BarGraphClass:_updateBarCount(newBarCount)
  -- Make sure we have exactly this number of bars in _bars.
  -- Reuse old ones if possible.
  -- If we have more old ones than we need, delete them.
  local newBars = {}
  local currentBarCount = table.getn(self._bars)
  
  for i = 1, currentBarCount, 1 do
    if (i <= currentBarCount) then
      table.insert(newBars, self._bars[i])
    else
      self._bars[i].Destroy()
    end
  end
  
  for i = currentBarCount + 1, newBarCount, 1 do 
    table.insert(newBars, self:_makeNthBar(i))
  end
  
  self._bars = newBars
end
  

function BarGraphClass:Render()    
  local numValues = table.getn(self._values)
  
  self:_updateBarCount(numValues)
  
  for i, value in ipairs(self._values) do
    self:_updateBar(i, value, numValues)
  end  

  if self._showExtras then
    self:_moveGraphAverage()
  end
end


function BarGraphClass:_addGraphTarget() 
  -- Add the line used to mark target value.
  local line = Instance.new("ImageLabel")
  line.Name = "TargetLine"
  line.Size = UDim2.new(1, 0, 0, StatsUtils.GraphTargetLineInnerThickness)

  line.Image = 'rbxasset://textures/ui/PerformanceStats/TargetLine.png'
  line.BackgroundTransparency = 1
  line.Parent = self._lineFrame
  line.ZIndex = self._lineFrame.ZIndex 
  line.BorderSizePixel = 0

  line.Changed:connect(function()
      self:_updateTargetLineImageSize()
    end)

  self._targetLine = line
  self:_updateTargetLineImageSize()
end

function BarGraphClass:_updateTargetLineImageSize()
  self._targetLine.ImageRectSize = self._targetLine.AbsoluteSize
end

function BarGraphClass:_addGraphAverage() 
  -- Add the line used to mark average of current values.
  local line = Instance.new("Frame")
  line.Name = "AverageLine"
  line.Size = UDim2.new(1, 0, 0, StatsUtils.GraphAverageLineInnerThickness)

  line.Parent = self._lineFrame
  line.ZIndex = self._lineFrame.ZIndex

  StatsUtils.StyleAverageLine(line)

  self._averageLine = line
end

function BarGraphClass:_moveGraphTarget() 
  -- Update position of graph target line, if present.
  if self._targetLine == nil then 
    return
  end
  self._targetLine.Position = UDim2.new(0, 
    0, (
      self._axisMax - self._target)/self._axisMax,
    -StatsUtils.GraphTargetLineInnerThickness/2)
end

function BarGraphClass:_moveGraphAverage()  
  -- Update position of graph average line, if present.
  if self._averageLine == nil then 
    return
  end

  -- Never let it go above axis max.
  local adjustedAverage = math.min(self._average, self._axisMax)

  self._averageLine.Position = UDim2.new(0, 
    0, 
    (self._axisMax - adjustedAverage)/self._axisMax,
    -StatsUtils.GraphAverageLineTotalThickness/2)
end

function BarGraphClass:_makeNthBar(index)
  -- Make the nth bar in the bar graph.
  local realIndex = index-1
  local bar = Instance.new("Frame")
  bar.Name = string.format("Bar_%d", realIndex)
  bar.Parent = self._barFrame  
  bar.ZIndex = self._barFrame.ZIndex
  bar.BorderSizePixel = 0
  return bar
end

function BarGraphClass:_updateBar(i, value, numValues) 
  -- Update nth bar in graph: size, position, and color.
  local bar = self._bars[i]
  local realIndex = i-1

  -- Don't let it go off the chart.
  local clampedValue = math.max(0, math.min(value, self._axisMax))

  bar.Position = UDim2.new(realIndex/numValues, 0,
    (self._axisMax - clampedValue)/self._axisMax, 0)
  bar.Size = UDim2.new(1/numValues, 0, 
    clampedValue/self._axisMax, 0)

  bar.BackgroundColor3 = StatsUtils.GetColorForValue(value, self._target)
end

return BarGraphClass]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6F61074644D84ECF88A0BF631CB5C3AF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DecoratedValueLabel</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: DecoratedValueLabel.lua
  Written by: dbanks
  Description: Icon, text label, numeric value.
      Icon is set by creator/caller.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Globals ]]--

--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)

--[[ Classes ]]--
local DecoratedValueLabelClass = {}
DecoratedValueLabelClass.__index = DecoratedValueLabelClass

function DecoratedValueLabelClass.new(statType, valueName) 
  local self = {}
  setmetatable(self, DecoratedValueLabelClass)

  self._frame = Instance.new("Frame")
  self._frame.Name = "PS_DecoratedValueLabel"
  self._frame.BackgroundTransparency = 1.0
  
  self._valueName = valueName
  self._statType = statType
  
  self._decorationFrame = Instance.new("Frame")
  self._decorationFrame.Name = "PS_Decoration"
  self._decorationFrame.Parent = self._frame
  self._decorationFrame.Position = UDim2.new(0, 0, 0.5, -StatsUtils.DecorationSize/2)
  self._decorationFrame.Size = UDim2.new(0, StatsUtils.DecorationSize, 
    0, StatsUtils.DecorationSize)
  self._decorationFrame.BackgroundTransparency = 1.0
  
  self._label =Instance.new("TextLabel")
  self._label.Name = "Label"
  self._label.Parent = self._frame
  self._label.Position = UDim2.new(0, StatsUtils.DecorationSize + StatsUtils.DecorationMargin, 
    0, 0)
  self._label.Size = UDim2.new(1, -(StatsUtils.DecorationSize + StatsUtils.DecorationMargin), 
    1, 0)
  self._label.FontSize = StatsUtils.PanelValueFontSize
  self._label.TextXAlignment = Enum.TextXAlignment.Left
  self._label.TextYAlignment = Enum.TextYAlignment.Center
  
  StatsUtils.StyleTextWidget(self._label)
  
  return self
end
  
function DecoratedValueLabelClass:SetZIndex(zIndex)
  self._frame.ZIndex = zIndex
  self._decorationFrame.ZIndex = zIndex
  self._label.ZIndex = zIndex
end


function DecoratedValueLabelClass:PlaceInParent(parent, size, position)
  self._frame.Parent = parent
  self._frame.Size = size
  self._frame.Position = position
end
    

function DecoratedValueLabelClass:GetDecorationFrame()
  return self._decorationFrame
end
  
function DecoratedValueLabelClass:SetValue(value)
  local formattedValue = StatsUtils.FormatTypedValue(value, self._statType)
  self._label.Text = string.format("%s: %s", self._valueName, formattedValue)  
end


return DecoratedValueLabelClass]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC296437739A745FD8A9B9AFD1320308C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsAggregatorManager</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[
--[[
  Filename: StatsAggregatorManager.lua
  Written by: dbanks
  Description: Indexed array of stats aggregators, one for each stat.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)
local StatsAggregatorClass = require(CoreGuiService.RobloxGui.Modules.Stats.StatsAggregator)


--[[ Classes ]]--
local StatsAggregatorManagerClass = {}
StatsAggregatorManagerClass.__index = StatsAggregatorManagerClass

StatsAggregatorManagerClass.SecondsBetweenUpdate = 1.0
StatsAggregatorManagerClass.NumSamplesToKeep = 20

function StatsAggregatorManagerClass.new() 
  local self = {}
  setmetatable(self, StatsAggregatorManagerClass)
  
  self._statsAggregators = {}
  
  for i, statType in ipairs(StatsUtils.AllStatTypes) do
    local statsAggregator = StatsAggregatorClass.new(statType, 
      StatsAggregatorManagerClass.NumSamplesToKeep, 
      StatsAggregatorManagerClass.SecondsBetweenUpdate)
    self._statsAggregators[statType] = statsAggregator
  end
  
  return self
end


function StatsAggregatorManagerClass:StartListening()
  for i, statsAggregator in pairs(self._statsAggregators) do
    statsAggregator:StartListening()
  end
end

function StatsAggregatorManagerClass:StopListening()
  for i, statsAggregator in pairs(self._statsAggregators) do
    statsAggregator:StopListening()
  end
end

function StatsAggregatorManagerClass:GetAggregator(statsType)
  return self._statsAggregators[statsType]
end

return StatsAggregatorManagerClass]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA283A5EEF94E4797A9305A85B9D94479">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatsAnnotatedGraph</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
  Filename: StatsAnnotatedGraph.lua
  Written by: dbanks
  Description: A graph plus extra annotations like axis markings, 
      target lines, etc.
--]]

--[[ Services ]]--
local CoreGuiService = game:GetService('CoreGui')

--[[ Globals ]]--
local Margin = 10
local LabelXWidth = 30

--[[ Modules ]]--
local StatsUtils = require(CoreGuiService.RobloxGui.Modules.Stats.StatsUtils)
local BarGraphClass = require(CoreGuiService.RobloxGui.Modules.Stats.BarGraph)

--[[ Classes ]]--
local StatsAnnotatedGraphClass = {}
StatsAnnotatedGraphClass.__index = StatsAnnotatedGraphClass

function StatsAnnotatedGraphClass.new(statType, isMaximized) 
  local self = {}
  setmetatable(self, StatsAnnotatedGraphClass)

  self._statType = statType
  self._statMaxName = StatsUtils.StatMaxNames[statType]
  self._isMaximized = isMaximized

  self._values = {}
  
  -- Average value of all bars in the graph.
  self._average = 0
  -- Suggested max value for the stat being measured.
  self._target = 0
  -- Max value we display on the y-axis.  Values higher than this are truncated.
  self._axisMax = 0
  
  self._frame = Instance.new("Frame")
  self._frame.Name = "PS_AnnotatedGraph"
  self._frame.BackgroundTransparency = 1.0
    self._frame.ZIndex = StatsUtils.GraphZIndex

  self._topLabel = Instance.new("TextLabel")
  self._topLabel.Name = "PS_TopAxisLabel"
  self._topLabel.Parent = self._frame
  self._topLabel.TextXAlignment = Enum.TextXAlignment.Left
  self._topLabel.TextYAlignment = Enum.TextYAlignment.Top
  self._topLabel.FontSize = StatsUtils.PanelGraphFontSize
  
  self._bottomLabel = Instance.new("TextLabel")
  self._bottomLabel.Name = "PS_BottomAxisLabel"
  self._bottomLabel.Parent = self._frame
  self._bottomLabel.TextXAlignment = Enum.TextXAlignment.Left
  self._bottomLabel.TextYAlignment = Enum.TextYAlignment.Bottom
  self._bottomLabel.FontSize = StatsUtils.PanelGraphFontSize

  local showExtras = isMaximized
  self._graph = BarGraphClass.new(showExtras)

  StatsUtils.StyleTextWidget(self._topLabel)
  StatsUtils.StyleTextWidget(self._bottomLabel)

  self:_layoutElements()

  return self
end

function StatsAnnotatedGraphClass:SetZIndex(zIndex)
  self._frame.ZIndex = zIndex
  self._topLabel.ZIndex = zIndex
  self._bottomLabel.ZIndex = zIndex
  self._graph:SetZIndex(zIndex)
end

function StatsAnnotatedGraphClass:_layoutElements()
  local labelWidth
  if (self._isMaximized) then
    labelWidth = LabelXWidth
    
    self._topLabel.Visible = true
    self._bottomLabel.Visible = true
  else
    labelWidth = 0
    
    self._topLabel.Visible = false
    self._bottomLabel.Visible = false
  end
  
  local GraphFramePosition = UDim2.new(0, Margin, 0, Margin)
  local GraphFrameSize = UDim2.new(1, -(2 * Margin + labelWidth), 1, -2 * Margin)

  local TopLabelFramePosition = UDim2.new(1, -(Margin + labelWidth), 0, Margin)
  local TopLabelFrameSize = UDim2.new(0, labelWidth, 0.333, -2 * Margin)
  local BottomLabelFramePosition = UDim2.new(1, -(Margin + labelWidth), 0.666, Margin)
  local BottomLabelFrameSize = UDim2.new(0, labelWidth, 0.333, -2 * Margin)
  
  self._topLabel.Size = TopLabelFrameSize
  self._topLabel.Position = TopLabelFramePosition
  self._bottomLabel.Size = BottomLabelFrameSize
  self._bottomLabel.Position = BottomLabelFramePosition
  
  self._graph:PlaceInParent(self._frame, GraphFrameSize, GraphFramePosition)
end

function StatsAnnotatedGraphClass:PlaceInParent(parent, size, position) 
  self._frame.Position = position
  self._frame.Size = size
  self._frame.Parent = parent
end

function StatsAnnotatedGraphClass:_getTarget()
  -- Get the current target value for the graphed stat.
  if self._performanceStats == nil then
    return 0
  end  
  
  local maxItemStats = self._performanceStats:FindFirstChild(self._statMaxName)
  if maxItemStats == nil then
    return 0
  end
  
  return maxItemStats:GetValue()
end

function StatsAnnotatedGraphClass:_render()  
  self._graph:SetAxisMax(self._axisMax)
  self._graph:SetValues(self._values)

  self._graph:SetAverage(self._average)
  self._graph:SetTarget(self._target)
  self._graph:Render()
  
  self._topLabel.Text = string.format("%.2f", self._axisMax)
  self._bottomLabel.Text = string.format("%.2f", 0,.0)
end

function StatsAnnotatedGraphClass:_calculateAxisMax()
  -- Calculate an optimal max axis label for this graph, given this 'target' value.
  -- We want target to be roughly in the middle.
  -- Say, roughly twice the target.
  local max = self._target * 2
  local orderOfMagnitude = self:_recursiveGetOrderOfMagnitude(1.0, max)
  local div = math.floor(0.5 + max/orderOfMagnitude)
  self._axisMax = div * orderOfMagnitude
end

function StatsAnnotatedGraphClass:SetStatsAggregator(aggregator)
  if (self._aggregator) then
    self._aggregator:RemoveListener(self._listenerId)
    self._listenerId = nil
    self._aggregator = nil
  end
  
  self._aggregator = aggregator
  
  self:OnVisibilityChanged()
end

function StatsAnnotatedGraphClass:_stopListening()
  if (self._aggregator == nil) then
    return
  end
  
  if (self._listenerId == nil) then 
    return
  end
  
  self._aggregator:RemoveListener(self._listenerId)
  self._listenerId = nil  
end

function StatsAnnotatedGraphClass:_startListening()
  if (self._aggregator == nil) then
    return
  end
  
  if (self._listenerId ~= nil) then 
    return
  end
  
  self._listenerId = self._aggregator:AddListener(function()
      self:_updateValuesAndRender()
  end)  
end



function StatsAnnotatedGraphClass:OnVisibilityChanged()
  if StatsUtils.PerformanceStatsShouldBeVisible() then
    self:_startListening()
    self:_updateValuesAndRender()
  else
    self:_stopListening()
  end
end

function StatsAnnotatedGraphClass:_recursiveGetOrderOfMagnitude(estimate, target)
  if (estimate > target) then 
    return self:_recursiveGetOrderOfMagnitude(estimate/10.0, target)
  end
  
  if (estimate * 10 >= target) then 
    return estimate
  end
  
  return self:_recursiveGetOrderOfMagnitude(estimate*10.0, target)
end

function StatsAnnotatedGraphClass:_updateValuesAndRender() 
  self._values = {}
  self._average = 0
  self._target = 0
  if self._aggregator ~= nil then 
    self._values = self._aggregator:GetValues()
    self._average = self._aggregator:GetAverage()
    self._target = self._aggregator:GetTarget()
  end
  
  self:_calculateAxisMax()
  self:_render()
end

return StatsAnnotatedGraphClass
]]></ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX881F407D55F34318A7612AC77A49700D">
				<Properties>
					<string name="Name">Settings</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX1FECD03406F64F5BA379B52E24029472">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Utility</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
		Filename: SettingsPage.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Base Page Functionality for all Settings Pages
--]]

------------------ CONSTANTS --------------------
local SELECTED_COLOR = Color3.new(0,162/255,1)
local NON_SELECTED_COLOR = Color3.new(78/255,84/255,96/255)

local ARROW_COLOR = Color3.new(0.8, 0.8, 0.8)
local ARROW_COLOR_HOVER = Color3.new(1, 1, 1)
local ARROW_COLOR_TOUCH = ARROW_COLOR_HOVER

local SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarLeft.png"
local NON_SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/BarLeft.png"
local SELECTED_RIGHT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarRight.png"
local NON_SELECTED_RIGHT_IMAGE= "rbxasset://textures/ui/Settings/Slider/BarRight.png"

local CONTROLLER_SCROLL_DELTA = 0.2
local CONTROLLER_THUMBSTICK_DEADZONE = 0.8

local DROPDOWN_BG_TRANSPARENCY = 0.2

------------- SERVICES ----------------
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:FindFirstChild("RobloxGui")
local ContextActionService = game:GetService("ContextActionService")

------------------ VARIABLES --------------------
local tenFootInterfaceEnabled = false
do
	RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
	tenFootInterfaceEnabled = require(RobloxGui.Modules.TenFootInterface):IsEnabled()
end

--------------- FLAGS ----------------
local getFixSettingsMenuVRSuccess, fixSettingsMenuVRValue = pcall(function() return settings():GetFFlag("FixSettingsMenuVRLua") end)
local fixSettingsMenuVR = getFixSettingsMenuVRSuccess and fixSettingsMenuVRValue

----------- UTILITIES --------------
local Util = {}
do
	function Util.Create(instanceType)
		return function(data)
			local obj = Instance.new(instanceType)
			local parent = nil
			for k, v in pairs(data) do
				if type(k) == 'number' then
					v.Parent = obj
				elseif k == 'Parent' then
					parent = v
				else
					obj[k] = v
				end
			end
			if parent then
				obj.Parent = parent
			end
			return obj
		end
	end
end


-- used by several guis to show no selection adorn
local noSelectionObject = Util.Create'ImageLabel'
{
	Image = "",
	BackgroundTransparency = 1
};


-- MATH --
function clamp(low, high, input)
	return math.max(low, math.min(high, input))
end

function ClampVector2(low, high, input)
	return Vector2.new(clamp(low.x, high.x, input.x), clamp(low.y, high.y, input.y))
end

---- TWEENZ ----
local Linear = function(t, b, c, d)
	if t >= d then return b + c end

	return c*t/d + b
end

local EaseOutQuad = function(t, b, c, d)
	if t >= d then return b + c end

	t = t/d;
	return -c * t*(t-2) + b
end

local EaseInOutQuad = function(t, b, c, d)
	if t >= d then return b + c end

	t = t / (d/2);
	if (t < 1) then return c/2*t*t + b end;
	t = t - 1;
	return -c/2 * (t*(t-2) - 1) + b;
end

function PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
	local this = {}
	this.StartTime = tick()
	this.EndTime = this.StartTime + duration
	this.Cancelled = false

	local finished = false
	local percentComplete = 0

	local function finalize()
		if instance then
			instance[prop] = easingFunc(1, start, final - start, 1)
		end
		finished = true
		percentComplete = 1
		if cbFunc then
			cbFunc()
		end
	end

	-- Initial set
	instance[prop] = easingFunc(0, start, final - start, duration)
	spawn(function()
		local now = tick()
		while now < this.EndTime and instance do
			if this.Cancelled then
				return
			end
			instance[prop] = easingFunc(now - this.StartTime, start, final - start, duration)
			percentComplete = clamp(0, 1, (now - this.StartTime) / duration)
			RunService.RenderStepped:wait()
			now = tick()
		end
		if this.Cancelled == false and instance then
			finalize()
		end
	end)

	function this:GetFinal()
		return final
	end

	function this:GetPercentComplete()
		return percentComplete
	end

	function this:IsFinished()
		return finished
	end

	function this:Finish()
		if not finished then
			self:Cancel()
			finalize()
		end
	end

	function this:Cancel()
		this.Cancelled = true
	end

	return this
end

----------- CLASS DECLARATION --------------

local function CreateSignal()
	local sig = {}

	local mSignaler = Instance.new('BindableEvent')

	local mArgData = nil
	local mArgDataCount = nil

	function sig:fire(...)
		mArgData = {...}
		mArgDataCount = select('#', ...)
		mSignaler:Fire()
	end

	function sig:connect(f)
		if not f then error("connect(nil)", 2) end
		return mSignaler.Event:connect(function()
			f(unpack(mArgData, 1, mArgDataCount))
		end)
	end

	function sig:wait()
		mSignaler.Event:wait()
		assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
		return unpack(mArgData, 1, mArgDataCount)
	end

	return sig
end

local function getViewportSize()
	while not game.Workspace.CurrentCamera do
		game.Workspace.Changed:wait()
	end

	while game.Workspace.CurrentCamera.ViewportSize == Vector2.new(0,0) do
		game.Workspace.CurrentCamera.Changed:wait()
	end

	return game.Workspace.CurrentCamera.ViewportSize
end

local function isSmallTouchScreen()
	return UserInputService.TouchEnabled and getViewportSize().Y <= 500
end

local function isTenFootInterface()
	return tenFootInterfaceEnabled
end

local function usesSelectedObject()
	--VR does not use selected objects (in the same way as gamepad)
	if UserInputService.VREnabled then return false end
	--Touch does not use selected objects unless there's also a gamepad 
	if UserInputService.TouchEnabled and not UserInputService.GamepadEnabled then return false end
	--PC with gamepad, console... does use selected objects
	return true
end

local function isPosOverGui(pos, gui, debug) -- does not account for rotation
	local ax, ay = gui.AbsolutePosition.x, gui.AbsolutePosition.y
	local sx, sy = gui.AbsoluteSize.x, gui.AbsoluteSize.y
	local bx, by = ax+sx, ay+sy

	if pos.x > ax and pos.x < bx and pos.y > ay and pos.y < by then
		return true
	else
		return false
	end
end

local function isPosOverGuiWithClipping(pos, gui) -- isPosOverGui, accounts for clipping and visibility, does not account for rotation
	if not isPosOverGui(pos, gui) then
		return false
	end

	local clipping = false
	local check = gui
	while true do
		if check == nil or (not check:IsA'GuiObject' and not check:IsA'LayerCollector') then
			clipping = true
			if check and check:IsA'CoreGui' then
				clipping = false
			end
			break
		end
		
		if check:IsA'GuiObject' and not check.Visible then
			clipping = true
			break
		end
		if check:IsA'LayerCollector' or check.ClipsDescendants then
			if not isPosOverGui(pos, check) then
				clipping = true
				break
			end
		end

		check = check.Parent
	end
	
	if clipping then
		return false
	else
		return true
	end
end

local function areGuisIntersecting(a, b) -- does not account for rotation
	local aax, aay = a.AbsolutePosition.x, a.AbsolutePosition.y
	local asx, asy = a.AbsoluteSize.x, a.AbsoluteSize.y
	local abx, aby = aax+asx, aay+asy
	local bax, bay = b.AbsolutePosition.x, b.AbsolutePosition.y
	local bsx, bsy = b.AbsoluteSize.x, b.AbsoluteSize.y
	local bbx, bby = bax+bsx, bay+bsy

	local intersectingX = aax < bbx and abx > bax
	local intersectingY = aay < bby and aby > bay
	local intersecting = intersectingX and intersectingY

	return intersecting
end

local function isGuiVisible(gui, debug) -- true if any part of the gui is visible on the screen, considers clipping, does not account for rotation
	local clipping = false
	local check = gui
	while true do
		if check == nil or not check:IsA'GuiObject' and not check:IsA'LayerCollector' then
			clipping = true
			if check and check:IsA'CoreGui' then
				clipping = false
			end
			break
		end
		
		if check:IsA'GuiObject' and not check.Visible then
			clipping = true
			break
		end
		if check:IsA'LayerCollector' or check.ClipsDescendants then
			if not areGuisIntersecting(check, gui) then
				clipping = true
				break
			end
		end

		check = check.Parent
	end
	
	if clipping then
		return false
	else
		return true
	end
end

local function addHoverState(button, instance, onNormalButtonState, onHoverButtonState)
	local function onNormalButtonStateCallback() onNormalButtonState(instance) end
	local function onHoverButtonStateCallback() onHoverButtonState(instance) end

	button.MouseEnter:connect(onHoverButtonStateCallback)
	button.SelectionGained:connect(onHoverButtonStateCallback)
	button.MouseLeave:connect(onNormalButtonStateCallback)
	button.SelectionLost:connect(onNormalButtonStateCallback)

	onNormalButtonState(instance)
end

local function MakeButton(name, text, size, clickFunc, pageRef, hubRef)
	local SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1,
	};

	local button = Util.Create'ImageButton'
	{
		Name = name .. "Button",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		AutoButtonColor = false,
		BackgroundTransparency = 1,
		Size = size,
		ZIndex = 2,
		SelectionImageObject = SelectionOverrideObject
	};
	button.NextSelectionLeft = button
	button.NextSelectionRight = button

	local enabled = Util.Create'BoolValue'
	{
		Name = 'Enabled',
		Parent = button,
		Value = true
	}

	if clickFunc then 
		button.MouseButton1Click:connect(function() 
			local lastInputType = nil
			pcall(function() lastInputType = UserInputService:GetLastInputType() end)
			if lastInputType then
				clickFunc(lastInputTypee == Enum.UserInputType.Gamepad1 or lastInputType == Enum.UserInputType.Gamepad2 or 
					lastInputType == Enum.UserInputType.Gamepad3 or lastInputType == Enum.UserInputType.Gamepad4)
			else
				clickFunc(false)
			end
		end) 
	end

	local function isPointerInput(inputObject)
		return (inputObject.UserInputType == Enum.UserInputType.MouseMovement or inputObject.UserInputType == Enum.UserInputType.Touch)
	end

	local function selectButton()
		local hub = hubRef
		if hub == nil then
			if pageRef then
				hub = pageRef.HubRef
			end
		end

		if (hub and hub.Active or hub == nil) then
			button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButtonSelected.png"

			local scrollTo = button
			if rowRef then
				scrollTo = rowRef
			end
			if hub then
				hub:ScrollToFrame(scrollTo)
			end
		end
	end

	local function deselectButton()
		button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png"
	end

	button.InputBegan:connect(function(inputObject)
		if button.Selectable and isPointerInput(inputObject) then
			selectButton()
		end
	end)
	button.InputEnded:connect(function(inputObject)
		if button.Selectable and GuiService.SelectedCoreObject ~= button and isPointerInput(inputObject) then
			deselectButton()
		end
	end)

	local rowRef = nil
	local function setRowRef(ref)
		rowRef = ref
	end
	button.SelectionGained:connect(function()
		selectButton()
	end)
	button.SelectionLost:connect(function()
		deselectButton()
	end)

	local textLabel = Util.Create'TextLabel'
	{
		Name = name .. "TextLabel",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, -8),
		Position = UDim2.new(0,0,0,0),
		TextColor3 = Color3.new(1,1,1),
		TextYAlignment = Enum.TextYAlignment.Center,
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size24,
		Text = text,
		TextWrapped = true,
		ZIndex = 2,
		Parent = button
	};

	if isSmallTouchScreen() then
		textLabel.FontSize = Enum.FontSize.Size18
	elseif isTenFootInterface() then
		textLabel.FontSize = Enum.FontSize.Size36
	end

	local guiServiceCon = GuiService.Changed:connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end
		if not usesSelectedObject() then return end

		if GuiService.SelectedCoreObject == nil or GuiService.SelectedCoreObject ~= button then 
			deselectButton()
			return 
		end

		if button.Selectable then
			selectButton()
		end
	end)

	return button, textLabel, setRowRef
end

local function CreateDropDown(dropDownStringTable, startPosition, settingsHub)
	-------------------- CONSTANTS ------------------------
	local DEFAULT_DROPDOWN_TEXT = "Choose One"
	local SCROLLING_FRAME_PIXEL_OFFSET = 25
	local SELECTION_TEXT_COLOR_NORMAL = Color3.new(0.7,0.7,0.7)
	local SELECTION_TEXT_COLOR_NORMAL_VR = Color3.new(0.9, 0.9, 0.9)
	local SELECTION_TEXT_COLOR_HIGHLIGHTED = Color3.new(1,1,1)

	-------------------- VARIABLES ------------------------
	local lastSelectedCoreObject= nil

	-------------------- SETUP ------------------------
	local this = {}
	this.CurrentIndex = nil

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	if type(dropDownStringTable) ~= "table" then
		error("CreateDropDown dropDownStringTable (first arg) is not a table")
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true
	local guid = HttpService:GenerateGUID(false)
	local dropDownButtonEnabled
	local lastStringTable = dropDownStringTable

	this.CurrentIndex = 0

	----------------- GUI SETUP ------------------------
	local DropDownFullscreenFrame = Util.Create'ImageButton'
	{
		Name = "DropDownFullscreenFrame",
		BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.new(0,0,0),
		ZIndex = 10,
		Active = true,
		Visible = false,
		Selectable = false,
		AutoButtonColor = false,
		Parent = CoreGui.RobloxGui
	};

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if UserInputService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			DropDownFullscreenFrame.Parent = Panel3D.Get("SettingsMenu"):GetGUI()
			DropDownFullscreenFrame.BackgroundTransparency = 1
		else
			DropDownFullscreenFrame.Parent = CoreGui.RobloxGui
			DropDownFullscreenFrame.BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY
		end

		--Force the gui to update, but only if onVREnabled is fired later on
		if this.UpdateDropDownList then
			this:UpdateDropDownList(lastStringTable)
		end
	end
	if fixSettingsMenuVR then
		UserInputService.Changed:connect(onVREnabled)
		onVREnabled("VREnabled")
	end

	local DropDownSelectionFrame = Util.Create'ImageLabel'
	{
		Name = "DropDownSelectionFrame",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,
		Size = UDim2.new(0, 400, 0.9, 0),
		Position = UDim2.new(0.5, -200, 0.05, 0),
		ZIndex = 10,
		Parent = DropDownFullscreenFrame
	};

	local DropDownScrollingFrame = Util.Create'ScrollingFrame'
	{
		Name = "DropDownScrollingFrame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, -20, 1, -SCROLLING_FRAME_PIXEL_OFFSET),
		Position = UDim2.new(0, 10, 0, 10),
		ZIndex = 10,
		Parent = DropDownSelectionFrame
	};

	local guiServiceChangeCon = nil
	local active = false
	local hideDropDownSelection = function(name, inputState)
		if name ~= nil and inputState ~= Enum.UserInputState.Begin then return end
		this.DropDownFrame.Selectable = interactable

		if DropDownFullscreenFrame.Visible and usesSelectedObject() then
			GuiService.SelectedCoreObject = lastSelectedCoreObject
		end
		DropDownFullscreenFrame.Visible = false
		if guiServiceChangeCon then guiServiceChangeCon:disconnect() end
		ContextActionService:UnbindCoreAction(guid .. "Action")
		ContextActionService:UnbindCoreAction(guid .. "FreezeAction")

		settingsHub:SetActive(true)

		dropDownButtonEnabled.Value = interactable
		active = false

		if fixSettingsMenuVR and UserInputService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0)
		end
	end
	local noOpFunc = function() end

	local DropDownFrameClicked = function()
		if not interactable then return end

		this.DropDownFrame.Selectable = false
		active = true

		DropDownFullscreenFrame.Visible = true
		if fixSettingsMenuVR and UserInputService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0.5)
		end
		if not this.CurrentIndex then this.CurrentIndex = 1 end
		if this.CurrentIndex <= 0 then this.CurrentIndex = 1 end

		lastSelectedCoreObject = this.DropDownFrame
		GuiService.SelectedCoreObject = this.Selections[this.CurrentIndex]

		guiServiceChangeCon = GuiService.Changed:connect(function(prop)
			if not prop == "SelectedCoreObject" then return end
			for i = 1, #this.Selections do
				if GuiService.SelectedCoreObject == this.Selections[i] then
					this.Selections[i].TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
				else
					this.Selections[i].TextColor3 = UserInputService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL
				end
			end
		end)

		ContextActionService:BindCoreAction(guid .. "FreezeAction", noOpFunc, false, Enum.UserInputType.Keyboard, Enum.UserInputType.Gamepad1)
		ContextActionService:BindCoreAction(guid .. "Action", hideDropDownSelection, false, Enum.KeyCode.ButtonB, Enum.KeyCode.Escape)

		settingsHub:SetActive(false)

		dropDownButtonEnabled.Value = false
	end

	local dropDownFrameSize = UDim2.new(0,400,0,44)
	if isSmallTouchScreen() then
		dropDownFrameSize = UDim2.new(0,300,0,44)
	end
	this.DropDownFrame = MakeButton("DropDownFrame", DEFAULT_DROPDOWN_TEXT, dropDownFrameSize, DropDownFrameClicked)
	dropDownButtonEnabled = this.DropDownFrame.Enabled
	local selectedTextLabel = this.DropDownFrame.DropDownFrameTextLabel
	local dropDownImage = Util.Create'ImageLabel'
	{
		Name = "DropDownImage",
		Image = "rbxasset://textures/ui/Settings/DropDown/DropDown.png",
		BackgroundTransparency = 1,
		Size = UDim2.new(0,15,0,10),
		Position = UDim2.new(1, -45,0.5,-7),
		ZIndex = 2,
		Parent = this.DropDownFrame
	};


	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if i == index then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end
		
		if shouldFireChanged then
			indexChangedEvent:Fire(index)
		end
	end
	
	local function setSelectionByValue(value)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if selectionLabel.Text == value then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end
		
		if shouldFireChanged then
			indexChangedEvent:Fire(this.CurrentIndex)
		end
		return shouldFireChanged
	end

	local enterIsDown = false
	local function processInput(input)
		if input.UserInputState == Enum.UserInputState.Begin then
			if input.KeyCode == Enum.KeyCode.Return then
				if GuiService.SelectedCoreObject == this.DropDownFrame or this.SelectionInfo and this.SelectionInfo[GuiService.SelectedCoreObject] then
					enterIsDown = true
				end
			end
		elseif input.UserInputState == Enum.UserInputState.End then
			if input.KeyCode == Enum.KeyCode.Return and enterIsDown then
				enterIsDown = false
				if GuiService.SelectedCoreObject == this.DropDownFrame then
					DropDownFrameClicked()
				elseif this.SelectionInfo and this.SelectionInfo[GuiService.SelectedCoreObject] then
					local info = this.SelectionInfo[GuiService.SelectedCoreObject]
					info.Clicked()
				end
			end
		end
	end


	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex)
	end
	
	function this:SetSelectionByValue(value)
		return setSelectionByValue(value)
	end

	function this:ResetSelectionIndex()
		this.CurrentIndex = nil
		selectedTextLabel.Text = DEFAULT_DROPDOWN_TEXT
		hideDropDownSelection()
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		this.DropDownFrame.ZIndex = newZIndex
		dropDownImage.ZIndex = newZIndex
		selectedTextLabel.ZIndex = newZIndex
	end

	function this:SetInteractable(value)
		interactable = value
		this.DropDownFrame.Selectable = interactable
		
		if not interactable then
			hideDropDownSelection()
			this:SetZIndex(1)
		else
			this:SetZIndex(2)
		end

		dropDownButtonEnabled.Value = value and not active
	end


	function this:UpdateDropDownList(dropDownStringTable)
		lastStringTable = dropDownStringTable

		if this.Selections then
			for i = 1, #this.Selections do
				this.Selections[i]:Destroy()
			end
		end

		this.Selections = {}
		this.SelectionInfo = {}

		local vrEnabled = UserInputService.VREnabled
		local font = vrEnabled and Enum.Font.SourceSansBold or Enum.Font.SourceSans
		local fontSize = vrEnabled and Enum.FontSize.Size36 or Enum.FontSize.Size24

		local itemHeight = vrEnabled and 70 or 50
		local itemSpacing = itemHeight + 1

		local dropDownWidth = vrEnabled and 600 or 400

		for i,v in pairs(dropDownStringTable) do
			local SelectionOverrideObject =	Util.Create'Frame'
			{
				BackgroundTransparency = 0.7,
				BorderSizePixel = 0,
				Size = UDim2.new(1, 0, 1, 0)
			};

			local nextSelection = Util.Create'TextButton'
			{
				Name = "Selection" .. tostring(i),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				AutoButtonColor = false,
				Size = UDim2.new(1, -28, 0, itemHeight),
				Position = UDim2.new(0,14,0, (i - 1) * itemSpacing),
				TextColor3 = UserInputService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL,
				Font = font,
				FontSize = fontSize,
				Text = v,
				ZIndex = 10,
				SelectionImageObject = SelectionOverrideObject,
				Parent = DropDownScrollingFrame
			};

			if i == startPosition then
				this.CurrentIndex = i
				selectedTextLabel.Text = v
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			elseif not startPosition and i == 1 then
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			end

			local clicked = function()
				selectedTextLabel.Text = nextSelection.Text
				hideDropDownSelection()
				this.CurrentIndex = i
				indexChangedEvent:Fire(i)
			end

			nextSelection.MouseButton1Click:connect(clicked)

			nextSelection.MouseEnter:connect(function()
				if usesSelectedObject() then
					GuiService.SelectedCoreObject = nextSelection
				end
			end)

			this.Selections[i] = nextSelection
			this.SelectionInfo[nextSelection] = {Clicked = clicked}
		end

		GuiService:RemoveSelectionGroup(guid)
		GuiService:AddSelectionTuple(guid, unpack(this.Selections))

		DropDownScrollingFrame.CanvasSize = UDim2.new(1,-20,0,#dropDownStringTable * itemSpacing)

		local function updateDropDownSize()
			if DropDownScrollingFrame.CanvasSize.Y.Offset < (DropDownFullscreenFrame.AbsoluteSize.Y - 10) then
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth,
														0,DropDownScrollingFrame.CanvasSize.Y.Offset + SCROLLING_FRAME_PIXEL_OFFSET)
				DropDownSelectionFrame.Position = UDim2.new(0.5, -dropDownWidth / 2,
															0.5, -DropDownSelectionFrame.Size.Y.Offset/2)
			else
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth, 0.9, 0)
				DropDownSelectionFrame.Position = UDim2.new(0.5, -dropDownWidth / 2, 0.05, 0)
			end
		end

		DropDownFullscreenFrame.Changed:connect(function(prop)
			if prop ~= "AbsoluteSize" then return end
			updateDropDownSize()
		end)

		updateDropDownSize()
	end

	----------------------- CONNECTIONS/SETUP --------------------------------
	this:UpdateDropDownList(dropDownStringTable)

	DropDownFullscreenFrame.MouseButton1Click:connect(hideDropDownSelection)

	settingsHub.PoppedMenu:connect(function(poppedMenu)
		if poppedMenu == DropDownFullscreenFrame then
			hideDropDownSelection()
		end
	end)

	UserInputService.InputBegan:connect(processInput)
	UserInputService.InputEnded:connect(processInput)

	return this
end


local function CreateSelector(selectionStringTable, startPosition)

	-------------------- VARIABLES ------------------------
	local lastInputDirection = 0
	local TweenTime = 0.15

	-------------------- SETUP ------------------------
	local this = {}
	this.HubRef = nil

	if type(selectionStringTable) ~= "table" then
		error("CreateSelector selectionStringTable (first arg) is not a table")
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true

	this.CurrentIndex = 0

	----------------- GUI SETUP ------------------------
	this.SelectorFrame = Util.Create'ImageButton'
	{
		Name = "Selector",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SelectorFrame,
		NextSelectionRight = this.SelectorFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,502,0,50),
		ZIndex = 2,
		SelectionImageObject = noSelectionObject
	};
	if isSmallTouchScreen() then
		this.SelectorFrame.Size = UDim2.new(0,400,0,50)
	end

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(0,-10,0.5,-25),
		Size =  UDim2.new(0,60,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(1,-50,0.5,-25),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(1,-24,0.5,-15),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Left.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = leftButton
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(0,6,0.5,-15),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Right.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = rightButton
	};
	if not UserInputService.TouchEnabled and fixSettingsMenuVR then
		local applyNormal, applyHover = 
			function(instance) instance.ImageColor3 = ARROW_COLOR end,
			function(instance) instance.ImageColor3 = ARROW_COLOR_HOVER end

		addHoverState(leftButton, leftButtonImage, applyNormal, applyHover)
		addHoverState(rightButton, rightButtonImage, applyNormal, applyHover)
	end


	this.Selections = {}
	local isSelectionLabelVisible = {}
	local isAutoSelectButton = {}

	for i,v in pairs(selectionStringTable) do
		local nextSelection = Util.Create'TextLabel'
		{
			Name = "Selection" .. tostring(i),
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			Size = UDim2.new(1,leftButton.Size.X.Offset * -2, 1, 0),
			Position = UDim2.new(1,0,0,0),
			TextColor3 = Color3.new(1,1,1),
			TextYAlignment = Enum.TextYAlignment.Center,
			TextTransparency = 0.5,
			Font = Enum.Font.SourceSans,
			FontSize = Enum.FontSize.Size24,
			Text = v,
			ZIndex = 2,
			Visible = false,
			Parent = this.SelectorFrame
		};
		if isTenFootInterface() then
			nextSelection.FontSize = Enum.FontSize.Size36
		end

		if i == startPosition then
			this.CurrentIndex = i
			nextSelection.Position = UDim2.new(0,leftButton.Size.X.Offset,0,0)
			nextSelection.Visible = true

			isSelectionLabelVisible[nextSelection] = true
		else
			isSelectionLabelVisible[nextSelection] = false
		end

		if not fixSettingsMenuVR then
			--The old code was creating an AutoSelectButton for each option in the selector
			--that tweened in and out when you cycled through the options. This was kind of
			--strange and didn't play well with VR input.
			local autoSelectButton = Util.Create'ImageButton'{
				Name = 'AutoSelectButton',
				BackgroundTransparency = 1,
				Image = '',
				Size = UDim2.new(1, 0, 1, 0),
				Parent = this.SelectorFrame,
				ZIndex = 2
			}
			autoSelectButton.MouseButton1Click:connect(function()
				if not interactable then return end
				local newIndex = this.CurrentIndex + 1
				if newIndex > #this.Selections then
					newIndex = 1
				end
				this:SetSelectionIndex(newIndex)
				if usesSelectedObject() then
					GuiService.SelectedCoreObject = this.SelectorFrame
				end
			end)
			isAutoSelectButton[autoSelectButton] = true
		end

		this.Selections[i] = nextSelection
	end

	local autoSelectButton
	if fixSettingsMenuVR then
		--So I moved the AutoSelectButton out of that loop so only one is created
		--per selector. It functions the same; it increments the selection by one
		--every time it's clicked/activated.
		autoSelectButton = Util.Create'ImageButton'{
			Name = 'AutoSelectButton',
			BackgroundTransparency = 1,
			Image = '',
			Position = UDim2.new(0, leftButton.Size.X.Offset, 0, 0),
			Size = UDim2.new(1, leftButton.Size.X.Offset * -2, 1, 0),
			Parent = this.SelectorFrame,
			ZIndex = 2,
			SelectionImageObject = noSelectionObject
		}
		autoSelectButton.MouseButton1Click:connect(function()
			if not interactable then return end
			local newIndex = this.CurrentIndex + 1
			if newIndex > #this.Selections then
				newIndex = 1
			end
			this:SetSelectionIndex(newIndex)
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = this.SelectorFrame
			end
		end)
		isAutoSelectButton[autoSelectButton] = true
	end

	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index, direction)
		for i, selectionLabel in pairs(this.Selections) do
			local isSelected = (i == index)
			
			local leftButtonUDim = UDim2.new(0,leftButton.Size.X.Offset,0,0)
			local tweenPos = UDim2.new(0,leftButton.Size.X.Offset * direction * 3,0,0)

			if isSelectionLabelVisible[selectionLabel] then
				tweenPos = UDim2.new(0,leftButton.Size.X.Offset * -direction * 3,0,0)
			end

			if tweenPos.X.Offset < 0 then
				tweenPos = UDim2.new(0,tweenPos.X.Offset + (selectionLabel.AbsoluteSize.X/4),0,0)
			end

			if isSelected then
				isSelectionLabelVisible[selectionLabel] = true
				selectionLabel.Position = tweenPos
				selectionLabel.Visible = true
				PropertyTweener(selectionLabel, "TextTransparency", 1, 0, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(leftButtonUDim, Enum.EasingDirection.In, Enum.EasingStyle.Quad, TweenTime, true)
				else
					selectionLabel.Position = leftButtonUDim
				end
				this.CurrentIndex = i
				indexChangedEvent:Fire(index)
			elseif isSelectionLabelVisible[selectionLabel] then
				isSelectionLabelVisible[selectionLabel] = false
				PropertyTweener(selectionLabel, "TextTransparency", 0, 1, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(tweenPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, TweenTime * 0.9, true)
				else
					selectionLabel.Position = UDim2.new(tweenPos)
				end
			end
		end
	end

	local function stepFunc(inputObject, step)
		if not interactable then return end

		if inputObject ~= nil and inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and 
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad2 and
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad3 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad4 and 
			inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end

		if usesSelectedObject() then
			GuiService.SelectedCoreObject = this.SelectorFrame
		end

		local newIndex = step + this.CurrentIndex

		local direction = 0
		if newIndex > this.CurrentIndex then
			direction = 1
		else
			direction = -1
		end

		if newIndex > #this.Selections then
			newIndex = 1
		elseif newIndex < 1 then
			newIndex = #this.Selections
		end

		setSelection(newIndex, direction)
	end

	local guiServiceCon = nil
	local function connectToGuiService()
		guiServiceCon = GuiService.Changed:connect(function(prop)
			if prop == "SelectedCoreObject" then
				if GuiService.SelectedCoreObject == this.SelectorFrame then 
					this.Selections[this.CurrentIndex].TextTransparency = 0
				else
					if GuiService.SelectedCoreObject ~= nil and isAutoSelectButton[GuiService.SelectedCoreObject] then
						if UserInputService.VREnabled and fixSettingsMenuVR then
							this.Selections[this.CurrentIndex].TextTransparency = 0
						else
							GuiService.SelectedCoreObject = this.SelectorFrame
						end
					else
						this.Selections[this.CurrentIndex].TextTransparency = 0.5
					end
				end
			end
		end)
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex, 1)
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Selections do
			this.Selections[i].ZIndex = newZIndex
		end
	end

	function this:SetInteractable(value)
		interactable = value
		this.SelectorFrame.Selectable = interactable
		if not interactable then
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.new(49/255, 49/255, 49/255)
			end
		else
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.new(1, 1, 1)
			end
		end
	end

	--------------------- SETUP -----------------------
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		local vrEnabled = UserInputService.VREnabled
		leftButton.Selectable = vrEnabled
		rightButton.Selectable = vrEnabled
		autoSelectButton.Selectable = vrEnabled
	end
	if fixSettingsMenuVR then
		UserInputService.Changed:connect(onVREnabled)
		onVREnabled("VREnabled")
	end

	leftButton.InputBegan:connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, -1) 
		end
	end)
	leftButton.MouseButton1Click:connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, -1) 
		end
	end)
	rightButton.InputBegan:connect(function(inputObject) 
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, 1)
		end
	end)
	rightButton.MouseButton1Click:connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, 1) 
		end
	end)

	local isInTree = true

	UserInputService.InputBegan:connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		if GuiService.SelectedCoreObject ~= this.SelectorFrame then return end

		if inputObject.KeyCode == Enum.KeyCode.DPadLeft or inputObject.KeyCode == Enum.KeyCode.Left or inputObject.KeyCode == Enum.KeyCode.A then
			stepFunc(inputObject, -1)
		elseif inputObject.KeyCode == Enum.KeyCode.DPadRight or inputObject.KeyCode == Enum.KeyCode.Right or inputObject.KeyCode == Enum.KeyCode.D then
			stepFunc(inputObject, 1)
		end
	end)

	UserInputService.InputChanged:connect(function(inputObject)
		if not interactable then return end
		if not isInTree then lastInputDirection = 0 return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end

		if fixSettingsMenuVR then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SelectorFrame.Parent) then return end
		else
			if GuiService.SelectedCoreObject ~= this.SelectorFrame then return end
		end

		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end


		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			stepFunc(inputObject, lastInputDirection)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			stepFunc(inputObject, lastInputDirection)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	this.SelectorFrame.AncestryChanged:connect(function(child, parent)
		isInTree = parent
		if not isInTree then
			if guiServiceCon then guiServiceCon:disconnect() end
		else
			connectToGuiService()
		end
	end)

	connectToGuiService()

	return this
end

local function ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	local parent = CoreGui.RobloxGui	
	if parent:FindFirstChild("AlertViewFullScreen") then return end

	--Declare AlertViewBacking so onVREnabled can take it as an upvalue
	local AlertViewBacking = nil

	--Handle VR toggle while alert is open
	--Future consideration: maybe rebuild gui when VR toggles mid-game; right now only subpaneling is handled rather than visual style
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then return end
		local Panel3D, settingsPanel = nil, nil
		if UserInputService.VREnabled then
			Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			settingsPanel = Panel3D.Get("SettingsMenu")
			parent = settingsPanel:GetGUI()
		else
			parent = CoreGui.RobloxGui
		end
		if AlertViewBacking and AlertViewBacking.Parent ~= nil then
			AlertViewBacking.Parent = parent
			if fixSettingsMenuVR and UserInputService.VREnabled then
				settingsPanel:SetSubpanelDepth(AlertViewBacking, 0.5)
			end
		end
	end
	local vrEnabledConn = nil
	if fixSettingsMenuVR then
		vrEnabledConn = UserInputService.Changed:connect(onVREnabled)
	end

	local NON_SELECTED_TEXT_COLOR = Color3.new(59/255, 166/255, 241/255)
	local SELECTED_TEXT_COLOR = Color3.new(1,1,1)

	AlertViewBacking = Util.Create'ImageLabel'
	{
		Name = "AlertViewBacking",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,
		
		ImageTransparency = 1,
		Size = UDim2.new(0, 400, 0, 350),
		Position = UDim2.new(0.5, -200, 0.5, -175),
		ZIndex = 9,
		Parent = parent
	};
	onVREnabled("VREnabled")
	if hasBackground or UserInputService.VREnabled then 
		AlertViewBacking.ImageTransparency = 0
	else
		AlertViewBacking.Size = UDim2.new(0.8, 0, 0, 350)
		AlertViewBacking.Position = UDim2.new(0.1, 0, 0.1, 0)
	end

	if CoreGui.RobloxGui.AbsoluteSize.Y <= AlertViewBacking.Size.Y.Offset then
		AlertViewBacking.Size = UDim2.new(AlertViewBacking.Size.X.Scale, AlertViewBacking.Size.X.Offset, 
											AlertViewBacking.Size.Y.Scale, CoreGui.RobloxGui.AbsoluteSize.Y)
		AlertViewBacking.Position = UDim2.new(0.5, -AlertViewBacking.Size.X.Offset/2, 0.5, -AlertViewBacking.Size.Y.Offset/2)
	end

	local AlertViewText = Util.Create'TextLabel'
	{
		Name = "AlertViewText",
		BackgroundTransparency = 1,
		Size = UDim2.new(0.95, 0, 0.6, 0),
		Position = UDim2.new(0.025, 0, 0.05, 0),
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size36,
		Text = alertMessage,
		TextWrapped = true,
		TextColor3 = Color3.new(1,1,1),
		TextXAlignment = Enum.TextXAlignment.Center,
		TextYAlignment = Enum.TextYAlignment.Center,
		ZIndex = 10,
		Parent = AlertViewBacking
	};

	local SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1
	};

	local removeId = HttpService:GenerateGUID(false)

	local destroyAlert = function(actionName, inputState)
		if fixSettingsMenuVR and UserInputService.VREnabled and (inputState == Enum.UserInputState.Begin or inputState == Enum.UserInputState.Cancel) then
			return
		end
		if fixSettingsMenuVR and UserInputService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(AlertViewBacking, 0)
		end
		AlertViewBacking:Destroy()
		AlertViewBacking = nil
		if okPressedFunc then
			okPressedFunc()
		end
		ContextActionService:UnbindCoreAction(removeId)
		Game.GuiService.SelectedCoreObject = nil
		if settingsHub then
			settingsHub:ShowBar()
		end
		if vrEnabledConn then
			vrEnabledConn:disconnect()
		end
	end

	local AlertViewButtonSize = UDim2.new(1, -20, 0, 60)
	local AlertViewButtonPosition = UDim2.new(0, 10, 0.65, 0)
	if not hasBackground then 
		AlertViewButtonSize = UDim2.new(0, 200, 0, 50)
		AlertViewButtonPosition = UDim2.new(0.5, -100, 0.65, 0)
	end

	local AlertViewButton, AlertViewText = MakeButton("AlertViewButton", okButtonText, AlertViewButtonSize, destroyAlert)
	AlertViewButton.Position = AlertViewButtonPosition
	AlertViewButton.NextSelectionLeft = AlertViewButton
	AlertViewButton.NextSelectionRight = AlertViewButton
	AlertViewButton.NextSelectionUp = AlertViewButton
	AlertViewButton.NextSelectionDown = AlertViewButton
	AlertViewButton.ZIndex = fixSettingsMenuVR and 9 or 10
	AlertViewText.ZIndex = AlertViewButton.ZIndex
	AlertViewButton.Parent = AlertViewBacking

	if usesSelectedObject() then
		Game.GuiService.SelectedCoreObject = AlertViewButton
	end

	GuiService.SelectedCoreObject = AlertViewButton

	ContextActionService:BindCoreAction(removeId, destroyAlert, false, Enum.KeyCode.Escape, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonA)

	if settingsHub and (not fixSettingsMenuVR or not UserInputService.VREnabled) then
		settingsHub:HideBar()
		settingsHub.Pages.CurrentPage:Hide(1, 1)
	end
end

local function CreateNewSlider(numOfSteps, startStep, minStep)
	-------------------- SETUP ------------------------
	local this = {}

	local spacing = 4
	local initialSpacing = 8
	local steps = tonumber(numOfSteps)
	local currentStep = startStep

	local lastInputDirection = 0
	local timeAtLastInput = nil

	local interactable = true

	local renderStepBindName = HttpService:GenerateGUID(false)

	-- this is done to prevent using these values below (trying to keep the variables consistent)
	numOfSteps = ""
	startStep = ""

	if steps <= 0 then
		error("CreateNewSlider failed because numOfSteps (first arg) is 0 or negative, please supply a positive integer")
		return
	end

	local valueChangedEvent = Instance.new("BindableEvent")
	valueChangedEvent.Name = "ValueChanged"

	----------------- GUI SETUP ------------------------
	this.SliderFrame = Util.Create'ImageButton'
	{
		Name = "Slider",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SliderFrame,
		NextSelectionRight = this.SliderFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,502,0,50),
		SelectionImageObject = noSelectionObject,
		ZIndex = 2
	};
	if isSmallTouchScreen() then
		this.SliderFrame.Size = UDim2.new(0,400,0,30)
	end

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(0,0,0.5,-25),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(1,-50,0.5,-25),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(1,-24,0.5,-15),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Left.png",
		ZIndex = 4,
		Parent = leftButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		Position = UDim2.new(0,6,0.5,-15),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Right.png",
		ZIndex = 4,
		Parent = rightButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	if not UserInputService.TouchEnabled and fixSettingsMenuVR then
		local onNormalButtonState, onHoverButtonState = 
			function(instance) instance.ImageColor3 = ARROW_COLOR end,
			function(instance) instance.ImageColor3 = ARROW_COLOR_HOVER end

		addHoverState(leftButton, leftButtonImage, onNormalButtonState, onHoverButtonState)
		addHoverState(rightButton, rightButtonImage, onNormalButtonState, onHoverButtonState)
	end

	this.Steps = {}
	local stepXSize = 35
	if isSmallTouchScreen() then
		stepXSize = 25
	end

	for i = 1, steps do
		local nextStep = Util.Create'ImageButton'
		{
			Name = "Step" .. tostring(i),
			BackgroundColor3 = SELECTED_COLOR,
			BackgroundTransparency = 0.36,
			BorderSizePixel = 0,
			AutoButtonColor = false,
			Active = false,
			Position = UDim2.new(0,initialSpacing + leftButton.Size.X.Offset + ((stepXSize + spacing) * (i - 1)),0.5,-12),
			Size =  UDim2.new(0,stepXSize,0, 24),
			Image =  "",
			ZIndex = 3,
			Selectable = false,
			ImageTransparency = 0.36,
			Parent = this.SliderFrame,
			SelectionImageObject = noSelectionObject
		};

		if i > currentStep then
			nextStep.BackgroundColor3 = NON_SELECTED_COLOR
		end

		if i == 1 or i == steps then
			nextStep.BackgroundTransparency = 1
			nextStep.ScaleType = Enum.ScaleType.Slice
			nextStep.SliceCenter = Rect.new(3,3,32,21)

			if i <= currentStep then
				if i == 1 then
					nextStep.Image = SELECTED_LEFT_IMAGE
				else
					nextStep.Image = SELECTED_RIGHT_IMAGE
				end
			else
				if i == 1 then
					nextStep.Image = NON_SELECTED_LEFT_IMAGE
				else
					nextStep.Image = NON_SELECTED_RIGHT_IMAGE
				end
			end
		end

		this.Steps[#this.Steps + 1] = nextStep
	end

	local xSize = initialSpacing + (leftButton.Size.X.Offset) + this.Steps[#this.Steps].Size.X.Offset + 
					this.Steps[#this.Steps].Position.X.Offset
	this.SliderFrame.Size = UDim2.new(0, xSize, 0, this.SliderFrame.Size.Y.Offset)


	------------------- FUNCTIONS ---------------------
	local function hideSelection()
		for i = 1, steps do
			this.Steps[i].BackgroundColor3 = NON_SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = NON_SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = NON_SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function showSelection()
		for i = 1, steps do
			if i > currentStep then break end
			this.Steps[i].BackgroundColor3 = SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function modifySelection(alpha)
		for i = 1, steps do
			if i == 1 or i == steps then
				this.Steps[i].ImageTransparency = alpha
			else
				this.Steps[i].BackgroundTransparency = alpha
			end
		end
	end

	local function setCurrentStep(newStepPosition)
		if not minStep then minStep = 0 end
		
		leftButton.Visible = true
		rightButton.Visible = true

		if newStepPosition <= minStep then 
			newStepPosition = minStep 
			leftButton.Visible = false
		end
		if newStepPosition >= steps then
			newStepPosition = steps
			rightButton.Visible = false
		end

		if currentStep == newStepPosition then return end

		currentStep = newStepPosition

		hideSelection()
		showSelection()

		timeAtLastInput = tick()
		valueChangedEvent:Fire(currentStep)
	end

	local function isActivateEvent(inputObject)
		if not inputObject then return false end
		if fixSettingsMenuVR then
			return inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch or (inputObject.UserInputType == Enum.UserInputType.Gamepad1 and inputObject.KeyCode == Enum.KeyCode.ButtonA)
		else
			--I don't want to change the logical statement that is known to be working, so this is left in its less concise state
			if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and inputObject.UserInputType ~= Enum.UserInputType.Touch then 
				return false 
			else
				return true
			end
		end
		return false
	end
	local function mouseDownFunc(inputObject, newStepPos, repeatAction)
		if not interactable then return end

		if inputObject == nil then return end
			
		if not isActivateEvent(inputObject) then return end

		if usesSelectedObject() and not UserInputService.VREnabled then
			GuiService.SelectedCoreObject = this.SliderFrame
		end

		if not UserInputService.VREnabled then
			if repeatAction then
				lastInputDirection = newStepPos - currentStep
			else
				lastInputDirection = 0

				local mouseInputMovedCon = nil
				local mouseInputEndedCon = nil

				mouseInputMovedCon = UserInputService.InputChanged:connect(function(inputObject)
					if inputObject.UserInputType ~= Enum.UserInputType.MouseMovement then return end

					local mousePos = inputObject.Position.X
					for i = 1, steps do
						local stepPosition = this.Steps[i].AbsolutePosition.X
						local stepSize = this.Steps[i].AbsoluteSize.X
						if mousePos >= stepPosition and mousePos <= stepPosition + stepSize then
							setCurrentStep(i)
							break
						elseif i == 1 and mousePos < stepPosition then
							setCurrentStep(0)
							break
						elseif i == steps and mousePos >= stepPosition then
							setCurrentStep(i)
							break
						end
					end
				end)
				mouseInputEndedCon = UserInputService.InputEnded:connect(function(inputObject)
					if not isActivateEvent(inputObject) then return end

					lastInputDirection = 0
					mouseInputEndedCon:disconnect()
					mouseInputMovedCon:disconnect()
				end)
			end
		else
			lastInputDirection = 0
		end

		setCurrentStep(newStepPos)
	end

	local function mouseUpFunc(inputObject)
		if not interactable then return end
		if not isActivateEvent(inputObject) then return end

		lastInputDirection = 0
	end

	local function touchClickFunc(inputObject, newStepPos, repeatAction)
		mouseDownFunc(inputObject, newStepPos, repeatAction)
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.ValueChanged = valueChangedEvent.Event

	function this:SetValue(newValue)
		setCurrentStep(newValue)
	end

	function this:GetValue()
		return currentStep
	end

	function this:SetInteractable(value)
		lastInputDirection = 0
		interactable = value
		this.SliderFrame.Selectable = value
		if not interactable then
			hideSelection()
		else
			showSelection()
		end
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Steps do
			this.Steps[i].ZIndex = newZIndex
		end
	end

	function this:SetMinStep(newMinStep)
		if newMinStep >= 0 and newMinStep <= steps then
			minStep = newMinStep
		end

		if currentStep <= minStep then 
			currentStep = minStep 
			leftButton.Visible = false
		end
		if currentStep >= steps then
			currentStep = steps
			rightButton.Visible = false
		end
	end

	--------------------- SETUP -----------------------

	leftButton.InputBegan:connect(function(inputObject) mouseDownFunc(inputObject, currentStep - 1, true) end)
	leftButton.InputEnded:connect(function(inputObject) mouseUpFunc(inputObject) end)
	rightButton.InputBegan:connect(function(inputObject) mouseDownFunc(inputObject, currentStep + 1, true) end)
	rightButton.InputEnded:connect(function(inputObject) mouseUpFunc(inputObject) end)

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if UserInputService.VREnabled then
			leftButton.Selectable = interactable
			rightButton.Selectable = interactable
			this.SliderFrame.Selectable = interactable

			for i = 1, steps do
				this.Steps[i].Selectable = interactable
				this.Steps[i].Active = interactable
			end
		else
			leftButton.Selectable = false
			rightButton.Selectable = false
			this.SliderFrame.Selectable = interactable
			for i = 1, steps do
				this.Steps[i].Selectable = false
				this.Steps[i].Active = false
			end
		end
	end
	if fixSettingsMenuVR then
		UserInputService.Changed:connect(onVREnabled)
		onVREnabled("VREnabled")
	end

	for i = 1, steps do
		this.Steps[i].InputBegan:connect(function(inputObject) 
			mouseDownFunc(inputObject, i) 
		end)
		this.Steps[i].InputEnded:connect(function(inputObject)
		 mouseUpFunc(inputObject) end)
	end

	this.SliderFrame.InputBegan:connect(function(inputObject) 
		if fixSettingsMenuVR and UserInputService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end 
		end
		mouseDownFunc(inputObject, currentStep) 
	end)
	this.SliderFrame.InputEnded:connect(function(inputObject) 
		if fixSettingsMenuVR and UserInputService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end 
		end
		mouseUpFunc(inputObject) 
	end)


	local stepSliderFunc = function()
		if timeAtLastInput == nil then return end

		local currentTime = tick()
		local timeSinceLastInput = currentTime - timeAtLastInput
		if timeSinceLastInput >= CONTROLLER_SCROLL_DELTA then
			setCurrentStep(currentStep + lastInputDirection)
		end
	end

	local isInTree = true

	local navigateLeft = -1 --these are just for differentiation, the actual value isn't important as long as they coerce to boolean true (all numbers do in Lua)
	local navigateRight = 1
	local navigationKeyCodes = {
		[Enum.KeyCode.Thumbstick1] = true, --thumbstick can be either direction
		[Enum.KeyCode.DPadLeft] = navigateLeft,
		[Enum.KeyCode.DPadRight] = navigateRight,
		[Enum.KeyCode.Left] = navigateLeft,
		[Enum.KeyCode.Right] = navigateRight,
		[Enum.KeyCode.A] = navigateLeft,
		[Enum.KeyCode.D] = navigateRight,
		[Enum.KeyCode.ButtonA] = fixSettingsMenuVR --buttonA can be either direction
	}
	UserInputService.InputBegan:connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if fixSettingsMenuVR then
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end 
		else
			if selected ~= this.SliderFrame then return end
		end

		if navigationKeyCodes[inputObject.KeyCode] == navigateLeft then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif navigationKeyCodes[inputObject.KeyCode] == navigateRight then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		end
	end)

	UserInputService.InputEnded:connect(function(inputObject)
		if not interactable then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if fixSettingsMenuVR then
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end 
		else
			if selected ~= this.SliderFrame then return end
		end

		if navigationKeyCodes[inputObject.KeyCode] then --detect any keycode considered a navigation key
			lastInputDirection = 0
		end
	end)

	UserInputService.InputChanged:connect(function(inputObject)
		if not interactable then 
			lastInputDirection = 0
			return 
		end
		if not isInTree then
			lastInputDirection = 0
			return 
		end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end
		local selected = GuiService.SelectedCoreObject
		if fixSettingsMenuVR then
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end 
		else
			if selected ~= this.SliderFrame then return end
		end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end

		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	local isBound = false
	GuiService.Changed:connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end

		local selected = GuiService.SelectedCoreObject
		local isThisSelected = fixSettingsMenuVR and (selected and selected:IsDescendantOf(this.SliderFrame.Parent)) or selected == this.SliderFrame
		if isThisSelected then
			modifySelection(0)
			if not isBound then
				isBound = true
				timeAtLastInput = tick()
				RunService:BindToRenderStep(renderStepBindName, Enum.RenderPriority.Input.Value + 1, stepSliderFunc)
			end
		else
			modifySelection(0.36)
			if isBound then
				isBound = false
				RunService:UnbindFromRenderStep(renderStepBindName)
			end
		end
	end)

	this.SliderFrame.AncestryChanged:connect(function(child, parent)
		isInTree = parent
	end)

	setCurrentStep(currentStep)

	return this
end

local ROW_HEIGHT = 50
if isTenFootInterface() then ROW_HEIGHT = 90 end

local nextPosTable = {}
local function AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	local nextRowPositionY = 0
	local isARealRow = selectionType ~= 'TextBox' -- Textboxes are constructed in this function - they don't have an associated class.

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = nil
	RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "",
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};

	if RowFrame and extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
										RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	local RowLabel = nil
	RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size24,
		TextColor3 = Color3.new(1,1,1),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};
	if isTenFootInterface() then
		RowLabel.FontSize = Enum.FontSize.Size36
	end
	if not isARealRow then
		RowLabel.Text = ''
	end

	local ValueChangerSelection = nil
	local ValueChangerInstance = nil
	if selectionType == "Slider" then
		ValueChangerInstance = CreateNewSlider(rowValues, rowDefault)	
		ValueChangerInstance.SliderFrame.Position = UDim2.new(1,-ValueChangerInstance.SliderFrame.Size.X.Offset,
														0.5,-ValueChangerInstance.SliderFrame.Size.Y.Offset/2)
		ValueChangerInstance.SliderFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SliderFrame
	elseif selectionType == "Selector" then
		ValueChangerInstance = CreateSelector(rowValues, rowDefault)
		ValueChangerInstance.SelectorFrame.Position = UDim2.new(1,-ValueChangerInstance.SelectorFrame.Size.X.Offset,
														0.5,-ValueChangerInstance.SelectorFrame.Size.Y.Offset/2)
		ValueChangerInstance.SelectorFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SelectorFrame
	elseif selectionType == "DropDown" then
		ValueChangerInstance = CreateDropDown(rowValues, rowDefault, pageToAddTo.HubRef)
		ValueChangerInstance.DropDownFrame.Position = UDim2.new(1,-ValueChangerInstance.DropDownFrame.Size.X.Offset - 50,
														0.5,-ValueChangerInstance.DropDownFrame.Size.Y.Offset/2)
		ValueChangerInstance.DropDownFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.DropDownFrame
	elseif selectionType == "TextBox" then
		local isMouseOverRow = false
		local forceReturnSelectionOnFocusLost = false
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			Size = UDim2.new(1,-10,0,100),
			Position = UDim2.new(0,5,0,nextRowPositionY),
			Text = rowDisplayName,
			TextColor3 = Color3.new(49/255, 49/255, 49/255),
			BackgroundTransparency = 0.5,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Top,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextWrapped = true,
			Font = Enum.Font.SourceSans,
			FontSize = Enum.FontSize.Size24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = pageToAddTo.Page
		};
		ValueChangerSelection = box

		box.Focused:connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		box.FocusLost:connect(function(enterPressed, inputObject)
			if GuiService.SelectedCoreObject == box and (not isMouseOverRow or forceReturnSelectionOnFocusLost) then
				GuiService.SelectedCoreObject = nil
			end
			forceReturnSelectionOnFocusLost = false
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
										box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.1

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.5
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
				isMouseOverRow = true
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						forceReturnSelectionOnFocusLost = true
						box:CaptureFocus()
					end
				end
			end
		end
		RowFrame.MouseEnter:connect(setRowSelection)
		RowFrame.Size = UDim2.new(1, 0, 0, 100)

		UserInputService.InputBegan:connect(processInput)

	elseif selectionType == "TextEntry" then
		local isMouseOverRow = false
		local forceReturnSelectionOnFocusLost = false
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			Size = UDim2.new(0.4,-10,0,40),
			Position = UDim2.new(0.5,5,0,nextRowPositionY+5),
			Text = rowDisplayName,
			TextColor3 = Color3.new(0.7, 0.7, 0.7),
			BackgroundTransparency = 1.0,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Center,
			TextXAlignment = Enum.TextXAlignment.Center,
			TextWrapped = false,
			Font = Enum.Font.SourceSans,
			FontSize = Enum.FontSize.Size24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = pageToAddTo.Page
		};
		ValueChangerSelection = box

		box.Focused:connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		box.FocusLost:connect(function(enterPressed, inputObject)
			if GuiService.SelectedCoreObject == box and (not isMouseOverRow or forceReturnSelectionOnFocusLost) then
				GuiService.SelectedCoreObject = nil
			end
			forceReturnSelectionOnFocusLost = false
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
										box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.8

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 1.0
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
				isMouseOverRow = true
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						forceReturnSelectionOnFocusLost = true
						box:CaptureFocus()
					end
				end
			end
		end
		RowFrame.MouseEnter:connect(setRowSelection)

		function ValueChangerInstance:SetZIndex(newZIndex)
			box.ZIndex = newZIndex
		end

		function ValueChangerInstance:SetInteractable(value)
			interactable = value
			box.Selectable = interactable
			if not interactable then
				box.TextColor3 = Color3.new(49/255, 49/255, 49/255)
				box.ZIndex = 1
			else
				box.TextColor3 = Color3.new(0.7, 0.7, 0.7)
				box.ZIndex = 2
			end
		end

		function ValueChangerInstance:SetValue(value) -- should this do more?
			box.Text = value
		end

		local valueChangedEvent = Instance.new("BindableEvent")
		valueChangedEvent.Name = "ValueChanged"

		box.FocusLost:connect(function() 
			valueChangedEvent:Fire(box.Text)
		end)

		ValueChangerInstance.ValueChanged = valueChangedEvent.Event

		UserInputService.InputBegan:connect(processInput)
	end

	ValueChangerInstance.Name = rowDisplayName .. "ValueChanger"

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	if isARealRow then
		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerInstance.SliderFrame 
			if not valueFrame then
				valueFrame = ValueChangerInstance.SliderFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.DropDownFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.SelectorFrame
			end

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
			end
		end
		RowFrame.MouseEnter:connect(setRowSelection)

		--Could this be cleaned up even more?
		local function onVREnabled(prop)
			if prop == "VREnabled" then
				if UserInputService.VREnabled then
					RowFrame.Selectable = true
					RowFrame.Active = true
					ValueChangerSelection.Active = true
					GuiService.Changed:connect(function(prop)
						if prop == "SelectedCoreObject" then
							local selected = GuiService.SelectedCoreObject
							if selected and (selected == RowFrame or selected:IsDescendantOf(RowFrame)) then
								RowFrame.BackgroundTransparency = 0.5
							else
								RowFrame.BackgroundTransparency = 1
							end
						end
					end)
				else
					RowFrame.Selectable = false
					RowFrame.Active = false
				end
			end
		end
		if fixSettingsMenuVR then
			UserInputService.Changed:connect(onVREnabled)
			onVREnabled("VREnabled")
		end

		ValueChangerSelection.SelectionGained:connect(function()
			if usesSelectedObject() then
				RowFrame.BackgroundTransparency = 0.5

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(RowFrame)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:connect(function()
			if usesSelectedObject() then
				RowFrame.BackgroundTransparency = 1
			end
		end)
	end

	pageToAddTo:AddRow(RowFrame, RowLabel, ValueChangerInstance, extraSpacing, false)

	ValueChangerInstance.Selection = ValueChangerSelection

	return RowFrame, RowLabel, ValueChangerInstance
end

local function AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	local nextRowPositionY = 0

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "",
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};
	RowFrame.SelectionGained:connect(function()
		RowFrame.BackgroundTransparency = 0.5
	end)
	RowFrame.SelectionLost:connect(function()
		RowFrame.BackgroundTransparency = 1
	end)

	local RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size24,
		TextColor3 = Color3.new(1,1,1),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};
	if isTenFootInterface() then
		RowLabel.FontSize = Enum.FontSize.Size36
	end

	if extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
										RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	local setRowSelection = function()
		if RowFrame.Visible then
			GuiService.SelectedCoreObject = RowFrame
		end
	end
	RowFrame.MouseEnter:connect(setRowSelection)

	rowObject.SelectionImageObject = noSelectionObject

	rowObject.SelectionGained:connect(function()
			RowFrame.BackgroundTransparency = 0.5
		end)
	rowObject.SelectionLost:connect(function()
		RowFrame.BackgroundTransparency = 1
	end)

	rowObject.Parent = RowFrame

	pageToAddTo:AddRow(RowFrame, RowLabel, rowObject, extraSpacing, true)
	return RowFrame
end

-------- public facing API ----------------
local moduleApiTable = {}

function moduleApiTable:Create(instanceType)
	return function(data)
		local obj = Instance.new(instanceType)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

-- RayPlaneIntersection (shortened)
-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
function moduleApiTable:RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	planeNormal = planeNormal.unit
	ray = ray.Unit

	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end
	
	return ray.Origin + ray.Direction * t
end

function moduleApiTable:GetEaseLinear()
	return Linear
end
function moduleApiTable:GetEaseOutQuad()
	return EaseOutQuad
end
function moduleApiTable:GetEaseInOutQuad()
	return EaseInOutQuad
end

function moduleApiTable:CreateNewSlider(numOfSteps, startStep, minStep)
	return CreateNewSlider(numOfSteps, startStep, minStep)
end

function moduleApiTable:CreateNewSelector(selectionStringTable, startPosition)
	return CreateSelector(selectionStringTable, startPosition)
end

function moduleApiTable:CreateNewDropDown(dropDownStringTable, startPosition)
	return CreateDropDown(dropDownStringTable, startPosition, nil)
end

function moduleApiTable:AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	return AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
end

function moduleApiTable:AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	return AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
end

function moduleApiTable:ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
end

function moduleApiTable:IsSmallTouchScreen()
	return isSmallTouchScreen()
end

function moduleApiTable:MakeStyledButton(name, text, size, clickFunc, pageRef, hubRef)
	return MakeButton(name, text, size, clickFunc, pageRef, hubRef)
end

function moduleApiTable:CreateSignal()
	return CreateSignal()
end

function  moduleApiTable:UsesSelectedObject()
	return usesSelectedObject();
end

function moduleApiTable:TweenProperty(instance, prop, start, final, duration, easingFunc, cbFunc)
	return PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
end

return moduleApiTable
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8B5CD5B81EB34C9CAEAFEAA82A9D7D79">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsPageFactory</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
		Filename: SettingsPageFactory.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Base Page Functionality for all Settings Pages
--]]
----------------- SERVICES ------------------------------
local GuiService = game:GetService("GuiService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")

local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)
local StyleWidgets = require(RobloxGui.Modules.StyleWidgets)


----------- VARIABLES --------------
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()

----------- CONSTANTS --------------
local HEADER_SPACING = 5
if utility:IsSmallTouchScreen() then
	HEADER_SPACING = 0
end

----------- CLASS DECLARATION --------------
local function Initialize()
	local this = {}
	this.HubRef = nil
	this.LastSelectedObject = nil
	this.TabPosition = 0
	this.Active = false
	this.OpenStateChangedCount = 0
	local rows = {}
	local displayed = false

	------ TAB CREATION -------
	this.TabHeader = utility:Create'TextButton'
	{
		Name = "Header",
		Text = "",
		BackgroundTransparency = 1,
		Size = UDim2.new(0,169,1,0),
		Position = UDim2.new(0.5,0,0,0)
	};
	if utility:IsSmallTouchScreen() then
		this.TabHeader.Size = UDim2.new(0,84,1,0)
	elseif isTenFootInterface then
		this.TabHeader.Size = UDim2.new(0,220,1,0)
	end
	this.TabHeader.MouseButton1Click:connect(function()
		if this.HubRef then
			this.HubRef:SwitchToPage(this, true)
		end
	end)

	local icon = utility:Create'ImageLabel'
	{
		Name = "Icon",
		BackgroundTransparency = 1,
		Size = UDim2.new(0,44,0,37),
		Position = UDim2.new(0,10,0.5,-18),
		Image = "",
		ImageTransparency = 0.5,
		Parent = this.TabHeader
	};

	local title = utility:Create'TextLabel'
	{
		Name = "Title",
		Text = "Change Me",
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size24,
		TextColor3 = Color3.new(1,1,1),
		BackgroundTransparency = 1,
		Size = UDim2.new(1.05,0,1,0),
		Position = UDim2.new(1.2,0,0,0),
		TextXAlignment = Enum.TextXAlignment.Left,
		TextTransparency = 0.5,
		Parent = icon
	};
	if utility:IsSmallTouchScreen() then
		title.FontSize = Enum.FontSize.Size18
	elseif isTenFootInterface then
		title.FontSize = Enum.FontSize.Size48
	end

	local tabSelection = StyleWidgets.MakeTabSelectionWidget(this.TabHeader)
 
	------ PAGE CREATION -------
	this.Page = utility:Create'Frame'
	{
		Name = "Page",
		BackgroundTransparency = 1,
		Size = UDim2.new(1,0,1,0)
	};

	-- make sure each page has a unique selection group (for gamepad selection)
	GuiService:AddSelectionParent(HttpService:GenerateGUID(false), this.Page)

	----------------- Events ------------------------

	this.Displayed = Instance.new("BindableEvent")
	this.Displayed.Name = "Displayed"
	
	this.Displayed.Event:connect(function()
		if not this.HubRef.Shield.Visible then return end

		this:SelectARow()
	end)

	this.Hidden = Instance.new("BindableEvent")
	this.Hidden.Event:connect(function()
		if GuiService.SelectedCoreObject and GuiService.SelectedCoreObject:IsDescendantOf(this.Page) then
			GuiService.SelectedCoreObject = nil
		end
	end)
	this.Hidden.Name = "Hidden"

	----------------- FUNCTIONS ------------------------
	function this:SelectARow(forced) -- Selects the first row or the most recently selected row
		if forced or not GuiService.SelectedCoreObject or not GuiService.SelectedCoreObject:IsDescendantOf(this.Page) then
			if this.LastSelectedObject then
				GuiService.SelectedCoreObject = this.LastSelectedObject
			else
				if rows and #rows > 0 then
					local valueChangerFrame = nil

					if type(rows[1].ValueChanger) ~= "table" then
						valueChangerFrame = rows[1].ValueChanger
					else
						valueChangerFrame = rows[1].ValueChanger.SliderFrame and 
													rows[1].ValueChanger.SliderFrame or rows[1].ValueChanger.SelectorFrame
					end
					GuiService.SelectedCoreObject = valueChangerFrame
				end
			end
		end
	end

	function this:Display(pageParent, skipAnimation)
		this.OpenStateChangedCount = this.OpenStateChangedCount + 1

		if this.TabHeader then
			this.TabHeader.TabSelection.Visible = true
			this.TabHeader.Icon.ImageTransparency = 0
			this.TabHeader.Icon.Title.TextTransparency = 0
		end

		this.Page.Parent = pageParent
		this.Page.Visible = true

		local endPos = UDim2.new(0,0,0,0)
		local animationComplete = function()
			this.Page.Visible = true
			displayed = true
			this.Displayed:Fire()
		end
		if skipAnimation then
			this.Page.Position = endPos
			animationComplete()
		else
			this.Page:TweenPosition(endPos, Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.1, true, animationComplete)
		end
	end
	function this:Hide(direction, newPagePos, skipAnimation, delayBeforeHiding)
		this.OpenStateChangedCount = this.OpenStateChangedCount + 1

		if this.TabHeader then
			this.TabHeader.TabSelection.Visible = false
			this.TabHeader.Icon.ImageTransparency = 0.5
			this.TabHeader.Icon.Title.TextTransparency = 0.5
		end

		if this.Page.Parent then
			local endPos = UDim2.new(1 * direction,0,0,0)
			local animationComplete = function()
				this.Page.Visible = false
				this.Page.Position = UDim2.new(this.TabPosition - newPagePos,0,0,0)
				displayed = false
				this.Hidden:Fire()
			end

			local remove = function()
				if skipAnimation then
					this.Page.Position = endPos
					animationComplete()
				else
					this.Page:TweenPosition(endPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.1, true, animationComplete)
				end
			end

			if delayBeforeHiding then
				local myOpenStateChangedCount = this.OpenStateChangedCount
				delay(delayBeforeHiding, function()
					if myOpenStateChangedCount == this.OpenStateChangedCount then
						remove()
					end
				end)
			else
				remove()
			end
		end
	end

	function this:GetDisplayed()
		return displayed
	end

	function this:GetVisibility()
		return this.Page.Parent
	end

	function this:GetTabHeader()
		return this.TabHeader
	end

	function this:SetHub(hubRef)
		this.HubRef = hubRef

		for i, row in next, rows do
			if type(row.ValueChanger) == 'table' then
				row.ValueChanger.HubRef = this.HubRef
			end
		end
	end

	function this:GetSize()
		return this.Page.AbsoluteSize
	end

	function this:AddRow(RowFrame, RowLabel, ValueChangerInstance, ExtraRowSpacing)
		rows[#rows + 1] = {SelectionFrame = RowFrame, Label = RowLabel, ValueChanger = ValueChangerInstance}

		local rowFrameYSize = 0
		if RowFrame then 
			rowFrameYSize = RowFrame.Size.Y.Offset
		end

		if ExtraRowSpacing then
			this.Page.Size = UDim2.new(1, 0, 0, this.Page.Size.Y.Offset + rowFrameYSize + ExtraRowSpacing)
		else
			this.Page.Size = UDim2.new(1, 0, 0, this.Page.Size.Y.Offset + rowFrameYSize)
		end

		if this.HubRef and type(ValueChangerInstance) == 'table' then
			ValueChangerInstance.HubRef = this.HubRef
		end
	end

	return this
end


-------- public facing API ----------------
local moduleApiTable = {}

function moduleApiTable:CreateNewPage()
	return Initialize()
end

return moduleApiTable]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX05069C68C79541619F02BE741E2E57CE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsHub</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
        Filename: SettingsHub.lua
        Written by: jeditkacheff
        Version 1.0
        Description: Controls the settings menu navigation and contains the settings pages
--]]

--[[ CONSTANTS ]]
local SETTINGS_SHIELD_COLOR = Color3.new(41/255,41/255,41/255)
local SETTINGS_SHIELD_TRANSPARENCY = 0.2
local SETTINGS_SHIELD_VR_TRANSPARENCY = 1
local SETTINGS_SHIELD_SIZE = UDim2.new(1, 0, 1, 0)
local SETTINGS_SHIELD_INACTIVE_POSITION = UDim2.new(0,0,-1,-36)
local SETTINGS_SHIELD_ACTIVE_POSITION = UDim2.new(0, 0, 0, 0)
local SETTINGS_BASE_ZINDEX = 2
local DEV_CONSOLE_ACTION_NAME = "Open Dev Console"
local QUICK_PROFILER_ACTION_NAME = "Show Quick Profiler"

--[[ SERVICES ]]
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local StarterGui = game:GetService("StarterGui")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

--[[ UTILITIES ]]
local utility = require(RobloxGui.Modules.Settings.Utility)
local VRHub = require(RobloxGui.Modules.VR.VRHub)

--[[ VARIABLES ]]
local isTouchDevice = UserInputService.TouchEnabled
local isSmallTouchScreen = utility:IsSmallTouchScreen()
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()
local platform = UserInputService:GetPlatform()

local DeveloperConsoleModule = require(RobloxGui.Modules.DeveloperConsoleModule)

local lastInputChangedCon = nil
local chatWasVisible = false
local userlistSuccess, userlistFlagValue = pcall(function() return settings():GetFFlag("UseUserListMenu") end)
local useUserList = (userlistSuccess and userlistFlagValue == true)

local resetButtonFlagSuccess, resetButtonFlagValue = pcall(function() return settings():GetFFlag("AllowResetButtonCustomization") end)
local resetButtonCustomizationAllowed = (resetButtonFlagSuccess and resetButtonFlagValue == true)

local function IsPlayMyPlaceEnabled()
  if UserInputService:GetPlatform() == Enum.Platform.XBoxOne then
    local playMyPlaceSuccess, playMyPlaceFlagValue = pcall(function() return settings():GetFFlag("XboxPlayMyPlace") end)
    return (playMyPlaceSuccess and playMyPlaceFlagValue == true)
  end
  return false
end


--[[ CORE MODULES ]]
local chat = require(RobloxGui.Modules.ChatSelector)

if isSmallTouchScreen or isTenFootInterface then
  SETTINGS_SHIELD_ACTIVE_POSITION = UDim2.new(0,0,0,0)
  SETTINGS_SHIELD_SIZE = UDim2.new(1,0,1,0)
end

local function CreateSettingsHub()
  local this = {}
  this.Visible = false
  this.Active = false
  this.Pages = {CurrentPage = nil, PageTable = {}}
  this.MenuStack = {}
  this.TabHeaders = {}
  this.BottomBarButtons = {}
  this.TabConnection = nil
  this.LeaveGamePage = require(RobloxGui.Modules.Settings.Pages.LeaveGame)
  this.ResetCharacterPage = require(RobloxGui.Modules.Settings.Pages.ResetCharacter)
  this.SettingsShowSignal = utility:CreateSignal()
  this.OpenStateChangedCount = 0

  local pageChangeCon = nil

  local PoppedMenuEvent = Instance.new("BindableEvent")
  PoppedMenuEvent.Name = "PoppedMenu"
  this.PoppedMenu = PoppedMenuEvent.Event

  local function setBottomBarBindings()
    for i = 1, #this.BottomBarButtons do
      local buttonTable = this.BottomBarButtons[i]
      local buttonName = buttonTable[1]
      local hotKeyTable = buttonTable[2]
      ContextActionService:BindCoreAction(buttonName, hotKeyTable[1], false, unpack(hotKeyTable[2]))
    end

    if this.BottomButtonFrame then
      this.BottomButtonFrame.Visible = true
    end
  end

  local function removeBottomBarBindings(delayBeforeRemoving)
    for _, hotKeyTable in pairs(this.BottomBarButtons) do
      ContextActionService:UnbindCoreAction(hotKeyTable[1])
    end

    local myOpenStateChangedCount = this.OpenStateChangedCount
    local remove = function()
      if this.OpenStateChangedCount == myOpenStateChangedCount and this.BottomButtonFrame then
        this.BottomButtonFrame.Visible = false
      end
    end

    if delayBeforeRemoving then
      delay(delayBeforeRemoving, remove)
    else
      remove()
    end
  end

  local function addBottomBarButton(name, text, gamepadImage, keyboardImage, position, clickFunc, hotkeys)
    local buttonName = name .. "Button"
    local textName = name .. "Text"

    local size = UDim2.new(0,260,0,70)
    if isTenFootInterface then
      size = UDim2.new(0,320,0,120)
    end

    this[buttonName], this[textName] = utility:MakeStyledButton(name .. "Button", text, size, clickFunc, nil, this)
    this[buttonName].Position = position
    this[buttonName].Parent = this.BottomButtonFrame
    if isTenFootInterface then
      this[buttonName].ImageTransparency = 1
    end

    this[textName].FontSize = Enum.FontSize.Size24
    local hintLabel = nil

    if not isTouchDevice then
      this[textName].Size = UDim2.new(1,0,1,0)
      if isTenFootInterface then
        this[textName].Position = UDim2.new(0,60,0,-4)
      else
        this[textName].Position = UDim2.new(0,10,0,-4)
      end

      local hintNameText = name .. "HintText"
      local hintName = name .. "Hint"
      local image = ""
      if UserInputService:GetGamepadConnected(Enum.UserInputType.Gamepad1) or platform == Enum.Platform.XBoxOne then
        image = gamepadImage
      else
        image = keyboardImage
      end

      hintLabel = utility:Create'ImageLabel'
      {
        Name = hintName,
        Size = UDim2.new(0,60,0,60),
        Position = UDim2.new(0,10,0,5),
        ZIndex = this.Shield.ZIndex + 2,
        BackgroundTransparency = 1,
        Image = image,
        Parent = this[buttonName]
      };
      if isTenFootInterface then
        hintLabel.Size = UDim2.new(0,90,0,90)
        hintLabel.Position = UDim2.new(0,10,0.5,-45)
      elseif UserInputService.MouseEnabled then
        hintLabel.Image = keyboardImage
        hintLabel.Size = UDim2.new(0,48,0,48)
        hintLabel.Position = UDim2.new(0,10,0,8)
      end
    end

    if isTenFootInterface then
      this[textName].FontSize = Enum.FontSize.Size36
    end

    UserInputService.InputBegan:connect(function(inputObject)
        if inputObject.UserInputType == Enum.UserInputType.Gamepad1 or inputObject.UserInputType == Enum.UserInputType.Gamepad2 or
        inputObject.UserInputType == Enum.UserInputType.Gamepad3 or inputObject.UserInputType == Enum.UserInputType.Gamepad4 then
          if hintLabel then
            hintLabel.Image = gamepadImage
            if isTenFootInterface then
              hintLabel.Size = UDim2.new(0,90,0,90)
              hintLabel.Position = UDim2.new(0,10,0.5,-45)
            else
              hintLabel.Size = UDim2.new(0,60,0,60)
              hintLabel.Position = UDim2.new(0,10,0,5)
            end
          end
        elseif inputObject.UserInputType == Enum.UserInputType.Keyboard then
          if hintLabel then
            hintLabel.Image = keyboardImage
            hintLabel.Size = UDim2.new(0,48,0,48)
            hintLabel.Position = UDim2.new(0,10,0,8)
          end
        end
      end)

    local hotKeyFunc = function(contextName, inputState, inputObject)
      if inputState == Enum.UserInputState.Begin then
        clickFunc()
      end
    end

    local hotKeyTable = {hotKeyFunc, hotkeys}
    this.BottomBarButtons[#this.BottomBarButtons + 1] = {buttonName, hotKeyTable}
  end

  local function createGui()
    local PageViewSizeReducer = 0
    if isSmallTouchScreen then
      PageViewSizeReducer = 5
    end

    this.ClippingShield = utility:Create'Frame'
    {
      Name = "SettingsShield",
      Size = SETTINGS_SHIELD_SIZE,
      Position = SETTINGS_SHIELD_ACTIVE_POSITION,
      BorderSizePixel = 0,
      ClipsDescendants = true,
      BackgroundTransparency = 1,
      Visible = true,
      ZIndex = SETTINGS_BASE_ZINDEX,
      Parent = RobloxGui
    };

    this.Shield = utility:Create'Frame'
    {
      Name = "SettingsShield",
      Size = UDim2.new(1,0,1,0),
      Position = SETTINGS_SHIELD_INACTIVE_POSITION,
      BackgroundTransparency = SETTINGS_SHIELD_TRANSPARENCY,
      BackgroundColor3 = SETTINGS_SHIELD_COLOR,
      BorderSizePixel = 0,
      Visible = false,
      Active = true,
      ZIndex = SETTINGS_BASE_ZINDEX,
      Parent = this.ClippingShield
    };
    this.VRShield = utility:Create("Frame") {
      Name = "VRBackground",
      Parent = this.Shield,

      BackgroundColor3 = SETTINGS_SHIELD_COLOR,
      BackgroundTransparency = SETTINGS_SHIELD_TRANSPARENCY,
      Position = UDim2.new(0, -4, 0, 24),
      Size = UDim2.new(1, 8, 1, -40),
      BorderSizePixel = 0,

      Visible = false
    }

    this.Modal = utility:Create'TextButton' -- Force unlocks the mouse, really need a way to do this via UIS
    {
      Name = 'Modal',
      BackgroundTransparency = 1,
      Position = UDim2.new(0, 0, 1, -1),
      Size = UDim2.new(1, 0, 1, 0),
      Modal = true,
      Text = '',
      Parent = this.Shield,
      Selectable = false
    }

    this.HubBar = utility:Create'ImageLabel'
    {
      Name = "HubBar",
      ZIndex = this.Shield.ZIndex + 1,
      BorderSizePixel = 0,
      BackgroundColor3 = Color3.new(78/255, 84/255, 96/255),
      BackgroundTransparency = 1,
      Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuBackground.png",
      ScaleType = Enum.ScaleType.Slice,
      SliceCenter = Rect.new(4,4,6,6),
      Parent = this.Shield
    };

    local barHeight = 60
    if isSmallTouchScreen then
      barHeight = 40
      this.HubBar.Size = UDim2.new(1,-10,0,40)
      this.HubBar.Position = UDim2.new(0,5,0,6)
    elseif isTenFootInterface then
      barHeight = 100
      this.HubBar.Size = UDim2.new(0,1200,0,100)
      this.HubBar.Position = UDim2.new(0.5,-600,0.1,0)
    else
      this.HubBar.Size = UDim2.new(0,800,0,60)
      this.HubBar.Position = UDim2.new(0.5,-400,0.1,0)
    end

    this.PageViewClipper = utility:Create'Frame'
    {
      Name = 'PageViewClipper',
      BackgroundTransparency = 1,
      Size = UDim2.new(this.HubBar.Size.X.Scale,this.HubBar.Size.X.Offset,
        1, -this.HubBar.Size.Y.Offset - this.HubBar.Position.Y.Offset - PageViewSizeReducer),
      Position = UDim2.new(this.HubBar.Position.X.Scale, this.HubBar.Position.X.Offset,
        this.HubBar.Position.Y.Scale, this.HubBar.Position.Y.Offset + this.HubBar.Size.Y.Offset + 1),
      ClipsDescendants = true,
      Parent = this.Shield,

      utility:Create'ImageButton'{
        Name = 'InputCapture',
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 1, 0),
        Image = ''
      }
    }

    this.PageView = utility:Create'ScrollingFrame'
    {
      Name = "PageView",
      Size = UDim2.new(1, 0, 1, 0),
      ZIndex = this.Shield.ZIndex,
      BackgroundTransparency = 1,
      BorderSizePixel = 0,
      Selectable = false,
      Parent = this.PageViewClipper,
    };
    if UserInputService.MouseEnabled then
      this.PageViewClipper.Size = UDim2.new(this.HubBar.Size.X.Scale,this.HubBar.Size.X.Offset,
        0.5, -(this.HubBar.Position.Y.Offset - this.HubBar.Size.Y.Offset))
    end

    if isSmallTouchScreen then
      this.PageView.CanvasSize = this.PageViewClipper.Size
    else
      local bottomOffset = 0
      if isTouchDevice and not UserInputService.MouseEnabled then
        bottomOffset = 80
      end
      this.BottomButtonFrame = utility:Create'Frame'
      {
        Name = "BottomButtonFrame",
        Size = this.HubBar.Size,
        Position = UDim2.new(0.5, -this.HubBar.Size.X.Offset/2, 1-this.HubBar.Position.Y.Scale-this.HubBar.Size.Y.Scale, -this.HubBar.Position.Y.Offset-this.HubBar.Size.Y.Offset),
        ZIndex = this.Shield.ZIndex + 1,
        BackgroundTransparency = 1,
        Parent = this.Shield
      };

      local leaveGameFunc = function()
        this:AddToMenuStack(this.Pages.CurrentPage)
        this.HubBar.Visible = false
        removeBottomBarBindings()
        this:SwitchToPage(this.LeaveGamePage, nil, 1, true)
      end
      
      local resetEnabled = true
      local function setResetEnabled(value)
        resetEnabled = value
        if this.ResetCharacterButton then
          this.ResetCharacterButton.Selectable = value
          this.ResetCharacterButton.Active = value
          this.ResetCharacterButton.Enabled.Value = value
          local resetHint = this.ResetCharacterButton:FindFirstChild("ResetCharacterHint")
          if resetHint then
            resetHint.ImageColor3 = (value and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(100, 100, 100))
          end
          local resetButtonText = this.ResetCharacterButton:FindFirstChild("ResetCharacterButtonTextLabel")
          if resetButtonText then
            resetButtonText.TextColor3 = (value and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(100, 100, 100))
          end
        end
      end
      
      local resetCharFunc = function()
        if resetEnabled then
          this:AddToMenuStack(this.Pages.CurrentPage)
          this.HubBar.Visible = false
          removeBottomBarBindings()
          this:SwitchToPage(this.ResetCharacterPage, nil, 1, true)
        end
      end

      if resetButtonCustomizationAllowed then
        StarterGui:RegisterSetCore("ResetButtonCallback", function(callback)
          local isBindableSuccess, isBindableValue = pcall(function() return type(callback) == "userdata" and callback:IsA("BindableEvent") end)
          local isBindable = (isBindableSuccess and isBindableValue)
          if isBindable or type(callback) == "boolean" then
            this.ResetCharacterPage:SetResetCallback(callback)
          else
            warn("ResetButtonCallback must be set to a BindableEvent or a boolean")
          end
          if callback == false then
            setResetEnabled(false)
          elseif not resetEnabled and (isBindable or callback == true) then
            setResetEnabled(true)
          end
        end)
      end
     
      -- Xbox Only
      local inviteToGameFunc = function()
        local platformService = game:GetService('PlatformService')
        if platformService then
          platformService:PopupGameInviteUI()
        end
      end

      local resumeFunc = function()
        setVisibilityInternal(false)
      end

      local buttonImageAppend = ""

      if isTenFootInterface then
        buttonImageAppend = "@2x"
      end

      if UserInputService:GetPlatform() == Enum.Platform.XBoxOne then
        local function createInviteButton()
          addBottomBarButton("InviteToGame", "Send Game Invites", "rbxasset://textures/ui/Settings/Help/XButtonLight" .. buttonImageAppend .. ".png",
            "", UDim2.new(0.5,isTenFootInterface and -160 or -130,0.5,-25),
            inviteToGameFunc, {Enum.KeyCode.ButtonX})
        end

        if IsPlayMyPlaceEnabled() then
          spawn(function()
              local PlatformService = nil
              pcall(function() PlatformService = game:GetService('PlatformService') end)
              local pmpCreatorId = PlatformService and PlatformService:BeginGetPMPCreatorId()
              if pmpCreatorId == 0 then
                createInviteButton()
              end
            end)
        else
          createInviteButton()
        end
      else
        addBottomBarButton("LeaveGame", "Leave Game", "rbxasset://textures/ui/Settings/Help/XButtonLight" .. buttonImageAppend .. ".png",
          "rbxasset://textures/ui/Settings/Help/LeaveIcon.png", UDim2.new(0.5,isTenFootInterface and -160 or -130,0.5,-25),
          leaveGameFunc, {Enum.KeyCode.L, Enum.KeyCode.ButtonX})
      end

      addBottomBarButton("ResetCharacter", "    Reset Character", "rbxasset://textures/ui/Settings/Help/YButtonLight" .. buttonImageAppend .. ".png",
        "rbxasset://textures/ui/Settings/Help/ResetIcon.png", UDim2.new(0.5,isTenFootInterface and -550 or -400,0.5,-25),
        resetCharFunc, {Enum.KeyCode.R, Enum.KeyCode.ButtonY})
      addBottomBarButton("Resume", "Resume Game", "rbxasset://textures/ui/Settings/Help/BButtonLight" .. buttonImageAppend .. ".png",
        "rbxasset://textures/ui/Settings/Help/EscapeIcon.png", UDim2.new(0.5,isTenFootInterface and 200 or 140,0.5,-25),
        resumeFunc, {Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonStart})
    end

    local function onScreenSizeChanged()
      local largestPageSize = 600
      local fullScreenSize = RobloxGui.AbsoluteSize.y
      local bufferSize = (1-0.95) * fullScreenSize
      if isTenFootInterface then
        largestPageSize = 800
        bufferSize = 0.07 * fullScreenSize
      elseif isSmallTouchScreen then
        bufferSize = (1-0.99) * fullScreenSize
      end
      local barSize = this.HubBar.Size.Y.Offset
      local extraSpace = bufferSize*2+barSize*2


      local usableScreenHeight = fullScreenSize - extraSpace
      local minimumPageSize = 150
      local usePageSize = nil

      if largestPageSize < usableScreenHeight then
        usePageSize = largestPageSize
        this.HubBar.Position = UDim2.new(
          this.HubBar.Position.X.Scale,
          this.HubBar.Position.X.Offset,
          0.5,
          -largestPageSize/2 - this.HubBar.Size.Y.Offset
        )
        if this.BottomButtonFrame then
          this.BottomButtonFrame.Position = UDim2.new(
            this.BottomButtonFrame.Position.X.Scale,
            this.BottomButtonFrame.Position.X.Offset,
            0.5,
            largestPageSize/2
          )
        end
      elseif usableScreenHeight < minimumPageSize then
        usePageSize = minimumPageSize
        this.HubBar.Position = UDim2.new(
          this.HubBar.Position.X.Scale,
          this.HubBar.Position.X.Offset,
          0.5,
          -minimumPageSize/2 - this.HubBar.Size.Y.Offset
        )
        if this.BottomButtonFrame then
          this.BottomButtonFrame.Position = UDim2.new(
            this.BottomButtonFrame.Position.X.Scale,
            this.BottomButtonFrame.Position.X.Offset,
            0.5,
            minimumPageSize/2
          )
        end
      else
        usePageSize = usableScreenHeight
        this.HubBar.Position = UDim2.new(
          this.HubBar.Position.X.Scale,
          this.HubBar.Position.X.Offset,
          0,
          bufferSize
        )
        if this.BottomButtonFrame then
          this.BottomButtonFrame.Position = UDim2.new(
            this.BottomButtonFrame.Position.X.Scale,
            this.BottomButtonFrame.Position.X.Offset,
            1,
            -(bufferSize + barSize)
          )
        end
      end

      if useUserList and not isTenFootInterface then
        if isSmallTouchScreen then
          this.PageViewClipper.Size = UDim2.new(
            this.PageViewClipper.Size.X.Scale,
            this.PageViewClipper.Size.X.Offset,
            0,
            usePageSize + 44
          )
        else
          this.PageViewClipper.Size = UDim2.new(
            this.PageViewClipper.Size.X.Scale,
            this.PageViewClipper.Size.X.Offset,
            0,
            usePageSize
          )
        end
      else
        this.PageViewClipper.Size = UDim2.new(
          this.PageViewClipper.Size.X.Scale,
          this.PageViewClipper.Size.X.Offset,
          0,
          usePageSize
        )
      end
      this.PageViewClipper.Position = UDim2.new(
        this.PageViewClipper.Position.X.Scale,
        this.PageViewClipper.Position.X.Offset,
        0.5,
        -usePageSize/2
      )
    end
    -- TODO: disconnect this event?
    RobloxGui.Changed:connect(function(prop)
        if prop == "AbsoluteSize" then
          onScreenSizeChanged()
        end
      end)
    onScreenSizeChanged()
  end

  local function toggleQuickProfilerFromHotkey(actionName, inputState, inputObject) 
    -- Make sure it's Ctrl-F7.
    -- NOTE: This will only work if FFlagDontSwallowInputForStudioShortcuts is True.
    -- Otherwise, we never get the "Begin" input state when Ctrl key is down.
    if (not (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or 
        UserInputService:IsKeyDown(Enum.KeyCode.RightControl))) then
      return
    end
    
    if actionName ==QUICK_PROFILER_ACTION_NAME then
      if inputState and inputState == Enum.UserInputState.Begin then
        GameSettings.PerformanceStatsVisible = not GameSettings.PerformanceStatsVisible
      end
    end
  end

  local function toggleDevConsole(actionName, inputState, inputObject)
    if actionName == DEV_CONSOLE_ACTION_NAME then   -- ContextActionService->F9
      if inputState and inputState == Enum.UserInputState.Begin then
        local devConsoleVisible = DeveloperConsoleModule:GetVisibility()
        DeveloperConsoleModule:SetVisibility(not devConsoleVisible)
      end
    end
  end

  local lastInputUsedToSelectGui = isTenFootInterface
  UserInputService.InputBegan:connect(function(input)
      if input.UserInputType == Enum.UserInputType.Gamepad1 or input.UserInputType == Enum.UserInputType.Gamepad2 or input.UserInputType == Enum.UserInputType.Gamepad3 or input.UserInputType == Enum.UserInputType.Gamepad4
      or input.KeyCode == Enum.KeyCode.Left or input.KeyCode == Enum.KeyCode.Right or input.KeyCode == Enum.KeyCode.Up or input.KeyCode == Enum.KeyCode.Down or input.KeyCode == Enum.KeyCode.Tab then
        lastInputUsedToSelectGui = true
      elseif input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 then
        lastInputUsedToSelectGui = false
      end
    end)
  UserInputService.InputChanged:connect(function(input)
      if input.KeyCode == Enum.KeyCode.Thumbstick1 or input.KeyCode == Enum.KeyCode.Thumbstick2 then
        if input.Position.magnitude >= 0.25 then
          lastInputUsedToSelectGui = true
        end
      elseif input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
        lastInputUsedToSelectGui = false
      end
    end)


  local switchTab = function(direction, cycle)
    local currentTabPosition = GetHeaderPosition(this.Pages.CurrentPage)
    if currentTabPosition < 0 then return end

    local newTabPosition = currentTabPosition + direction
    if cycle then
      if newTabPosition > #this.TabHeaders then
        newTabPosition = 1
      elseif newTabPosition < 1 then
        newTabPosition = #this.TabHeaders
      end
    end
    local newHeader = this.TabHeaders[newTabPosition]

    if newHeader then
      for pager,v in pairs(this.Pages.PageTable) do
        if pager:GetTabHeader() == newHeader then
          this:SwitchToPage(pager, true, direction)
          break
        end
      end
    end
  end

  local switchTabFromBumpers = function(actionName, inputState, inputObject)
    if inputState ~= Enum.UserInputState.Begin then return end

    local direction = 0
    if inputObject.KeyCode == Enum.KeyCode.ButtonR1 then
      direction = 1
    elseif inputObject.KeyCode == Enum.KeyCode.ButtonL1 then
      direction = -1
    end

    switchTab(direction, true, true)
  end

  local switchTabFromKeyboard = function(input)
    if input.KeyCode == Enum.KeyCode.Tab then
      local direction = 0
      if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift) then
        direction = -1
      else
        direction = 1
      end

      switchTab(direction, true, true)
    end
  end

  local scrollHotkeyFunc = function(actionName, inputState, inputObject)
    if inputState ~= Enum.UserInputState.Begin then return end

    local direction = 0
    if inputObject.KeyCode == Enum.KeyCode.PageUp then
      direction = -100
    elseif inputObject.KeyCode == Enum.KeyCode.PageDown then
      direction = 100
    end

    this:ScrollPixels(direction)
  end

  -- need some stuff for functions below so init here
  createGui()

  function GetHeaderPosition(page)
    local header = page:GetTabHeader()
    if not header then return -1 end

    for i,v in pairs(this.TabHeaders) do
      if v == header then
        return i
      end
    end

    return -1
  end

  local setZIndex = nil
  setZIndex = function(newZIndex, object)
    if object:IsA("GuiObject") then
      object.ZIndex = newZIndex
      local children = object:GetChildren()
      for i = 1, #children do
        setZIndex(newZIndex, children[i])
      end
    end
  end

  local function AddHeader(newHeader, headerPage)
    if not newHeader then return end

    this.TabHeaders[#this.TabHeaders + 1] = newHeader
    headerPage.TabPosition = #this.TabHeaders

    local sizeOfTab = 1/#this.TabHeaders
    for i = 1, #this.TabHeaders do
      local tabMaxPos = (sizeOfTab * i)
      local tabMinPos = (sizeOfTab * (i - 1))
      local pos = ((tabMaxPos - tabMinPos)/2) + tabMinPos

      local tab = this.TabHeaders[i]
      tab.Position = UDim2.new(pos,-tab.Size.X.Offset/2,0,0)
    end

    setZIndex(SETTINGS_BASE_ZINDEX + 1, newHeader)
    newHeader.Parent = this.HubBar
  end

  local function RemoveHeader(oldHeader)
    local removedPos = nil

    for i = 1, #this.TabHeaders do
      if this.TabHeaders[i] == oldHeader then
        removedPos = i
        table.remove(this.TabHeaders, i)
        break
      end
    end

    if removedPos then
      for i = removedPos, #this.TabHeaders do
        local currentTab = this.TabHeaders[i]
        currentTab.Position = UDim2.new(currentTab.Position.X.Scale, currentTab.Position.X.Offset - oldHeader.AbsoluteSize.X,
          currentTab.Position.Y.Scale, currentTab.Position.Y.Offset)
      end
    end

    oldHeader.Parent = nil
  end

  -- Page APIs
  function this:AddPage(pageToAdd)
    this.Pages.PageTable[pageToAdd] = true
    AddHeader(pageToAdd:GetTabHeader(), pageToAdd)
    pageToAdd.Page.Position = UDim2.new(pageToAdd.TabPosition - 1,0,0,0)
  end

  function this:RemovePage(pageToRemove)
    this.Pages.PageTable[pageToRemove] = nil
    RemoveHeader(pageToRemove:GetTabHeader())
  end

  function this:HideBar()
    this.HubBar.Visible = false
    this.PageViewClipper.Visible = false
    if this.BottomButtonFrame then
      removeBottomBarBindings()
    end
  end

  function this:ShowBar()
    this.HubBar.Visible = true
    this.PageViewClipper.Visible = true
    if this.BottomButtonFrame then
      setBottomBarBindings()
    end
  end

  function this:ScrollPixels(pixels)
    -- Only Y
    local oldY = this.PageView.CanvasPosition.Y
    local maxY = this.PageView.CanvasSize.Y.Offset - this.PageViewClipper.AbsoluteSize.y
    local newY = math.max(0, math.min(oldY+pixels, maxY)) -- i.e. clamp
    this.PageView.CanvasPosition = Vector2.new(0, newY)
  end

  function this:ScrollToFrame(frame, forced)
    if lastInputUsedToSelectGui or forced then
      local ay = frame.AbsolutePosition.y - this.Pages.CurrentPage.Page.AbsolutePosition.y
      local by = ay + frame.AbsoluteSize.y

      if ay < this.PageView.CanvasPosition.y then -- Scroll up to fit top
        this.PageView.CanvasPosition = Vector2.new(0, ay)
      elseif by - this.PageView.CanvasPosition.y > this.PageViewClipper.Size.Y.Offset then -- Scroll down to fit bottom
        this.PageView.CanvasPosition = Vector2.new(0, by - this.PageViewClipper.Size.Y.Offset)
      end
    end
  end

  function this:SwitchToPage(pageToSwitchTo, ignoreStack, direction, skipAnimation)
    if this.Pages.PageTable[pageToSwitchTo] == nil then return end

    -- detect direction
    if direction == nil then
      if this.Pages.CurrentPage and this.Pages.CurrentPage.TabHeader and pageToSwitchTo and pageToSwitchTo.TabHeader then
        direction = this.Pages.CurrentPage.TabHeader.AbsolutePosition.x < pageToSwitchTo.TabHeader.AbsolutePosition.x and 1 or -1
      end
    end
    if direction == nil then
      direction = 1
    end

    -- if we have a page we need to let it know to go away
    if this.Pages.CurrentPage then
      pageChangeCon:disconnect()
      this.Pages.CurrentPage.Active = false
    end

    -- make sure all pages are in right position
    local newPagePos = pageToSwitchTo.TabPosition
    for page, _ in pairs(this.Pages.PageTable) do
      if page ~= pageToSwitchTo then
        page:Hide(-direction, newPagePos, skipAnimation)
      end
    end

    if this.BottomButtonFrame then
      this.BottomButtonFrame.Visible = (pageToSwitchTo ~= this.ResetCharacterPage and pageToSwitchTo ~= this.LeaveGamePage)
      this.HubBar.Visible = this.BottomButtonFrame.Visible
    end

    -- make sure page is visible
    this.Pages.CurrentPage = pageToSwitchTo
    this.Pages.CurrentPage:Display(this.PageView, skipAnimation)
    this.Pages.CurrentPage.Active = true

    local pageSize = this.Pages.CurrentPage:GetSize()
    this.PageView.CanvasSize = UDim2.new(0,pageSize.X,0,pageSize.Y)

    pageChangeCon = this.Pages.CurrentPage.Page.Changed:connect(function(prop)
        if prop == "AbsoluteSize" then
          local pageSize = this.Pages.CurrentPage:GetSize()
          this.PageView.CanvasSize = UDim2.new(0,pageSize.X,0,pageSize.Y)
        end
      end)

    if this.MenuStack[#this.MenuStack] ~= this.Pages.CurrentPage and not ignoreStack then
      this.MenuStack[#this.MenuStack + 1] = this.Pages.CurrentPage
    end
  end

  function this:SetActive(active)
    this.Active = active

    if this.Pages.CurrentPage then
      this.Pages.CurrentPage.Active = active
    end
  end

  function clearMenuStack()
    while this.MenuStack and #this.MenuStack > 0 do
      this:PopMenu()
    end
  end

  function setOverrideMouseIconBehavior()
    pcall(function()
        if UserInputService:GetLastInputType() == Enum.UserInputType.Gamepad1 then
          UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.ForceHide
        else
          UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.ForceShow
        end
      end)
  end

  function setVisibilityInternal(visible, noAnimation, customStartPage)
    this.OpenStateChangedCount = this.OpenStateChangedCount + 1
    local switchedFromGamepadInput = switchedFromGamepadInput or isTenFootInterface
    this.Visible = visible


    this.Modal.Visible = this.Visible

    if this.TabConnection then
      this.TabConnection:disconnect()
      this.TabConnection = nil
    end

    local playerList = require(RobloxGui.Modules.PlayerlistModule)

    if this.Visible then
      this.SettingsShowSignal:fire(this.Visible)

      pcall(function() GuiService:SetMenuIsOpen(true) end)
      this.Shield.Visible = this.Visible
      if noAnimation or not this.Shield:IsDescendantOf(game) then
        this.Shield.Position = SETTINGS_SHIELD_ACTIVE_POSITION
      else
        this.Shield:TweenPosition(SETTINGS_SHIELD_ACTIVE_POSITION, Enum.EasingDirection.InOut, Enum.EasingStyle.Quart, 0.5, true)
      end

      local noOpFunc = function() end
      ContextActionService:BindCoreAction("RbxSettingsHubStopCharacter", noOpFunc, false,
        Enum.PlayerActions.CharacterForward,
        Enum.PlayerActions.CharacterBackward,
        Enum.PlayerActions.CharacterLeft,
        Enum.PlayerActions.CharacterRight,
        Enum.PlayerActions.CharacterJump,
        Enum.KeyCode.LeftShift,
        Enum.KeyCode.RightShift,
        Enum.KeyCode.Tab,
        Enum.UserInputType.Gamepad1, Enum.UserInputType.Gamepad2, Enum.UserInputType.Gamepad3, Enum.UserInputType.Gamepad4)

      ContextActionService:BindCoreAction("RbxSettingsHubSwitchTab", switchTabFromBumpers, false, Enum.KeyCode.ButtonR1, Enum.KeyCode.ButtonL1)
      ContextActionService:BindCoreAction("RbxSettingsScrollHotkey", scrollHotkeyFunc, false, Enum.KeyCode.PageUp, Enum.KeyCode.PageDown)
      setBottomBarBindings()

      this.TabConnection = UserInputService.InputBegan:connect(switchTabFromKeyboard)


      setOverrideMouseIconBehavior()
      pcall(function() lastInputChangedCon = UserInputService.LastInputTypeChanged:connect(setOverrideMouseIconBehavior) end)
      if UserInputService.MouseEnabled then
        pcall(function()
            UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.ForceShow
          end)
      end

      if customStartPage then
        removeBottomBarBindings()
        this:SwitchToPage(customStartPage, nil, 1, true)
      else
        if useUserList and not isTenFootInterface then
          this:SwitchToPage(this.PlayersPage, nil, 1, true)
        else
          if this.HomePage then
            this:SwitchToPage(this.HomePage, nil, 1, true)
          else
            this:SwitchToPage(this.GameSettingsPage, nil, 1, true)
          end
        end
      end

      playerList:HideTemp('SettingsMenu', true)

      if chat:GetVisibility() then
        chatWasVisible = true
        chat:ToggleVisibility()
      end

      local backpack = require(RobloxGui.Modules.BackpackScript)
      if backpack.IsOpen then
        backpack:OpenClose()
      end
    else
      if noAnimation then
        this.Shield.Position = SETTINGS_SHIELD_INACTIVE_POSITION
        this.Shield.Visible = this.Visible
        this.SettingsShowSignal:fire(this.Visible)
        pcall(function() GuiService:SetMenuIsOpen(false) end)
      else
        this.Shield:TweenPosition(SETTINGS_SHIELD_INACTIVE_POSITION, Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.4, true, function()
            this.Shield.Visible = this.Visible
            this.SettingsShowSignal:fire(this.Visible)
            if not this.Visible then pcall(function() GuiService:SetMenuIsOpen(false) end) end
          end)
      end

      if lastInputChangedCon then
        lastInputChangedCon:disconnect()
      end

      playerList:HideTemp('SettingsMenu', false)

      if chatWasVisible then
        chat:ToggleVisibility()
        chatWasVisible = false
      end

      pcall(function() UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.None end)

      clearMenuStack()
      ContextActionService:UnbindCoreAction("RbxSettingsHubSwitchTab")
      ContextActionService:UnbindCoreAction("RbxSettingsHubStopCharacter")
      ContextActionService:UnbindCoreAction("RbxSettingsScrollHotkey")
      removeBottomBarBindings(0.4)

      GuiService.SelectedCoreObject = nil
    end
  end

  function this:SetVisibility(visible, noAnimation, customStartPage, switchedFromGamepadInput)
    if this.Visible == visible then return end

    setVisibilityInternal(visible, noAnimation, customStartPage, switchedFromGamepadInput)
  end

  function this:ToggleVisibility(switchedFromGamepadInput)
    setVisibilityInternal(not this.Visible, nil, nil, switchedFromGamepadInput)
  end

  function this:AddToMenuStack(newItem)
    if this.MenuStack[#this.MenuStack] ~= newItem then
      this.MenuStack[#this.MenuStack + 1] = newItem
    end
  end


  function this:PopMenu(switchedFromGamepadInput, skipAnimation)
    if this.MenuStack and #this.MenuStack > 0 then
      local lastStackItem = this.MenuStack[#this.MenuStack]

      if type(lastStackItem) ~= "table" then
        PoppedMenuEvent:Fire(lastStackItem)
      end

      if lastStackItem == this.LeaveGamePage or lastStackItem == this.ResetCharacterPage then
        setBottomBarBindings()
      end

      table.remove(this.MenuStack, #this.MenuStack)
      this:SwitchToPage(this.MenuStack[#this.MenuStack], true, 1, skipAnimation)
      if #this.MenuStack == 0 then
        this:SetVisibility(false)
        this.Pages.CurrentPage:Hide(0, 0)
      end
    else
      this.MenuStack = {}
      PoppedMenuEvent:Fire()
      this:ToggleVisibility()
    end
  end

  function this:ShowShield()
    this.Shield.BackgroundTransparency = UserInputService.VREnabled and SETTINGS_SHIELD_VR_TRANSPARENCY or SETTINGS_SHIELD_TRANSPARENCY
  end
  function this:HideShield()
    this.Shield.BackgroundTransparency = 1
  end

  local thisModuleName = "SettingsMenu"
  local vrMenuOpened, vrMenuClosed = nil, nil
  local function enableVR()
    local VRHub = require(RobloxGui.Modules.VR.VRHub)
    local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
    local panel = Panel3D.Get(thisModuleName)
    panel:ResizeStuds(4, 4, 200)
    panel:SetType(Panel3D.Type.Fixed)
    panel:SetVisible(false)
    panel:SetCanFade(false)

    this.ClippingShield.Parent = panel:GetGUI()
    this.Shield.Parent.ClipsDescendants = false
    this.VRShield.Visible = true
    this:HideShield()

    vrMenuOpened = this.SettingsShowSignal:connect(function(visible)
        if visible then
          local topbarPanel = Panel3D.Get("Topbar3D")
          panel.localCF = topbarPanel.localCF * CFrame.Angles(math.rad(-5), 0, 0) * CFrame.new(0, 4, 0) * CFrame.Angles(math.rad(-15), 0, 0)
          panel:SetVisible(true)

          VRHub:FireModuleOpened(thisModuleName)
        else
          panel:SetVisible(false)

          VRHub:FireModuleClosed(thisModuleName)
        end
      end)

    VRHub.ModuleOpened.Event:connect(function(moduleName)
        if moduleName ~= thisModuleName then
          this:SetVisibility(false)
        end
      end)
  end
  local function disableVR()
    this.ClippingShield.Parent = RobloxGui
    this.Shield.Parent.ClipsDescendants = true
    this.VRShield.Visible = false
    this:ShowShield()

    if vrMenuOpened then
      vrMenuOpened:disconnect()
      vrMenuOpened = nil
    end
    if vrMenuClosed then
      vrMenuClosed:disconnect()
      vrMenuClosed = nil
    end

    local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
    local panel = Panel3D.Get(thisModuleName)
    panel:SetVisible(false)
  end

  local UISChanged;
  local function OnVREnabled(prop)
    if prop == "VREnabled" then
      if UserInputService.VREnabled then
        enableVR()
      else
        disableVR()
      end
    end
  end
  UISChanged = UserInputService.Changed:connect(OnVREnabled)
  OnVREnabled("VREnabled")


  local closeMenuFunc = function(name, inputState, input)
    if inputState ~= Enum.UserInputState.Begin then return end
    this:PopMenu(false, true)
  end
  ContextActionService:BindCoreAction("RBXEscapeMainMenu", closeMenuFunc, false, Enum.KeyCode.Escape)

  this.ResetCharacterPage:SetHub(this)
  this.LeaveGamePage:SetHub(this)

  -- full page initialization
  if not useUserList then
    if utility:IsSmallTouchScreen() then
      this.HomePage = require(RobloxGui.Modules.Settings.Pages.Home)
      this.HomePage:SetHub(this)
    end
  end

  this.GameSettingsPage = require(RobloxGui.Modules.Settings.Pages.GameSettings)
  this.GameSettingsPage:SetHub(this)

  if platform ~= Enum.Platform.XBoxOne and platform ~= Enum.Platform.PS4 then
    this.ReportAbusePage = require(RobloxGui.Modules.Settings.Pages.ReportAbuseMenu)
    this.ReportAbusePage:SetHub(this)
  end

  this.HelpPage = require(RobloxGui.Modules.Settings.Pages.Help)
  this.HelpPage:SetHub(this)

  if platform == Enum.Platform.Windows then
    this.RecordPage = require(RobloxGui.Modules.Settings.Pages.Record)
    this.RecordPage:SetHub(this)
  end

  if useUserList and not isTenFootInterface then
    this.PlayersPage = require(RobloxGui.Modules.Settings.Pages.Players)
    this.PlayersPage:SetHub(this)
  end

  -- page registration
  if useUserList and not isTenFootInterface then
    this:AddPage(this.PlayersPage)
  end
  this:AddPage(this.ResetCharacterPage)
  this:AddPage(this.LeaveGamePage)
  if not useUserList then
    if this.HomePage then
      this:AddPage(this.HomePage)
    end
  end
  this:AddPage(this.GameSettingsPage)
  if this.ReportAbusePage then
    this:AddPage(this.ReportAbusePage)
  end
  this:AddPage(this.HelpPage)
  if this.RecordPage then
    this:AddPage(this.RecordPage)
  end

  if useUserList and not isTenFootInterface then
    this:SwitchToPage(this.PlayerPage, true, 1)
  else
    if this.HomePage then
      this:SwitchToPage(this.HomePage, true, 1)
    else
      this:SwitchToPage(this.GameSettingsPage, true, 1)
    end
  end
  -- hook up to necessary signals

  -- connect back button on android
  GuiService.ShowLeaveConfirmation:connect(function()
      if #this.MenuStack == 0 then
        this:SetVisibility(true)
        this:SwitchToPage(this.PlayerPage, nil, 1)
      else
        this:PopMenu(false, true)
      end
    end)

  -- Dev Console Connections
  ContextActionService:BindCoreAction(DEV_CONSOLE_ACTION_NAME, 
    toggleDevConsole, 
    false,
    Enum.KeyCode.F9)

  -- Quick Profiler connections
  -- Note: it's actually Ctrl-F7.  We don't have a nice way of 
  -- making that explicit here, so we check it inside toggleQuickProfilerFromHotkey.
  ContextActionService:BindCoreAction(QUICK_PROFILER_ACTION_NAME, 
    toggleQuickProfilerFromHotkey, 
    false,
    Enum.KeyCode.F7)

  -- Keyboard control
  UserInputService.InputBegan:connect(function(input)
      if input.KeyCode == Enum.KeyCode.Left or input.KeyCode == Enum.KeyCode.Right or input.KeyCode == Enum.KeyCode.Up or input.KeyCode == Enum.KeyCode.Down then
        if this.Visible and this.Active then
          if this.Pages.CurrentPage then
            if GuiService.SelectedCoreObject == nil then
              this.Pages.CurrentPage:SelectARow()
            end
          end
        end
      end
    end)

  return this
end


-- Main Entry Point

local moduleApiTable = {}

moduleApiTable.ModuleName = "SettingsMenu"
moduleApiTable.KeepVRTopbarOpen = true
moduleApiTable.VRIsExclusive = true
moduleApiTable.VRClosesNonExclusive = true
VRHub:RegisterModule(moduleApiTable)

VRHub.ModuleOpened.Event:connect(function(moduleName)
    if moduleName ~= moduleApiTable.ModuleName then
      local module = VRHub:GetModule(moduleName)
      if module.VRIsExclusive then
        moduleApiTable:SetVisibility(false)
      end
    end
  end)

local SettingsHubInstance = CreateSettingsHub()

function moduleApiTable:SetVisibility(visible, noAnimation, customStartPage, switchedFromGamepadInput)
  SettingsHubInstance:SetVisibility(visible, noAnimation, customStartPage, switchedFromGamepadInput)
end

function moduleApiTable:ToggleVisibility(switchedFromGamepadInput)
  SettingsHubInstance:ToggleVisibility(switchedFromGamepadInput)
end

function moduleApiTable:SwitchToPage(pageToSwitchTo, ignoreStack)
  SettingsHubInstance:SwitchToPage(pageToSwitchTo, ignoreStack, 1)
end

function moduleApiTable:GetVisibility()
  return SettingsHubInstance.Visible
end

function moduleApiTable:ShowShield()
  SettingsHubInstance:ShowShield()
end

function moduleApiTable:HideShield()
  SettingsHubInstance:HideShield()
end

moduleApiTable.SettingsShowSignal = SettingsHubInstance.SettingsShowSignal

moduleApiTable.Instance = SettingsHubInstance

return moduleApiTable]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX32B049A45BD5498980EF02146C665DFD">
					<Properties>
						<string name="Name">Pages</string>
					</Properties>
					<Item class="ModuleScript" referent="RBXBAA476C5B1C746E1A4724628F3865883">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ReportAbuseMenu</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
		Filename: ReportAbuseMenu.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Takes care of the report abuse page in Settings Menu
--]]

-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local GuiService = game:GetService("GuiService")
local PlayersService = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)

------------ CONSTANTS -------------------
local ABUSE_TYPES_PLAYER = {
	"Swearing",
	"Inappropriate Username",
	"Bullying",
	"Scamming",
	"Dating",
	"Cheating/Exploiting",
	"Personal Question",
	"Offsite Links",
}

local ABUSE_TYPES_GAME = {
	"Inappropriate Content"
}
local DEFAULT_ABUSE_DESC_TEXT = "   Short Description (Optional)"
if utility:IsSmallTouchScreen() then
	DEFAULT_ABUSE_DESC_TEXT = "   (Optional)"
end

------------ VARIABLES -------------------
local PageInstance = nil

----------- CLASS DECLARATION --------------
local function Initialize()
	local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
	local this = settingsPageFactory:CreateNewPage()

	local playerNames = {}
	local nameToRbxPlayer = {}

	function this:GetPlayerFromIndex(index)
		local playerName = playerNames[index]
		if playerName then
			return nameToRbxPlayer[playerName]
		end

		return nil
	end

	function this:UpdatePlayerDropDown()
		playerNames = {}
	    	nameToRbxPlayer = {}

		local players = PlayersService:GetPlayers()
		local index = 1
		for i = 1, #players do
			local player = players[i]
			if player ~= PlayersService.LocalPlayer and player.UserId > 0 then
				playerNames[index] = player.Name
				nameToRbxPlayer[player.Name] = player
				index = index + 1
			end
		end

		this.WhichPlayerMode:UpdateDropDownList(playerNames)
		
		if index == 1 then
			this.GameOrPlayerMode:SetSelectionIndex(1)
			this.TypeOfAbuseMode:UpdateDropDownList(ABUSE_TYPES_GAME)
		else
			this.WhichPlayerLabel.ZIndex = 2
			this.TypeOfAbuseMode:UpdateDropDownList(ABUSE_TYPES_PLAYER)
		end

		this.WhichPlayerMode:SetInteractable(index > 1 and this.GameOrPlayerMode.CurrentIndex ~= 1)
		this.GameOrPlayerMode:SetInteractable(index > 1)
	end

	------ TAB CUSTOMIZATION -------
	this.TabHeader.Name = "ReportAbuseTab"

	this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/ReportAbuseTab.png"
	if utility:IsSmallTouchScreen() then
		this.TabHeader.Icon.Size = UDim2.new(0,27,0,32)
		this.TabHeader.Size = UDim2.new(0,120,1,0)
	else
		this.TabHeader.Size = UDim2.new(0,150,1,0)
		this.TabHeader.Icon.Size = UDim2.new(0,36,0,43)
	end
	this.TabHeader.Icon.Position = UDim2.new(this.TabHeader.Icon.Position.X.Scale, this.TabHeader.Icon.Position.X.Offset + 10, 0.5,-this.TabHeader.Icon.Size.Y.Offset/2)

	this.TabHeader.Icon.Title.Text = "Report"

	------ PAGE CUSTOMIZATION -------
	this.Page.Name = "ReportAbusePage"

	-- need to override this function from SettingsPageFactory
	-- DropDown menus require hub to to be set when they are initialized
	function this:SetHub(newHubRef)
		this.HubRef = newHubRef

		if utility:IsSmallTouchScreen() then
			this.GameOrPlayerFrame, 
			this.GameOrPlayerLabel,
			this.GameOrPlayerMode = utility:AddNewRow(this, "Game or Player?", "Selector", {"Game", "Player"}, 2)
		else
			this.GameOrPlayerFrame, 
			this.GameOrPlayerLabel,
			this.GameOrPlayerMode = utility:AddNewRow(this, "Game or Player?", "Selector", {"Game", "Player"}, 2, 3)
		end

		this.WhichPlayerFrame, 
		this.WhichPlayerLabel,
		this.WhichPlayerMode = utility:AddNewRow(this, "Which Player?", "DropDown", {"update me"})
		this.WhichPlayerMode:SetInteractable(false)
		this.WhichPlayerLabel.ZIndex = 1

		this.TypeOfAbuseFrame, 
		this.TypeOfAbuseLabel,
		this.TypeOfAbuseMode = utility:AddNewRow(this, "Type Of Abuse", "DropDown", ABUSE_TYPES_GAME, 1)

		if utility:IsSmallTouchScreen() then
			this.AbuseDescriptionFrame, 
			this.AbuseDescriptionLabel,
			this.AbuseDescription = utility:AddNewRow(this, DEFAULT_ABUSE_DESC_TEXT, "TextBox", nil, nil)
		else
			this.AbuseDescriptionFrame, 
			this.AbuseDescriptionLabel,
			this.AbuseDescription = utility:AddNewRow(this, DEFAULT_ABUSE_DESC_TEXT, "TextBox", nil, nil, 5)
		end
		
		this.AbuseDescription.Selection.FocusLost:connect(function()
			if this.AbuseDescription.Selection.Text == "" then
				this.AbuseDescription.Selection.Text = DEFAULT_ABUSE_DESC_TEXT
			end
		end)
		
		if utility:IsSmallTouchScreen() then
			this.AbuseDescription.Selection.Size = UDim2.new(0, 290, 0, 30)
			this.AbuseDescription.Selection.Position = UDim2.new(1,-345,this.AbuseDescription.Selection.Position.Y.Scale, this.AbuseDescription.Selection.Position.Y.Offset)

			this.AbuseDescriptionLabel = this.TypeOfAbuseLabel:clone()
			this.AbuseDescriptionLabel.Text = "Abuse Description"
			this.AbuseDescriptionLabel.Position = UDim2.new(this.AbuseDescriptionLabel.Position.X.Scale, this.AbuseDescriptionLabel.Position.X.Offset,
														0,50)
			this.AbuseDescriptionLabel.Parent = this.Page
		end

		local SelectionOverrideObject = utility:Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1
		};

		local submitButton, submitText = nil, nil

		local function makeSubmitButtonActive()
			submitButton.ZIndex = 2
			submitButton.Selectable = true
			submitText.ZIndex = 2
		end

		local function makeSubmitButtonInactive()
			submitButton.ZIndex = 1
			submitButton.Selectable = false
			submitText.ZIndex = 1
		end

		local function updateAbuseDropDown()
			this.WhichPlayerMode:ResetSelectionIndex()
			this.TypeOfAbuseMode:ResetSelectionIndex()

			if this.GameOrPlayerMode.CurrentIndex == 1 then
				this.TypeOfAbuseMode:UpdateDropDownList(ABUSE_TYPES_GAME)
				
				this.TypeOfAbuseMode:SetInteractable(#ABUSE_TYPES_GAME > 1)
				this.TypeOfAbuseLabel.ZIndex = (#ABUSE_TYPES_GAME > 1 and 2 or 1)

				this.WhichPlayerMode:SetInteractable(false)
				this.WhichPlayerLabel.ZIndex = 1
				this.GameOrPlayerMode.SelectorFrame.NextSelectionDown = this.TypeOfAbuseMode.DropDownFrame
				makeSubmitButtonActive()
			else
				this.TypeOfAbuseMode:UpdateDropDownList(ABUSE_TYPES_PLAYER)
				this.TypeOfAbuseMode:SetInteractable(#ABUSE_TYPES_PLAYER > 1)
				this.TypeOfAbuseLabel.ZIndex = (#ABUSE_TYPES_PLAYER > 1 and 2 or 1)
				
				if #playerNames > 0 then
					this.WhichPlayerMode:SetInteractable(true)
					this.WhichPlayerLabel.ZIndex = 2
					this.GameOrPlayerMode.SelectorFrame.NextSelectionDown = this.WhichPlayerMode.DropDownFrame
				else
					this.WhichPlayerMode:SetInteractable(false)
					this.WhichPlayerLabel.ZIndex = 1
					this.GameOrPlayerMode.SelectorFrame.NextSelectionDown = this.TypeOfAbuseMode.DropDownFrame
				end
				makeSubmitButtonInactive()
			end
			
		end

		local function cleanupReportAbuseMenu()
			updateAbuseDropDown()
			this.AbuseDescription.Selection.Text = DEFAULT_ABUSE_DESC_TEXT
			this.HubRef:SetVisibility(false, true)
		end

		local function onReportSubmitted()
			local abuseReason = nil
			local reportSucceeded = false
			if this.GameOrPlayerMode.CurrentIndex == 2 then
				abuseReason = ABUSE_TYPES_PLAYER[this.TypeOfAbuseMode.CurrentIndex]

				local currentAbusingPlayer = this:GetPlayerFromIndex(this.WhichPlayerMode.CurrentIndex)
				if currentAbusingPlayer and abuseReason then
					reportSucceeded = true
					spawn(function()
						game.Players:ReportAbuse(currentAbusingPlayer, abuseReason, this.AbuseDescription.Selection.Text)
					end)
				end
			else
				abuseReason = ABUSE_TYPES_GAME[this.TypeOfAbuseMode.CurrentIndex]
				if abuseReason then
					reportSucceeded = true
					spawn(function()
						local placeId,placeName,placeDescription = tostring(game.PlaceId), "N/A", "N/A"
						local abuseDescription = this.AbuseDescription.Selection.Text
						pcall(function()
							local productInfo = MarketplaceService:GetProductInfo(game.PlaceId, Enum.InfoType.Asset)
							placeName = productInfo.Name
							placeDescription = productInfo.Description
						end)
						local formattedText = string.format("User Report: \n    %s \n".."Place Title: \n    %s \n".."PlaceId: \n    %s \n".."Place Description: \n    %s \n",abuseDescription, placeName, placeId, placeDescription)

						game.Players:ReportAbuse(nil, abuseReason, formattedText)
					end)
				end
			end

			if reportSucceeded then
				local alertText = "Thanks for your report! Our moderators will review the chat logs and evaluate what happened."

				if abuseReason == 'Cheating/Exploiting' then
					alertText = "Thanks for your report! We've recorded your report for evaluation."
				elseif abuseReason == 'Inappropriate Username' then
					alertText = "Thanks for your report! Our moderators will evaluate the username."
				elseif abuseReason == "Bad Model or Script" or  abuseReason == "Inappropriate Content" or abuseReason == "Offsite Link" or abuseReason == "Offsite Links" then
					alertText = "Thanks for your report! Our moderators will review the place and make a determination."
				end

				utility:ShowAlert(alertText, "Ok", this.HubRef, cleanupReportAbuseMenu)

				this.LastSelectedObject = nil
			end
		end

		submitButton, submitText = utility:MakeStyledButton("SubmitButton", "Submit", UDim2.new(0,198,0,50), onReportSubmitted, this)
		if utility:IsSmallTouchScreen() then
			submitButton.Position = UDim2.new(1,-220,1,5)
		else
			submitButton.Position = UDim2.new(1,-194,1,5)
		end
		
		if this.GameOrPlayerMode.CurrentIndex == 1 then
			makeSubmitButtonActive()
		else
			makeSubmitButtonInactive()
		end
		submitButton.Parent = this.AbuseDescription.Selection

		local function playerSelectionChanged(newIndex)
			if newIndex ~= nil and this.TypeOfAbuseMode:GetSelectedIndex() ~= nil then
				makeSubmitButtonActive()
			else
				makeSubmitButtonInactive()
			end
		end
		this.WhichPlayerMode.IndexChanged:connect(playerSelectionChanged)

		local function typeOfAbuseChanged(newIndex)
			if newIndex ~= nil then
				if this.GameOrPlayerMode.CurrentIndex == 1 then -- 1 is Report Game
					makeSubmitButtonActive()
				else -- 2 is Report Player
					if this.WhichPlayerMode:GetSelectedIndex() then
						makeSubmitButtonActive()
					else
						makeSubmitButtonInactive()
					end
				end
			else
				makeSubmitButtonInactive()
			end
		end
		this.TypeOfAbuseMode.IndexChanged:connect(typeOfAbuseChanged)

		this.GameOrPlayerMode.IndexChanged:connect(updateAbuseDropDown)

		this:AddRow(nil, nil, this.AbuseDescription)

		this.Page.Size = UDim2.new(1,0,0,submitButton.AbsolutePosition.Y + submitButton.AbsoluteSize.Y)
	end

	return this
end


----------- Public Facing API Additions --------------
do
	PageInstance = Initialize()

	PageInstance.Displayed.Event:connect(function()
		PageInstance:UpdatePlayerDropDown()
	end)

	function PageInstance:ReportPlayer(player)
		if player then
			local setReportPlayerConnection = nil
			setReportPlayerConnection = PageInstance.Displayed.Event:connect(function()
				-- When we change the SelectionIndex of GameOrPlayerMode it waits until the tween is done
				-- before it fires the IndexChanged signal. The WhichPlayerMode dropdown listens to this signal
				-- and resets when it is fired. Therefore we need to listen to this signal and set the player we want
				-- to report the frame after the dropdown is reset
				local indexChangedConnection = nil
				indexChangedConnection = PageInstance.GameOrPlayerMode.IndexChanged:connect(function()
					if indexChangedConnection then
						indexChangedConnection:disconnect()
						indexChangedConnection = nil
					end
					PageInstance.WhichPlayerMode:SetSelectionByValue(player.Name)
				end)
				PageInstance.GameOrPlayerMode:SetSelectionIndex(2)

				if setReportPlayerConnection then
					setReportPlayerConnection:disconnect()
					setReportPlayerConnection = nil
				end
			end)
			PageInstance.HubRef:SetVisibility(true, false, PageInstance)
		end
	end
end


return PageInstance
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0F400533A6DB4695BE3B9E06D5EC4892">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ResetCharacter</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
		Filename: ResetCharacter.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Takes care of the reseting the character in Settings Menu
--]]

-------------- CONSTANTS -------------
local RESET_CHARACTER_GAME_ACTION = "ResetCharacterAction"

-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local ContextActionService = game:GetService("ContextActionService")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local GuiService = game:GetService("GuiService")
local PlayersService = game:GetService("Players")

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)

------------ Variables -------------------
local PageInstance = nil
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()

----------- CLASS DECLARATION --------------

local function Initialize()
	local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
	local this = settingsPageFactory:CreateNewPage()

	this.DontResetCharFunc = function(isUsingGamepad)
		if this.HubRef then
			this.HubRef:PopMenu(isUsingGamepad, true)
		end
	end
	this.DontResetCharFromHotkey = function(name, state, input)
		if state == Enum.UserInputState.Begin then
			local isUsingGamepad = input.UserInputType == Enum.UserInputType.Gamepad1 or input.UserInputType == Enum.UserInputType.Gamepad2
				or input.UserInputType == Enum.UserInputType.Gamepad3 or input.UserInputType == Enum.UserInputType.Gamepad4

			this.DontResetCharFunc(isUsingGamepad)
		end
	end
	this.DontResetCharFromButton = function(isUsingGamepad)
		this.DontResetCharFunc(isUsingGamepad)
	end
	
	------ TAB CUSTOMIZATION -------
	this.TabHeader = nil -- no tab for this page

	------ PAGE CUSTOMIZATION -------
	this.Page.Name = "ResetCharacter"

	local resetCharacterText =  utility:Create'TextLabel'
	{
		Name = "ResetCharacterText",
		Text = "Are you sure you want to reset your character?",
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size36,
		TextColor3 = Color3.new(1,1,1),
		BackgroundTransparency = 1,
		Size = UDim2.new(1,0,0,200),
		TextWrapped = true,
		ZIndex = 2,
		Parent = this.Page
	};
	if utility:IsSmallTouchScreen() then
		resetCharacterText.FontSize = Enum.FontSize.Size24
		resetCharacterText.Size = UDim2.new(1,0,0,100)
	elseif isTenFootInterface then
		resetCharacterText.FontSize = Enum.FontSize.Size48
	end

	------ Init -------
	local resetCharFunc = function()
		local player = PlayersService.LocalPlayer
		if player then
			local character = player.Character
			if character then
				local humanoid = character:FindFirstChild('Humanoid')
				if humanoid then
					humanoid.Health = 0
				end
			end
		end
	end
	
	this.ResetBindable = true
	
	local onResetFunction = function()
		if this.HubRef then
			this.HubRef:SetVisibility(false, true)
		end
		if this.ResetBindable == true then
			resetCharFunc()
		elseif this.ResetBindable then
			this.ResetBindable:Fire()
		end
	end

	local buttonSpacing = 20
	local buttonSize = UDim2.new(0, 200, 0, 50)
	if isTenFootInterface then
		resetCharacterText.Position = UDim2.new(0,0,0,100)
		buttonSize = UDim2.new(0, 300, 0, 80)
	end

	this.ResetCharacterButton = utility:MakeStyledButton("ResetCharacter", "Reset", buttonSize, onResetFunction)
	this.ResetCharacterButton.NextSelectionRight = nil
	if utility:IsSmallTouchScreen() then
		this.ResetCharacterButton.Position = UDim2.new(0.5, -buttonSize.X.Offset - buttonSpacing, 1, 0)
	else
		this.ResetCharacterButton.Position = UDim2.new(0.5, -buttonSize.X.Offset - buttonSpacing, 1, -30)
	end
	this.ResetCharacterButton.Parent = resetCharacterText


	local dontResetCharacterButton = utility:MakeStyledButton("DontResetCharacter", "Don't Reset", buttonSize, this.DontResetCharFromButton)
	dontResetCharacterButton.NextSelectionLeft = nil
	if utility:IsSmallTouchScreen() then
		dontResetCharacterButton.Position = UDim2.new(0.5, buttonSpacing, 1, 0)
	else
		dontResetCharacterButton.Position = UDim2.new(0.5, buttonSpacing, 1, -30)
	end
	dontResetCharacterButton.Parent = resetCharacterText

	this.Page.Size = UDim2.new(1,0,0,dontResetCharacterButton.AbsolutePosition.Y + dontResetCharacterButton.AbsoluteSize.Y)
	
	return this
end


----------- Public Facing API Additions --------------
PageInstance = Initialize()
local isOpen = false

PageInstance.Displayed.Event:connect(function()
	isOpen = true
	GuiService.SelectedCoreObject = PageInstance.ResetCharacterButton
	ContextActionService:BindCoreAction(RESET_CHARACTER_GAME_ACTION, PageInstance.DontResetCharFromHotkey, false, Enum.KeyCode.ButtonB)
end)

PageInstance.Hidden.Event:connect(function()
	isOpen = false
	ContextActionService:UnbindCoreAction(RESET_CHARACTER_GAME_ACTION)
end)

function PageInstance:SetResetCallback(bindableEvent)
	if bindableEvent == false and isOpen then
		-- We need to close this page if reseting was just disabled and the page is already open
		PageInstance.HubRef:PopMenu(nil, true)
	end
	PageInstance.ResetBindable = bindableEvent
end

return PageInstance
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD599113A73CA4E749F01CBB284FC74CC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Record</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[r
		Filename: Record.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Takes care of the Record Tab in Settings Menu
--]]
-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local GuiService = game:GetService("GuiService")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

----------- UTILITIES --------------
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local utility = require(RobloxGui.Modules.Settings.Utility)
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()

------------ Variables -------------------
local PageInstance = nil

----------- CLASS DECLARATION --------------

local function Initialize()
	local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
	local this = settingsPageFactory:CreateNewPage()
	local isRecordingVideo = false

	local recordingEvent = Instance.new("BindableEvent")
	recordingEvent.Name = "RecordingEvent"
	this.RecordingChanged = recordingEvent.Event
	function this:IsRecording()
		return isRecordingVideo
	end
	
	------ TAB CUSTOMIZATION -------
	this.TabHeader.Name = "RecordTab"

	this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/RecordTab.png"
	this.TabHeader.Icon.Size = UDim2.new(0,41,0,40)
	this.TabHeader.Icon.Position = UDim2.new(0,5,0.5,-20)

	this.TabHeader.Icon.Title.Text = "Record"

	this.TabHeader.Size = UDim2.new(0,130,1,0)


	------ PAGE CUSTOMIZATION -------
	this.Page.Name = "Record"

	local function makeTextLabel(name, text, bold, size, pos, parent)
		local textLabel = utility:Create'TextLabel'
		{
			Name = name,
			BackgroundTransparency = 1,
			Text = text,
			TextWrapped = true,
			Font = Enum.Font.SourceSans,
			FontSize = Enum.FontSize.Size24,
			TextColor3 = Color3.new(1,1,1),
			Size = size,
			Position = pos,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextYAlignment = Enum.TextYAlignment.Top,
			ZIndex = 2,
			Parent = parent
		};
		if bold then textLabel.Font = Enum.Font.SourceSansBold end

		return textLabel
	end

	-- need to override this function from SettingsPageFactory
	-- DropDown menus require hub to to be set when they are initialized
	function this:SetHub(newHubRef)
		this.HubRef = newHubRef

		local recordEnumNames = {}
		recordEnumNames[1] = "Save To Disk"
		recordEnumNames[2] = "Upload to YouTube"

		local startSetting = 2
		if GameSettings.VideoUploadPromptBehavior == Enum.UploadSetting["Never"] then
			startSetting = 1
		end

		---------------------------------- SCREENSHOT -------------------------------------
		local screenshotTitle = makeTextLabel("ScreenshotTitle", 
												"Screenshot",
												true, UDim2.new(1,0,0,36), UDim2.new(0,10,0.05,0), this.Page)
		screenshotTitle.FontSize = Enum.FontSize.Size36

		local screenshotBody = makeTextLabel("ScreenshotBody", 
												"By clicking the 'Take Screenshot' button, the menu will close and take a screenshot and save it to your computer.",
												false, UDim2.new(1,-10,0,70), UDim2.new(0,0,1,0), screenshotTitle)

		local closeSettingsFunc = function()
			this.HubRef:SetVisibility(false, true)
		end
		this.ScreenshotButton = utility:MakeStyledButton("ScreenshotButton", "Take Screenshot", UDim2.new(0,300,0,44), closeSettingsFunc, this)
		
		this.ScreenshotButton.Position = UDim2.new(0,400,1,0)
		this.ScreenshotButton.Parent = screenshotBody


		---------------------------------- VIDEO -------------------------------------
		local videoTitle = makeTextLabel("VideoTitle", 
												"Video",
												true, UDim2.new(1,0,0,36), UDim2.new(0,10,0.5,0), this.Page)
		videoTitle.FontSize = Enum.FontSize.Size36

		local videoBody = makeTextLabel("VideoBody", 
												"By clicking the 'Record Video' button, the menu will close and start recording your screen.",
												false, UDim2.new(1,-10,0,70), UDim2.new(0,0,1,0), videoTitle)

		this.VideoSettingsFrame, 
		this.VideoSettingsLabel,
		this.VideoSettingsMode = utility:AddNewRow(this, "Video Settings", "Selector", recordEnumNames, startSetting, 270)

		this.VideoSettingsMode.IndexChanged:connect(function(newIndex)
			if newIndex == 1 then
				GameSettings.VideoUploadPromptBehavior = Enum.UploadSetting.Never
			elseif newIndex == 2 then
				GameSettings.VideoUploadPromptBehavior = Enum.UploadSetting.Always
			end
		end)


		local recordButton = utility:MakeStyledButton("RecordButton", "Record Video", UDim2.new(0,300,0,44), closeSettingsFunc, this)
		
		recordButton.Position = UDim2.new(0,410,1,10)
		recordButton.Parent = this.VideoSettingsMode.SelectorFrame.Parent
		recordButton.MouseButton1Click:connect(function()
			recordingEvent:Fire(not isRecordingVideo)
		end)

		local gameOptions = settings():FindFirstChild("Game Options")
		if gameOptions then
			gameOptions.VideoRecordingChangeRequest:connect(function(recording)
				isRecordingVideo = recording
				if recording then
					recordButton.RecordButtonTextLabel.Text = "Stop Recording"
				else
					recordButton.RecordButtonTextLabel.Text = "Record Video"
				end
			end)
		end


		recordButton:SetVerb("RecordToggle")
		this.ScreenshotButton:SetVerb("Screenshot")

		this.Page.Size = UDim2.new(1,0,0,400)
	end

	return this
end


----------- Public Facing API Additions --------------
PageInstance = Initialize()

PageInstance.Displayed.Event:connect(function(switchedFromGamepadInput)
	if switchedFromGamepadInput then
		GuiService.SelectedCoreObject = PageInstance.ScreenshotButton
	end
end)


return PageInstance]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1DCECC79D8DE41439427F092F37ADD84">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Players</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[ --[[
		Filename: Players.lua
		Written by: Stickmasterluke
		Version 1.0
		Description: Player list inside escape menu, with friend adding functionality.
--]]
-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local GuiService = game:GetService("GuiService")
local PlayersService = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')

----------- UTILITIES --------------
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local utility = require(RobloxGui.Modules.Settings.Utility)
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()

------------ Constants -------------------
local frameDefaultTransparency = .85
local frameSelectedTransparency = .65

------------ Variables -------------------
local PageInstance = nil
local localPlayer = PlayersService.LocalPlayer
while not localPlayer do
	PlayersService.ChildAdded:wait()
	localPlayer = PlayersService.LocalPlayer
end

----------- CLASS DECLARATION --------------
local function Initialize()
	local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
	local this = settingsPageFactory:CreateNewPage()

	local playerLabelFakeSelection = Instance.new('ImageLabel')
	playerLabelFakeSelection.BackgroundTransparency = 1
	--[[playerLabelFakeSelection.Image = 'rbxasset://textures/ui/SelectionBox.png'
	playerLabelFakeSelection.ScaleType = 'Slice'
	playerLabelFakeSelection.SliceCenter = Rect.new(31,31,31,31)]]
	playerLabelFakeSelection.Image = ''
	playerLabelFakeSelection.Size = UDim2.new(0,0,0,0)

	------ TAB CUSTOMIZATION -------
	this.TabHeader.Name = "PlayersTab"

	this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/PlayersTabIcon.png"
	if utility:IsSmallTouchScreen() then
		this.TabHeader.Icon.Size = UDim2.new(0,34,0,28)
		this.TabHeader.Icon.Position = UDim2.new(this.TabHeader.Icon.Position.X.Scale,this.TabHeader.Icon.Position.X.Offset,0.5,-14)
		this.TabHeader.Size = UDim2.new(0,115,1,0)
	elseif isTenFootInterface then
		this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/PlayersTabIcon@2x.png"
		this.TabHeader.Icon.Size = UDim2.new(0,88,0,74)
		this.TabHeader.Icon.Position = UDim2.new(0,0,0.5,-43)
		this.TabHeader.Size = UDim2.new(0,280,1,0)
	else
		this.TabHeader.Icon.Size = UDim2.new(0,44,0,37)
		this.TabHeader.Icon.Position = UDim2.new(0,15,0.5,-18)	-- -22
		this.TabHeader.Size = UDim2.new(0,150,1,0)
	end

	this.TabHeader.Icon.Title.Text = "Players"

	----- FRIENDSHIP FUNCTIONS ------
	local function getFriendStatus(selectedPlayer)
		local success, result = pcall(function()
			-- NOTE: Core script only
			return localPlayer:GetFriendStatus(selectedPlayer)
		end)
		if success then
			return result
		else
			return Enum.FriendStatus.NotFriend
		end
	end

	------ PAGE CUSTOMIZATION -------
	this.Page.Name = "Players"

	local selectionFound = nil
	local function friendStatusCreate(playerLabel, player)
		if playerLabel then
			-- remove any previous friend status labels
			for _, item in pairs(playerLabel:GetChildren()) do
				if item and item.Name == 'FriendStatus' then
					if GuiService.SelectedCoreObject == item then
						selectionFound = nil
						GuiService.SelectedCoreObject = nil
					end
					item:Destroy()
				end
			end

			-- create new friend status label
			local status = nil
			if player and player ~= localPlayer and player.userId > 1 and localPlayer.userId > 1 then
				status = getFriendStatus(player)
			end

			local friendLabel, friendLabelText = nil, nil
			if not status then
				friendLabel = Instance.new('TextButton')
				friendLabel.Text = ''
				friendLabel.BackgroundTransparency = 1
				friendLabel.Position = UDim2.new(1,-198,0,7)
			elseif status == Enum.FriendStatus.Friend then 
				friendLabel = Instance.new('TextButton')
				friendLabel.Text = 'Friend'
				friendLabel.BackgroundTransparency = 1
				friendLabel.FontSize = 'Size24'
				friendLabel.Font = 'SourceSans'
				friendLabel.TextColor3 = Color3.new(1,1,1)
				friendLabel.Position = UDim2.new(1,-198,0,7)
			elseif status == Enum.FriendStatus.Unknown or status == Enum.FriendStatus.NotFriend or status == Enum.FriendStatus.FriendRequestReceived then
				local addFriendFunc = function()
					if friendLabel and friendLabelText and friendLabelText.Text ~= '' then
						friendLabel.ImageTransparency = 1
						friendLabelText.Text = ''
						if localPlayer and player then
							localPlayer:RequestFriendship(player)
						end
					end
				end
				local friendLabel2, friendLabelText2 = utility:MakeStyledButton("FriendStatus", "Add Friend", UDim2.new(0, 182, 0, 46), addFriendFunc)
				friendLabel = friendLabel2
				friendLabelText = friendLabelText2
				friendLabelText.ZIndex = 3
				friendLabelText.Position = friendLabelText.Position + UDim2.new(0,0,0,1)
				friendLabel.Position = UDim2.new(1,-198,0,7)
			elseif status == Enum.FriendStatus.FriendRequestSent then
				friendLabel = Instance.new('TextButton')
				friendLabel.Text = 'Request Sent'
				friendLabel.BackgroundTransparency = 1
				friendLabel.FontSize = 'Size24'
				friendLabel.Font = 'SourceSans'
				friendLabel.TextColor3 = Color3.new(1,1,1)
				friendLabel.Position = UDim2.new(1,-198,0,7)
			end

			if friendLabel then
				friendLabel.Name = 'FriendStatus'
				friendLabel.Size = UDim2.new(0,182,0,46)
				friendLabel.ZIndex = 3
				friendLabel.Parent = playerLabel
				friendLabel.SelectionImageObject = playerLabelFakeSelection

				local updateHighlight = function()
					if playerLabel then
						playerLabel.ImageTransparency = friendLabel and GuiService.SelectedCoreObject == friendLabel and frameSelectedTransparency or frameDefaultTransparency
					end
				end
				friendLabel.SelectionGained:connect(updateHighlight)
				friendLabel.SelectionLost:connect(updateHighlight)

				if UserInputService.GamepadEnabled and not selectionFound then
					selectionFound = true
					local fakeSize = 20
					playerLabelFakeSelection.Size = UDim2.new(0,playerLabel.AbsoluteSize.X+fakeSize,0,playerLabel.AbsoluteSize.Y+fakeSize)
					playerLabelFakeSelection.Position = UDim2.new(0, -(playerLabel.AbsoluteSize.X-198)-fakeSize*.5, 0, -8-fakeSize*.5)
					GuiService.SelectedCoreObject = friendLabel
				end
			end

		end
	end

	localPlayer.FriendStatusChanged:connect(function(player, friendStatus)
		if player then
			local playerLabel = this.Page:FindFirstChild('PlayerLabel'..player.Name)
			if playerLabel then
				friendStatusCreate(playerLabel, player)
			end
		end
	end)

	if utility:IsSmallTouchScreen() then
		local spaceFor3Buttons = RobloxGui.AbsoluteSize.x >= 720	-- else there is only space for 2

		local resetFunc = function()
			this.HubRef:SwitchToPage(this.HubRef.ResetCharacterPage, false, 1)
		end
		local resetButton, resetLabel = utility:MakeStyledButton("ResetButton", "Reset Character", UDim2.new(0, 200, 0, 62), resetFunc)
		resetLabel.Size = UDim2.new(1, 0, 1, -6)
		resetLabel.FontSize = Enum.FontSize.Size24
		resetButton.Position = UDim2.new(0.5,spaceFor3Buttons and -340 or -220,0,14)
		resetButton.Parent = this.Page

		local leaveGameFunc = function()
			this.HubRef:SwitchToPage(this.HubRef.LeaveGamePage, false, 1)
		end
		local leaveButton, leaveLabel = utility:MakeStyledButton("LeaveButton", "Leave Game", UDim2.new(0, 200, 0, 62), leaveGameFunc)
		leaveLabel.Size = UDim2.new(1, 0, 1, -6)
		leaveLabel.FontSize = Enum.FontSize.Size24
		leaveButton.Position = UDim2.new(0.5,spaceFor3Buttons and -100 or 20,0,14)
		leaveButton.Parent = this.Page

		if spaceFor3Buttons then
			local resumeGameFunc = function()
				this.HubRef:SetVisibility(false)
			end
			resumeButton, resumeLabel = utility:MakeStyledButton("ResumeButton", "Resume Game", UDim2.new(0, 200, 0, 62), resumeGameFunc)
			resumeLabel.Size = UDim2.new(1, 0, 1, -6)
			resumeLabel.FontSize = Enum.FontSize.Size24
			resumeButton.Position = UDim2.new(0.5,140,0,14)
			resumeButton.Parent = this.Page
		end
	end

	local existingPlayerLabels = {}
	this.Displayed.Event:connect(function(switchedFromGamepadInput)
		local sortedPlayers = PlayersService:GetPlayers()
		table.sort(sortedPlayers,function(item1,item2)
			return item1.Name < item2.Name
		end)

		local extraOffset = 20
		if utility:IsSmallTouchScreen() then
			extraOffset = 85
		end

		selectionFound = nil

		-- iterate through players to reuse or create labels for players
		for index=1, #sortedPlayers do
			local player = sortedPlayers[index]
			local frame = existingPlayerLabels[index]
			if player then
				-- create label (frame) for this player index if one does not exist
				if not frame or not frame.Parent then
					frame = Instance.new('ImageLabel')
					frame.Image = "rbxasset://textures/ui/dialog_white.png"
					frame.ScaleType = 'Slice'
					frame.SliceCenter = Rect.new(10,10,10,10)
					frame.Size = UDim2.new(1,0,0,60)
					frame.Position = UDim2.new(0,0,0,(index-1)*80 + extraOffset)
					frame.BackgroundTransparency = 1
					frame.ZIndex = 2

					local icon = Instance.new('ImageLabel')
					icon.Name = 'Icon'
					icon.BackgroundTransparency = 1
					icon.Size = UDim2.new(0,36,0,36)
					icon.Position = UDim2.new(0,12,0,12)
					icon.ZIndex = 3
					icon.Parent = frame

					local nameLabel = Instance.new('TextLabel')
					nameLabel.Name = 'NameLabel'
					nameLabel.TextXAlignment = Enum.TextXAlignment.Left
					nameLabel.Font = 'SourceSans'
					nameLabel.FontSize = 'Size24'
					nameLabel.TextColor3 = Color3.new(1,1,1)
					nameLabel.BackgroundTransparency = 1
					nameLabel.Position = UDim2.new(0,60,.5,0)
					nameLabel.Size = UDim2.new(0,0,0,0)
					nameLabel.ZIndex = 3
					nameLabel.Parent = frame

					frame.MouseEnter:connect(function()
						frame.ImageTransparency = frameSelectedTransparency
					end)
					frame.MouseLeave:connect(function()
						frame.ImageTransparency = frameDefaultTransparency
					end)

					frame.Parent = this.Page
					table.insert(existingPlayerLabels, index, frame)
				end
				frame.Name = 'PlayerLabel'..player.Name
				frame.Icon.Image = 'https://www.roblox.com/Thumbs/Avatar.ashx?x=100&y=100&userId='..math.max(1, player.userId)
				frame.NameLabel.Text = player.Name
				frame.ImageTransparency = frameDefaultTransparency

				friendStatusCreate(frame, player)
			end
		end

		-- iterate through existing labels in reverse to destroy and remove unused labels
		for index=#existingPlayerLabels, 1, -1 do
			local player = sortedPlayers[index]
			local frame = existingPlayerLabels[index]
			if frame and not player then
				table.remove(existingPlayerLabels, i)
				frame:Destroy()
			end
		end

		this.Page.Size = UDim2.new(1,0,0, extraOffset + 80 * #sortedPlayers - 5)
	end)

	return this
end

----------- Public Facing API Additions --------------
PageInstance = Initialize()

return PageInstance
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD6E6367BC8414960A564743B3FFBA525">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">LeaveGame</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
		Filename: LeaveGame.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Takes care of the leave game in Settings Menu
--]]


-------------- CONSTANTS -------------
local LEAVE_GAME_ACTION = "LeaveGameCancelAction"
local LEAVE_GAME_FRAME_WAITS = 2

-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local ContextActionService = game:GetService("ContextActionService")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)

------------ Variables -------------------
local PageInstance = nil
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()

local useShutdownToLeaveSuccess,useShutdownToLeaveValue = pcall(function() return settings():GetFFlag("UseShutdownToLeave") end) 
local useShutdownToLeave = useShutdownToLeaveSuccess and useShutdownToLeaveValue

----------- CLASS DECLARATION --------------

local function Initialize()
	local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
	local this = settingsPageFactory:CreateNewPage()

	this.LeaveFunc = function()
		GuiService.SelectedCoreObject = nil -- deselects the button and prevents spamming the popup to save in studio when using gamepad
		
		-- need to wait for render frames so on slower devices the leave button highlight will update
		-- otherwise, since on slow devices it takes so long to leave you are left wondering if you pressed the button
		for i = 1, LEAVE_GAME_FRAME_WAITS do
			RunService.RenderStepped:wait()
		end

		game:Shutdown()
	end
	this.DontLeaveFunc = function(isUsingGamepad)
		if this.HubRef then
			this.HubRef:PopMenu(isUsingGamepad, true)
		end
	end
	this.DontLeaveFromHotkey = function(name, state, input)
		if state == Enum.UserInputState.Begin then
			local isUsingGamepad = input.UserInputType == Enum.UserInputType.Gamepad1 or input.UserInputType == Enum.UserInputType.Gamepad2
				or input.UserInputType == Enum.UserInputType.Gamepad3 or input.UserInputType == Enum.UserInputType.Gamepad4

			this.DontLeaveFunc(isUsingGamepad)
		end
	end
	this.DontLeaveFromButton = function(isUsingGamepad)
		this.DontLeaveFunc(isUsingGamepad)
	end
	
	------ TAB CUSTOMIZATION -------
	this.TabHeader = nil -- no tab for this page

	------ PAGE CUSTOMIZATION -------
	this.Page.Name = "LeaveGamePage"

	local leaveGameText =  utility:Create'TextLabel'
	{
		Name = "LeaveGameText",
		Text = "Are you sure you want to leave the game?",
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size36,
		TextColor3 = Color3.new(1,1,1),
		BackgroundTransparency = 1,
		Size = UDim2.new(1,0,0,200),
		TextWrapped = true,
		ZIndex = 2,
		Parent = this.Page
	};
	if utility:IsSmallTouchScreen() then
		leaveGameText.FontSize = Enum.FontSize.Size24
		leaveGameText.Size = UDim2.new(1,0,0,100)
	elseif isTenFootInterface then
		leaveGameText.FontSize = Enum.FontSize.Size48
	end

	local buttonSpacing = 20
	local buttonSize = UDim2.new(0, 200, 0, 50)
	if isTenFootInterface then
		leaveGameText.Position = UDim2.new(0,0,0,100)
		buttonSize = UDim2.new(0, 300, 0, 80)
	end

	this.LeaveGameButton = utility:MakeStyledButton("LeaveGame", "Leave", buttonSize, useShutdownToLeave and this.LeaveFunc or nil)
	this.LeaveGameButton.NextSelectionRight = nil
	
	if not useShutdownToLeave then
		this.LeaveGameButton:SetVerb("Exit")
	end
	
	if utility:IsSmallTouchScreen() then
		this.LeaveGameButton.Position = UDim2.new(0.5, -buttonSize.X.Offset - buttonSpacing, 1, 0)
	else
		this.LeaveGameButton.Position = UDim2.new(0.5, -buttonSize.X.Offset - buttonSpacing, 1, -30)
	end
	this.LeaveGameButton.Parent = leaveGameText


	------------- Init ----------------------------------
	
	local dontleaveGameButton = utility:MakeStyledButton("DontLeaveGame", "Don't Leave", buttonSize, this.DontLeaveFromButton)
	dontleaveGameButton.NextSelectionLeft = nil
	if utility:IsSmallTouchScreen() then
		dontleaveGameButton.Position = UDim2.new(0.5, buttonSpacing, 1, 0)
	else
		dontleaveGameButton.Position = UDim2.new(0.5, buttonSpacing, 1, -30)
	end
	dontleaveGameButton.Parent = leaveGameText

	this.Page.Size = UDim2.new(1,0,0,dontleaveGameButton.AbsolutePosition.Y + dontleaveGameButton.AbsoluteSize.Y)

	return this
end


----------- Public Facing API Additions --------------
PageInstance = Initialize()

PageInstance.Displayed.Event:connect(function()
	GuiService.SelectedCoreObject = PageInstance.LeaveGameButton
	ContextActionService:BindCoreAction(LEAVE_GAME_ACTION, PageInstance.DontLeaveFromHotkey, false, Enum.KeyCode.ButtonB)
end)

PageInstance.Hidden.Event:connect(function()
	ContextActionService:UnbindCoreAction(LEAVE_GAME_ACTION)
end)


return PageInstance]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX415944229C7E4B04A72F0DAA5B072489">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Home</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
		Filename: Home.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Takes care of the home page in Settings Menu
--]]

local BUTTON_OFFSET = 20
local BUTTON_SPACING = 10

-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local GuiService = game:GetService("GuiService")

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)

------------ Variables -------------------
local PageInstance = nil

----------- CLASS DECLARATION --------------

local function Initialize()
	local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
	local this = settingsPageFactory:CreateNewPage()
	
	------ TAB CUSTOMIZATION -------
	this.TabHeader.Name = "HomeTab"

	this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/HomeTab.png"
	this.TabHeader.Icon.Size = UDim2.new(0,32,0,30)
	this.TabHeader.Icon.Position = UDim2.new(0,5,0.5,-15)

	this.TabHeader.Icon.Title.Text = "Home"

	this.TabHeader.Size = UDim2.new(0,100,1,0)

	------ PAGE CUSTOMIZATION -------
	this.Page.Name = "Home"
	local resumeGameFunc = function()
		this.HubRef:SetVisibility(false)
	end

	this.ResumeButton = utility:MakeStyledButton("ResumeButton", "Resume Game", UDim2.new(0, 200, 0, 50), resumeGameFunc)
	this.ResumeButton.Position = UDim2.new(0.5,-100,0,BUTTON_OFFSET)
	this.ResumeButton.Parent = this.Page

	local resetFunc = function()
		this.HubRef:SwitchToPage(this.HubRef.ResetCharacterPage, false, 1)
	end

	local resetButton = utility:MakeStyledButton("ResetButton", "Reset Character", UDim2.new(0, 200, 0, 50), resetFunc)
	resetButton.Position = UDim2.new(0.5,-100,0,this.ResumeButton.AbsolutePosition.Y + this.ResumeButton.AbsoluteSize.Y + BUTTON_SPACING)
	resetButton.Parent = this.Page

	local leaveGameFunc = function()
		this.HubRef:SwitchToPage(this.HubRef.LeaveGamePage, false, 1)
	end

	local leaveButton = utility:MakeStyledButton("LeaveButton", "Leave Game", UDim2.new(0, 200, 0, 50), leaveGameFunc)
	leaveButton.Position = UDim2.new(0.5,-100,0,resetButton.AbsolutePosition.Y + resetButton.AbsoluteSize.Y + BUTTON_SPACING)
	leaveButton.Parent = this.Page

	this.Page.Size = UDim2.new(1,0,0,leaveButton.AbsolutePosition.Y + leaveButton.AbsoluteSize.Y)
	
	return this
end


----------- Public Facing API Additions --------------
do
	PageInstance = Initialize()

	PageInstance.Displayed.Event:connect(function()
		if not utility:UsesSelectedObject() then return end

		GuiService.SelectedCoreObject = PageInstance.ResumeButton
	end)
end


return PageInstance]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6A7B7047335A4BBF8CB9995945E7C727">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Help</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
		Filename: Help.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Takes care of the help page in Settings Menu
--]]
-------------- CONSTANTS --------------
local KEYBOARD_MOUSE_TAG = "KeyboardMouse"
local TOUCH_TAG = "Touch"
local GAMEPAD_TAG = "Gamepad"
local PC_TABLE_SPACING = 4

-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)
  
------------ Variables -------------------
local PageInstance = nil
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()

----------- CLASS DECLARATION --------------

local function Initialize()
  local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
  local this = settingsPageFactory:CreateNewPage()
  this.HelpPages = {}

  local lastInputType = nil

  function this:GetCurrentInputType()
    if lastInputType == nil then -- we don't know what controls the user has, just use reasonable defaults
      local platform = UserInputService:GetPlatform()
      if platform == Enum.Platform.XBoxOne or platform == Enum.Platform.WiiU then

        return GAMEPAD_TAG
      elseif platform == Enum.Platform.Windows or platform == Enum.Platform.OSX then
        return KEYBOARD_MOUSE_TAG
      else
        return TOUCH_TAG
      end
    end

    if lastInputType == Enum.UserInputType.Keyboard or lastInputType == Enum.UserInputType.MouseMovement or 
    lastInputType == Enum.UserInputType.MouseButton1 or lastInputType == Enum.UserInputType.MouseButton2 or
    lastInputType == Enum.UserInputType.MouseButton3 or lastInputType == Enum.UserInputType.MouseWheel then
      return KEYBOARD_MOUSE_TAG
    elseif lastInputType == Enum.UserInputType.Touch then
      return TOUCH_TAG
    elseif lastInputType == Enum.UserInputType.Gamepad1 or lastInputType == Enum.UserInputType.Gamepad2 or 
    inputType == Enum.UserInputType.Gamepad3 or lastInputType == Enum.UserInputType.Gamepad4 then
      return GAMEPAD_TAG
    end

    return KEYBOARD_MOUSE_TAG
  end


  local function createPCHelp(parentFrame)
    local function createPCGroup(title, actionInputBindings)
      local textIndent = 9

      local pcGroupFrame = utility:Create'Frame'
      {
        Size = UDim2.new(1/3,-PC_TABLE_SPACING,1,0),
        BackgroundTransparency = 1,
        Name = "PCGroupFrame" .. tostring(title)
      };
      local pcGroupTitle = utility:Create'TextLabel'
      {
        Position = UDim2.new(0,textIndent,0,0),
        Size = UDim2.new(1,-textIndent,0,30),
        BackgroundTransparency = 1,
        Text = title,
        Font = Enum.Font.SourceSansBold,
        FontSize = Enum.FontSize.Size18,
        TextColor3 = Color3.new(1,1,1),
        TextXAlignment = Enum.TextXAlignment.Left,
        Name = "PCGroupTitle" .. tostring(title),
        ZIndex = 2,
        Parent = pcGroupFrame
      };

      local count = 0
      local frameHeight = 42
      local spacing = 2
      local offset = pcGroupTitle.Size.Y.Offset
      for i = 1, #actionInputBindings do
        for actionName, inputName in pairs(actionInputBindings[i]) do
          local actionInputFrame = utility:Create'Frame'
          {
            Size = UDim2.new(1,0,0,frameHeight),
            Position = UDim2.new(0,0,0, offset + ((frameHeight + spacing) * count)),
            BackgroundTransparency = 0.65,
            BorderSizePixel = 0,
            ZIndex = 2,
            Name = "ActionInputBinding" .. tostring(actionName),
            Parent = pcGroupFrame
          };

          local nameLabel = utility:Create'TextLabel'
          {
            Size = UDim2.new(0.4,-textIndent,0,frameHeight),
            Position = UDim2.new(0,textIndent,0,0),
            BackgroundTransparency = 1,
            Text = actionName,
            Font = Enum.Font.SourceSansBold,
            FontSize = Enum.FontSize.Size18,
            TextColor3 = Color3.new(1,1,1),
            TextXAlignment = Enum.TextXAlignment.Left,
            Name = actionName .. "Label",
            ZIndex = 2,
            Parent = actionInputFrame
          };

          local inputLabel = utility:Create'TextLabel'
          {
            Size = UDim2.new(0.6,0,0,frameHeight),
            Position = UDim2.new(0.5,-4,0,0),
            BackgroundTransparency = 1,
            Text = inputName,
            Font = Enum.Font.SourceSans,
            FontSize = Enum.FontSize.Size18,
            TextColor3 = Color3.new(1,1,1),
            TextXAlignment = Enum.TextXAlignment.Left,
            Name = inputName .. "Label",
            ZIndex = 2,
            Parent = actionInputFrame
          };

          count = count + 1
        end
      end

      pcGroupFrame.Size = UDim2.new(pcGroupFrame.Size.X.Scale,pcGroupFrame.Size.X.Offset,
        0, offset + ((frameHeight + spacing) * count))

      return pcGroupFrame
    end

    local rowOffset = 50
    local isOSX = UserInputService:GetPlatform() == Enum.Platform.OSX

    local charMoveFrame = createPCGroup( "Character Movement", {[1] = {["Move Forward"] = "W/Up Arrow"}, 
        [2] = {["Move Backward"] = "S/Down Arrow"},
        [3] = {["Move Left"] = "A/Left Arrow"},
        [4] = {["Move Right"] = "D/Right Arrow"},
        [5] = {["Jump"] = "Space"}} )
    charMoveFrame.Parent = parentFrame

    local accessoriesFrame = createPCGroup("Accessories", {	
        [1] = {["Equip Tools"] = "1,2,3..."}, 
        [2] = {["Unequip Tools"] = "1,2,3..."},
        [3] = {["Drop Tool"] = "Backspace"},
        [4] = {["Use Tool"] = "Left Mouse Button"} })
    accessoriesFrame.Position = UDim2.new(1/3,PC_TABLE_SPACING,0,0)
    accessoriesFrame.Parent = parentFrame

    local miscFrame = nil
    miscFrame = createPCGroup("Misc", {	
        [1] = {["Screenshot"] = "Print Screen"}, 
        [2] = {["Record Video"] = isOSX and "F12/fn + F12" or "F12"},
        [3] = {["Dev Console"] = isOSX and "F9/fn + F9" or "F9"},
        [4] = {["Mouselock"] = "Shift"},
        [5] = {["Graphics Level"] = isOSX and "F10/fn + F10" or "F10"},
        [6] = {["Fullscreen"] = isOSX and "F11/fn + F11" or "F11"},
        [7] = {["Perf. Stats"] = isOSX and "F9/fn + F9" or "F9"}, 
      }
    )

    miscFrame.Position = UDim2.new(2/3,PC_TABLE_SPACING * 2,0,0)
    miscFrame.Parent = parentFrame

    local camFrame = createPCGroup("Camera Movement", {	[1] = {["Rotate"] = "Right Mouse Button"}, 
        [2] = {["Zoom In/Out"] = "Mouse Wheel"},
        [3] = {["Zoom In"] = "I"},
        [4] = {["Zoom Out"] = "O"} })
    camFrame.Position = UDim2.new(0,0,charMoveFrame.Size.Y.Scale,charMoveFrame.Size.Y.Offset + rowOffset)
    camFrame.Parent = parentFrame

    local menuFrame = createPCGroup("Menu Items", {		[1] = {["ROBLOX Menu"] = "ESC"}, 
        [2] = {["Backpack"] = "~"},
        [3] = {["Playerlist"] = "TAB"},
        [4] = {["Chat"] = "/"} })
    menuFrame.Position = UDim2.new(1/3,PC_TABLE_SPACING,charMoveFrame.Size.Y.Scale,charMoveFrame.Size.Y.Offset + rowOffset)
    menuFrame.Parent = parentFrame

    parentFrame.Size = UDim2.new(parentFrame.Size.X.Scale, parentFrame.Size.X.Offset, 0, 
      menuFrame.Size.Y.Offset + menuFrame.Position.Y.Offset)
  end

  local function createGamepadHelp(parentFrame)
    local gamepadImage = "rbxasset://textures/ui/Settings/Help/GenericController.png"
    local imageSize = UDim2.new(0,650,0,239)
    local imagePosition = UDim2.new(0.5,-imageSize.X.Offset/2,0.5,-imageSize.Y.Offset/2)
    if UserInputService:GetPlatform() == Enum.Platform.XBoxOne or UserInputService:GetPlatform() == Enum.Platform.XBox360 then
      gamepadImage = "rbxasset://textures/ui/Settings/Help/XboxController.png"
      imageSize = UDim2.new(0,1334,0,570)
      imagePosition = UDim2.new(0.5, (-imageSize.X.Offset/2) - 50, 0.5, -imageSize.Y.Offset/2)
    elseif UserInputService:GetPlatform() == Enum.Platform.PS4 or UserInputService:GetPlatform() == Enum.Platform.PS3 then
      gamepadImage = "rbxasset://textures/ui/Settings/Help/PSController.png"
    end

    local gamepadImageLabel = utility:Create'ImageLabel'
    {
      Name = "GamepadImage",
      Size = imageSize,
      Position = imagePosition,
      Image = gamepadImage,
      BackgroundTransparency = 1,
      ZIndex = 2,
      Parent = parentFrame
    };
    parentFrame.Size = UDim2.new(parentFrame.Size.X.Scale, parentFrame.Size.X.Offset, 0, gamepadImageLabel.Size.Y.Offset + 100)

    local gamepadFontSize = isTenFootInterface and Enum.FontSize.Size36 or Enum.FontSize.Size24
    local function createGamepadLabel(text, position, size)
      local nameLabel = utility:Create'TextLabel'
      {
        Position = position,
        Size = size,
        BackgroundTransparency = 1,
        Text = text,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.SourceSansBold,
        FontSize = gamepadFontSize,
        TextColor3 = Color3.new(1,1,1),
        Name = text .. "Label",
        ZIndex = 2,
        Parent = gamepadImageLabel
      };
    end

    local textVerticalSize = (gamepadFontSize == Enum.FontSize.Size36) and 36 or 24

    if gamepadImage == "rbxasset://textures/ui/Settings/Help/XboxController.png" then
      createGamepadLabel("Switch Tool", UDim2.new(0,50,0,-textVerticalSize/2), UDim2.new(0,100,0,textVerticalSize))
      createGamepadLabel("Game Menu Toggle", UDim2.new(0,-38,0.15,-textVerticalSize/2), UDim2.new(0,164,0,textVerticalSize))
      createGamepadLabel("Move", UDim2.new(0,-80,0.31,-textVerticalSize/2), UDim2.new(0,46,0,textVerticalSize))
      createGamepadLabel("Menu Navigation", UDim2.new(0,-50,0.46,-textVerticalSize/2), UDim2.new(0,164,0,textVerticalSize))
      createGamepadLabel("Use Tool", UDim2.new(0.96,0,0,-textVerticalSize/2), UDim2.new(0,73,0,textVerticalSize))
      createGamepadLabel("ROBLOX Menu", UDim2.new(0.96,0,0.15,-textVerticalSize/2), UDim2.new(0,122,0,textVerticalSize))
      createGamepadLabel("Back", UDim2.new(0.96,0,0.31,-textVerticalSize/2), UDim2.new(0,43,0,textVerticalSize))
      createGamepadLabel("Jump", UDim2.new(0.96,0,0.46,-textVerticalSize/2), UDim2.new(0,49,0,textVerticalSize))
      createGamepadLabel("Rotate Camera", UDim2.new(1,0,0.62,-textVerticalSize/2), UDim2.new(0,132,0,textVerticalSize))
      createGamepadLabel("Camera Zoom", UDim2.new(1,0,0.77,-textVerticalSize/2), UDim2.new(0,122,0,textVerticalSize))
    else
      createGamepadLabel("Switch Tool", UDim2.new(-0.01,0,0,-textVerticalSize/2), UDim2.new(0,100,0,textVerticalSize))
      createGamepadLabel("Game Menu Toggle", UDim2.new(-0.11,0,0.15,-textVerticalSize/2), UDim2.new(0,164,0,textVerticalSize))
      createGamepadLabel("Move", UDim2.new(-0.08,0,0.31,-textVerticalSize/2), UDim2.new(0,46,0,textVerticalSize))
      createGamepadLabel("Menu Navigation", UDim2.new(-0.125,0,0.46,-textVerticalSize/2), UDim2.new(0,164,0,textVerticalSize))
      createGamepadLabel("Use Tool", UDim2.new(0.96,0,0,-textVerticalSize/2), UDim2.new(0,73,0,textVerticalSize))
      createGamepadLabel("ROBLOX Menu", UDim2.new(0.9,0,0.15,-textVerticalSize/2), UDim2.new(0,122,0,textVerticalSize))
      createGamepadLabel("Back", UDim2.new(1.01,0,0.31,-textVerticalSize/2), UDim2.new(0,43,0,textVerticalSize))
      createGamepadLabel("Jump", UDim2.new(0.91,0,0.46,-textVerticalSize/2), UDim2.new(0,49,0,textVerticalSize))
      createGamepadLabel("Rotate Camera", UDim2.new(0.91,0,0.62,-textVerticalSize/2), UDim2.new(0,132,0,textVerticalSize))
      createGamepadLabel("Camera Zoom", UDim2.new(0.91,0,0.77,-textVerticalSize/2), UDim2.new(0,122,0,textVerticalSize))
    end


    -- NOTE: On consoles we put the dev console in the settings menu. Only place
    -- owners can see this for now.
  end

  local function createTouchHelp(parentFrame)
    local smallScreen = utility:IsSmallTouchScreen()
    local ySize = GuiService:GetScreenResolution().y - 350
    if smallScreen then
      ySize = GuiService:GetScreenResolution().y - 100
    end
    parentFrame.Size = UDim2.new(1,0,0,ySize)

    local function createTouchLabel(text, position, size, parent)
      local nameLabel = utility:Create'TextLabel'
      {
        Position = position,
        Size = size,
        BackgroundTransparency = 1,
        Text = text,
        Font = Enum.Font.SourceSansBold,
        FontSize = Enum.FontSize.Size14,
        TextColor3 = Color3.new(1,1,1),
        Name = text .. "Label",
        ZIndex = 3,
        Parent = parent
      };
      if not smallScreen then
        nameLabel.FontSize = Enum.FontSize.Size18
        nameLabel.Size = UDim2.new(nameLabel.Size.X.Scale, nameLabel.Size.X.Offset, nameLabel.Size.Y.Scale, nameLabel.Size.Y.Offset + 4)
      end
      local nameBackgroundImage = utility:Create'ImageLabel'
      {
        Name = text .. "BackgroundImage",
        Size = UDim2.new(1,0,1,0),
        Position = UDim2.new(0,0,0,2),
        BackgroundTransparency = 1,
        Image = "rbxasset://textures/ui/Settings/Radial/RadialLabel.png",
        ScaleType = Enum.ScaleType.Slice,
        SliceCenter = Rect.new(12,2,65,21),
        ZIndex = 2,
        Parent = nameLabel
      };

      return nameLabel
    end

    local function createTouchGestureImage(name, image, position, size, parent)
      local gestureImage = utility:Create'ImageLabel'
      {
        Name = name,
        Size = size,
        Position = position,
        BackgroundTransparency = 1,
        Image = image,
        ZIndex = 2,
        Parent = parent
      };

      return gestureImage
    end

    local xSizeOffset = 30
    local ySize = 25
    if smallScreen then xSizeOffset = 0 end

    local moveLabel = createTouchLabel("Move", UDim2.new(0.06,0,0.58,0), UDim2.new(0,77 + xSizeOffset,0,ySize), parentFrame)
    if not smallScreen then moveLabel.Position = UDim2.new(-0.03,0,0.7,0) end
    local jumpLabel = createTouchLabel("Jump", UDim2.new(0.8,0,0.58,0), UDim2.new(0,77 + xSizeOffset,0,ySize), parentFrame)
    if not smallScreen then jumpLabel.Position = UDim2.new(0.85,0,0.7,0) end
    local equipLabel = createTouchLabel("Equip/Unequip Tools", UDim2.new(0.5,-60,0.64,0), UDim2.new(0,120 + xSizeOffset,0,ySize), parentFrame)
    if not smallScreen then equipLabel.Position = UDim2.new(0.5,-60,0.95,0) end

    local zoomLabel = createTouchLabel("Zoom In/Out", UDim2.new(0.15,-60,0.02,0), UDim2.new(0,120,0,ySize), parentFrame)
    createTouchGestureImage("ZoomImage", "rbxasset://textures/ui/Settings/Help/ZoomGesture.png", UDim2.new(0.5,-26,1,3), UDim2.new(0,53,0,59), zoomLabel)
    local rotateLabel = createTouchLabel("Rotate Camera", UDim2.new(0.5,-60,0.02,0), UDim2.new(0,120,0,ySize), parentFrame)
    createTouchGestureImage("RotateImage", "rbxasset://textures/ui/Settings/Help/RotateCameraGesture.png", UDim2.new(0.5,-32,1,3), UDim2.new(0,65,0,48), rotateLabel)
    local useToolLabel = createTouchLabel("Use Tool", UDim2.new(0.85,-60,0.02,0), UDim2.new(0,120,0,ySize), parentFrame)
    createTouchGestureImage("ToolImage", "rbxasset://textures/ui/Settings/Help/UseToolGesture.png", UDim2.new(0.5,-19,1,3), UDim2.new(0,38,0,52), useToolLabel)

  end

  local function createHelpDisplay(typeOfHelp)
    local helpFrame = utility:Create'Frame'
    {
      Size = UDim2.new(1,0,1,0),
      BackgroundTransparency = 1,
      Name = "HelpFrame" .. tostring(typeOfHelp)
    };

    if typeOfHelp == KEYBOARD_MOUSE_TAG then
      createPCHelp(helpFrame)
    elseif typeOfHelp == GAMEPAD_TAG then
      createGamepadHelp(helpFrame)
    elseif typeOfHelp == TOUCH_TAG then
      createTouchHelp(helpFrame)
    end

    return helpFrame
  end

  local function displayHelp(currentPage)
    for i, helpPage in pairs(this.HelpPages) do
      if helpPage == currentPage then
        helpPage.Parent = this.Page
        this.Page.Size = helpPage.Size
      else
        helpPage.Parent = nil
      end
    end
    if UserInputService:GetPlatform() == Enum.Platform.XBoxOne then
      this.HubRef.PageViewClipper.ClipsDescendants = false
      this.HubRef.PageView.ClipsDescendants = false
    end
  end

  local function switchToHelp(typeOfHelp)
    local helpPage = this.HelpPages[typeOfHelp]
    if helpPage then
      displayHelp(helpPage)
    else
      this.HelpPages[typeOfHelp] = createHelpDisplay(typeOfHelp)
      switchToHelp(typeOfHelp)
    end
  end

  local function showTypeOfHelp()
    switchToHelp(this:GetCurrentInputType())
  end

  ------ TAB CUSTOMIZATION -------
  this.TabHeader.Name = "HelpTab"

  this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/HelpTab.png"

  if utility:IsSmallTouchScreen() then
    this.TabHeader.Icon.Size = UDim2.new(0,33,0,33)
    this.TabHeader.Icon.Position = UDim2.new(this.TabHeader.Icon.Position.X.Scale,this.TabHeader.Icon.Position.X.Offset,0.5,-16)
    this.TabHeader.Size = UDim2.new(0,100,1,0)
  elseif isTenFootInterface then
    this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/HelpTab@2x.png"
    this.TabHeader.Icon.Size = UDim2.new(0,90,0,90)
    this.TabHeader.Icon.Position = UDim2.new(0,0,0.5,-43)
    this.TabHeader.Size = UDim2.new(0,210,1,0)
  else
    this.TabHeader.Icon.Size = UDim2.new(0,44,0,44)
    this.TabHeader.Icon.Position = UDim2.new(this.TabHeader.Icon.Position.X.Scale,this.TabHeader.Icon.Position.X.Offset,0.5,-22)
    this.TabHeader.Size = UDim2.new(0,130,1,0)
  end

  this.TabHeader.Icon.Title.Text = "Help"


  ------ PAGE CUSTOMIZATION -------
  this.Page.Name = "Help"

  UserInputService.InputBegan:connect(function(inputObject)
      local inputType = inputObject.UserInputType
      if inputType ~= Enum.UserInputType.Focus and inputType ~= Enum.UserInputType.None then
        lastInputType = inputObject.UserInputType
        showTypeOfHelp()
      end
    end)

  return this
end


----------- Public Facing API Additions --------------
do
  PageInstance = Initialize()

  PageInstance.Displayed.Event:connect(function()
      if PageInstance:GetCurrentInputType() == TOUCH_TAG then
        if PageInstance.HubRef.BottomButtonFrame and not utility:IsSmallTouchScreen() then
          PageInstance.HubRef.BottomButtonFrame.Visible = false
        end
      end
    end)

  PageInstance.Hidden.Event:connect(function()
      PageInstance.HubRef.PageViewClipper.ClipsDescendants = true
      PageInstance.HubRef.PageView.ClipsDescendants = true

      PageInstance.HubRef:ShowShield()

      if PageInstance:GetCurrentInputType() == TOUCH_TAG then
        if PageInstance.HubRef.BottomButtonFrame then
          PageInstance.HubRef.BottomButtonFrame.Visible = true
        end
      end
    end)
end


return PageInstance]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX928C1617FB234238A974AD7C24CCE08A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GameSettings</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
		Filename: GameSettings.lua
		Written by: jeditkacheff
		Version 1.1
		Description: Takes care of the Game Settings Tab in Settings Menu
--]]

-------------- SERVICES --------------
local CoreGui = game:GetService("CoreGui")
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local PlatformService = nil 
pcall(function() PlatformService = game:GetService("PlatformService") end)
local ContextActionService = game:GetService("ContextActionService")
local StarterGui = game:GetService("StarterGui")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

-------------- CONSTANTS --------------
local GRAPHICS_QUALITY_LEVELS = 10
local GRAPHICS_QUALITY_TO_INT = {
  ["Enum.SavedQualitySetting.Automatic"] = 0,
  ["Enum.SavedQualitySetting.QualityLevel1"] = 1,
  ["Enum.SavedQualitySetting.QualityLevel2"] = 2,
  ["Enum.SavedQualitySetting.QualityLevel3"] = 3,
  ["Enum.SavedQualitySetting.QualityLevel4"] = 4,
  ["Enum.SavedQualitySetting.QualityLevel5"] = 5,
  ["Enum.SavedQualitySetting.QualityLevel6"] = 6,
  ["Enum.SavedQualitySetting.QualityLevel7"] = 7,
  ["Enum.SavedQualitySetting.QualityLevel8"] = 8,
  ["Enum.SavedQualitySetting.QualityLevel9"] = 9,
  ["Enum.SavedQualitySetting.QualityLevel10"] = 10,
}
local PC_CHANGED_PROPS = {
  DevComputerMovementMode = true,
  DevComputerCameraMode = true,
  DevEnableMouseLock = true,
}
local TOUCH_CHANGED_PROPS = {
  DevTouchMovementMode = true,
  DevTouchCameraMode = true,
}
local CAMERA_MODE_DEFAULT_STRING = UserInputService.TouchEnabled and "Default (Follow)" or "Default (Classic)"

local MOVEMENT_MODE_DEFAULT_STRING = UserInputService.TouchEnabled and "Default (Thumbstick)" or "Default (Keyboard)"
local MOVEMENT_MODE_KEYBOARDMOUSE_STRING = "Keyboard + Mouse"
local MOVEMENT_MODE_CLICKTOMOVE_STRING = UserInputService.TouchEnabled and "Tap to Move" or "Click to Move"

----------- UTILITIES --------------
local utility = require(RobloxGui.Modules.Settings.Utility)

------------ Variables -------------------
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
RobloxGui:WaitForChild("Modules"):WaitForChild("Settings"):WaitForChild("SettingsHub")
local isTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()
local HasVRAPI = false
pcall(function() HasVRAPI = UserInputService.GetUserCFrame ~= nil end)
local PageInstance = nil
local LocalPlayer = game.Players.LocalPlayer
local platform = UserInputService:GetPlatform()
local overscanScreen = nil

----------- CLASS DECLARATION --------------

local function Initialize()
  local settingsPageFactory = require(RobloxGui.Modules.Settings.SettingsPageFactory)
  local this = settingsPageFactory:CreateNewPage()

  local allSettingsCreated = false
  local settingsDisabledInVR = {}
  local function onVRSettingsReady()
    local vrEnabled = UserInputService.VREnabled
    for settingFrame, _ in pairs(settingsDisabledInVR) do
      settingFrame:SetInteractable(not vrEnabled)
    end
  end

  local function onVREnabled(prop)
    if prop ~= "VREnabled" then return end
    if UserInputService.VREnabled and allSettingsCreated then
      --Only call this if all settings have been created. 
      --If they aren't ready by the time VR is enabled, this
      --will be called later when they are.
      onVRSettingsReady()
    end
  end
  UserInputService.Changed:connect(onVREnabled)
  onVREnabled("VREnabled")

  ----------- FUNCTIONS ---------------
  local function createGraphicsOptions()

    ------------------ Fullscreen Selection GUI Setup ------------------
    local fullScreenInit = 1
    if not GameSettings:InFullScreen() then
      fullScreenInit = 2
    end

    this.FullscreenFrame,
    this.FullscreenLabel,
    this.FullscreenEnabler = utility:AddNewRow(this, "Fullscreen", "Selector", {"On", "Off"}, fullScreenInit)

    settingsDisabledInVR[this.FullscreenEnabler] = true

    this.FullscreenEnabler.IndexChanged:connect(function(newIndex)
        if newIndex == 1 then
          if not GameSettings:InFullScreen() then
            GuiService:ToggleFullscreen()
            this.FullscreenEnabler:SetSelectionIndex(1)
          end
        elseif newIndex == 2 then
          if GameSettings:InFullScreen() then
            GuiService:ToggleFullscreen()
            this.FullscreenEnabler:SetSelectionIndex(2)
          end
        end
      end)

    GameSettings.FullscreenChanged:connect(function(isFullScreen)
        if isFullScreen then
          if this.FullscreenEnabler:GetSelectedIndex() ~= 1 then
            this.FullscreenEnabler:SetSelectionIndex(1)
          end
        else
          if this.FullscreenEnabler:GetSelectedIndex() ~= 2 then
            this.FullscreenEnabler:SetSelectionIndex(2)
          end	
        end
      end)

    ------------------ Gfx Enabler Selection GUI Setup ------------------
    local graphicsEnablerStart = 1
    if GameSettings.SavedQualityLevel ~= Enum.SavedQualitySetting.Automatic then
      graphicsEnablerStart = 2
    end

    this.GraphicsEnablerFrame, 
    this.GraphicsEnablerLabel,
    this.GraphicsQualityEnabler = utility:AddNewRow(this, "Graphics Mode", "Selector", {"Automatic", "Manual"}, graphicsEnablerStart)

    ------------------ Gfx Slider GUI Setup  ------------------
    this.GraphicsQualityFrame, 
    this.GraphicsQualityLabel,
    this.GraphicsQualitySlider = utility:AddNewRow(this, "Graphics Quality", "Slider", GRAPHICS_QUALITY_LEVELS, 1)
    this.GraphicsQualitySlider:SetMinStep(1)

    ------------------------------------------------------
    ------------------------- Connection Setup ----------------------------
    settings().Rendering.EnableFRM = true

    function SetGraphicsQuality(newValue, automaticSettingAllowed)
      local percentage = newValue/GRAPHICS_QUALITY_LEVELS
      local newQualityLevel = math.floor((settings().Rendering:GetMaxQualityLevel() - 1) * percentage)
      if newQualityLevel == 20 then
        newQualityLevel = 21
      elseif newValue == 1 then
        newQualityLevel = 1
      elseif newValue < 1 and not automaticSettingAllowed then
        newValue = 1
        newQualityLevel = 1
      elseif newQualityLevel > settings().Rendering:GetMaxQualityLevel() then
        newQualityLevel = settings().Rendering:GetMaxQualityLevel() - 1
      end

      GameSettings.SavedQualityLevel = newValue
      settings().Rendering.QualityLevel = newQualityLevel
    end

    local function setGraphicsToAuto()
      this.GraphicsQualitySlider:SetZIndex(1)
      this.GraphicsQualityLabel.ZIndex = 1
      this.GraphicsQualitySlider:SetInteractable(false)

      SetGraphicsQuality(Enum.QualityLevel.Automatic.Value, true)
    end

    local function setGraphicsToManual(level)
      this.GraphicsQualitySlider:SetZIndex(2)
      this.GraphicsQualityLabel.ZIndex = 2
      this.GraphicsQualitySlider:SetInteractable(true)

      -- need to force the quality change if slider is already at this position
      if this.GraphicsQualitySlider:GetValue() == level then
        SetGraphicsQuality(level)
      else
        this.GraphicsQualitySlider:SetValue(level)
      end
    end

    game.GraphicsQualityChangeRequest:connect(function(isIncrease)
        --  was using settings().Rendering.Quality level, which was wrongly saying it was automatic.
        if GameSettings.SavedQualityLevel == Enum.SavedQualitySetting.Automatic then return end
        local currentGraphicsSliderValue = this.GraphicsQualitySlider:GetValue()
        if isIncrease then
          currentGraphicsSliderValue = currentGraphicsSliderValue + 1
        else
          currentGraphicsSliderValue = currentGraphicsSliderValue - 1
        end

        this.GraphicsQualitySlider:SetValue(currentGraphicsSliderValue)
      end)

    this.GraphicsQualitySlider.ValueChanged:connect(function(newValue)
        SetGraphicsQuality(newValue)
      end)

    this.GraphicsQualityEnabler.IndexChanged:connect(function(newIndex)
        if newIndex == 1 then
          setGraphicsToAuto()
        elseif newIndex == 2 then
          setGraphicsToManual( this.GraphicsQualitySlider:GetValue() )
        end
      end)

    -- initialize the slider position
    if GameSettings.SavedQualityLevel == Enum.SavedQualitySetting.Automatic then
      this.GraphicsQualitySlider:SetValue(5)
      setGraphicsToAuto()
    else
      local graphicsLevel = tostring(GameSettings.SavedQualityLevel)
      if GRAPHICS_QUALITY_TO_INT[graphicsLevel] then
        graphicsLevel = GRAPHICS_QUALITY_TO_INT[graphicsLevel]
      else
        graphicsLevel = GRAPHICS_QUALITY_LEVELS
      end

      spawn(function()
          this.GraphicsQualitySlider:SetValue(graphicsLevel)
        end)
    end
  end  -- of createGraphicsOptions
  
  local function createPerformanceStatsOptions()    
    ------------------
    ------------------ Performance Stats -----------------
    this.PerformanceStatsFrame, 
    this.PerformanceStatsLabel,
    this.PerformanceStatsMode,
    this.PerformanceStatsOverrideText = nil

    function GetDesiredPerformanceStatsIndex()
      if GameSettings.PerformanceStatsVisible then
        return 1
      else
        return 2
      end
    end

    local startIndex = GetDesiredPerformanceStatsIndex()

    this.PerformanceStatsFrame, 
    this.PerformanceStatsLabel,
    this.PerformanceStatsMode = utility:AddNewRow(this, 
      "Performance Stats", 
      "Selector", 
      {"On", "Off"}, 
      startIndex)

    this.PerformanceStatsOverrideText = utility:Create'TextLabel'
    {
      Name = "PerformanceStatsLabel",
      Text = "Set by Developer",
      TextColor3 = Color3.new(1,1,1),
      Font = Enum.Font.SourceSans,
      FontSize = Enum.FontSize.Size24,
      BackgroundTransparency = 1,
      Size = UDim2.new(0,200,1,0),
      Position = UDim2.new(1,-350,0,0),
      Visible = false,
      ZIndex = 2,
      Parent = this.PerformanceStatsFrame
    };

    this.PerformanceStatsMode.IndexChanged:connect(function(newIndex)
        if newIndex == 1 then
          GameSettings.PerformanceStatsVisible = true
        else
          GameSettings.PerformanceStatsVisible = false
        end
      end)
    
    GameSettings.PerformanceStatsVisibleChanged:connect(function()
        local desiredIndex = GetDesiredPerformanceStatsIndex()
        if desiredIndex ~= this.PerformanceStatsMode.CurrentIndex then 
          this.PerformanceStatsMode:SetSelectionIndex(desiredIndex)
        end
      end)
  end  -- of createPerformanceStats

  local function createCameraModeOptions(movementModeEnabled)
    ------------------------------------------------------
    ------------------
    ------------------ Shift Lock Switch -----------------
    if UserInputService.MouseEnabled then
      this.ShiftLockFrame, 
      this.ShiftLockLabel,
      this.ShiftLockMode,
      this.ShiftLockOverrideText = nil

      if UserInputService.MouseEnabled and UserInputService.KeyboardEnabled then
        local startIndex = 2
        if GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch then
          startIndex = 1
        end

        this.ShiftLockFrame, 
        this.ShiftLockLabel,
        this.ShiftLockMode = utility:AddNewRow(this,
          "Shift Lock Switch", 
          "Selector",
          {"On", "Off"},
          startIndex)

        settingsDisabledInVR[this.ShiftLockMode] = true

        this.ShiftLockOverrideText = utility:Create'TextLabel'
        {
          Name = "ShiftLockOverrideLabel",
          Text = "Set by Developer",
          TextColor3 = Color3.new(1,1,1),
          Font = Enum.Font.SourceSans,
          FontSize = Enum.FontSize.Size24,
          BackgroundTransparency = 1,
          Size = UDim2.new(0,200,1,0),
          Position = UDim2.new(1,-350,0,0),
          Visible = false,
          ZIndex = 2,
          Parent = this.ShiftLockFrame
        };

        this.ShiftLockMode.IndexChanged:connect(function(newIndex)
            if newIndex == 1 then
              GameSettings.ControlMode = Enum.ControlMode.MouseLockSwitch
            else
              GameSettings.ControlMode = Enum.ControlMode.Classic
            end
          end)
      end
    end


    ------------------------------------------------------
    ------------------
    ------------------ Camera Mode -----------------------
    do
      local enumItems = nil
      local startingCameraEnumItem = 1
      if UserInputService.TouchEnabled then
        enumItems = Enum.TouchCameraMovementMode:GetEnumItems()
      else
        enumItems = Enum.ComputerCameraMovementMode:GetEnumItems()
      end

      local cameraEnumNames = {}
      local cameraEnumNameToItem = {}
      for i = 1, #enumItems do
        local displayName = enumItems[i].Name
        if displayName == 'Default' then
          displayName = CAMERA_MODE_DEFAULT_STRING
        end

        if UserInputService.TouchEnabled then
          if GameSettings.TouchCameraMovementMode == enumItems[i] then
            startingCameraEnumItem = i
          end
        else
          if GameSettings.ComputerCameraMovementMode == enumItems[i] then
            startingCameraEnumItem = i
          end
        end

        cameraEnumNames[i] = displayName
        cameraEnumNameToItem[displayName] = enumItems[i].Value
      end

      this.CameraModeFrame, 
      this.CameraModeLabel,
      this.CameraMode = utility:AddNewRow(this, "Camera Mode", "Selector", cameraEnumNames, startingCameraEnumItem)

      settingsDisabledInVR[this.CameraMode] = true

      this.CameraModeOverrideText = utility:Create'TextLabel'
      {
        Name = "CameraDevOverrideLabel",
        Text = "Set by Developer",
        TextColor3 = Color3.new(1,1,1),
        Font = Enum.Font.SourceSans,
        FontSize = Enum.FontSize.Size24,
        BackgroundTransparency = 1,
        Size = UDim2.new(0,200,1,0),
        Position = UDim2.new(1,-350,0,0),
        Visible = false,
        ZIndex = 2,
        Parent = this.CameraModeFrame
      };

      this.CameraMode.IndexChanged:connect(function(newIndex)
          local newEnumSetting = cameraEnumNameToItem[cameraEnumNames[newIndex]]

          if UserInputService.TouchEnabled then
            GameSettings.TouchCameraMovementMode = newEnumSetting
          else
            GameSettings.ComputerCameraMovementMode = newEnumSetting
          end
        end)
    end


    ------------------------------------------------------
    ------------------
    ------------------ VR Camera Mode -----------------------

    if HasVRAPI and UserInputService.VREnabled then
      local VR_ROTATION_INTENSITY_OPTIONS = {"Low", "High", "Smooth"}

      if utility:IsSmallTouchScreen() then
        this.VRRotationFrame, 
        this.VRRotationLabel,
        this.VRRotationMode = utility:AddNewRow(this, "VR Camera Rotation", "Selector", VR_ROTATION_INTENSITY_OPTIONS, GameSettings.VRRotationIntensity)
      else
        this.VRRotationFrame, 
        this.VRRotationLabel,
        this.VRRotationMode = utility:AddNewRow(this, "VR Camera Rotation", "Selector", VR_ROTATION_INTENSITY_OPTIONS, GameSettings.VRRotationIntensity, 3)
      end

      StarterGui:RegisterGetCore("VRRotationIntensity",
        function()
          return VR_ROTATION_INTENSITY_OPTIONS[GameSettings.VRRotationIntensity] or VR_ROTATION_INTENSITY_OPTIONS[1]
        end)
      this.VRRotationMode.IndexChanged:connect(function(newIndex)
          GameSettings.VRRotationIntensity = newIndex
        end)
    end

    ------------------------------------------------------
    ------------------
    ------------------ Movement Mode ---------------------
    if movementModeEnabled then
      local movementEnumItems = nil
      local startingMovementEnumItem = 1
      if UserInputService.TouchEnabled then
        movementEnumItems = Enum.TouchMovementMode:GetEnumItems()
      else
        movementEnumItems = Enum.ComputerMovementMode:GetEnumItems()
      end

      local movementEnumNames = {}
      local movementEnumNameToItem = {}
      for i = 1, #movementEnumItems do
        local displayName = movementEnumItems[i].Name
        if displayName == "Default" then
          displayName = MOVEMENT_MODE_DEFAULT_STRING
        elseif displayName == "KeyboardMouse" then
          displayName = MOVEMENT_MODE_KEYBOARDMOUSE_STRING
        elseif displayName == "ClickToMove" then
          displayName = MOVEMENT_MODE_CLICKTOMOVE_STRING
        end

        if UserInputService.TouchEnabled then
          if GameSettings.TouchMovementMode == movementEnumItems[i] then
            startingMovementEnumItem = i
          end
        else
          if GameSettings.ComputerMovementMode == movementEnumItems[i] then
            startingMovementEnumItem = i
          end
        end

        movementEnumNames[i] = displayName
        movementEnumNameToItem[displayName] = movementEnumItems[i]
      end

      this.MovementModeFrame, 
      this.MovementModeLabel,
      this.MovementMode = utility:AddNewRow(this, "Movement Mode", "Selector", movementEnumNames, startingMovementEnumItem)

      settingsDisabledInVR[this.MovementMode] = true

      this.MovementModeOverrideText = utility:Create'TextLabel'
      {
        Name = "MovementDevOverrideLabel",
        Text = "Set by Developer",
        TextColor3 = Color3.new(1,1,1),
        Font = Enum.Font.SourceSans,
        FontSize = Enum.FontSize.Size24,
        BackgroundTransparency = 1,
        Size = UDim2.new(0,200,1,0),
        Position = UDim2.new(1,-350,0,0),
        Visible = false,
        ZIndex = 2,
        Parent = this.MovementModeFrame
      };

      this.MovementMode.IndexChanged:connect(function(newIndex)
          local newEnumSetting = movementEnumNameToItem[movementEnumNames[newIndex]]

          if UserInputService.TouchEnabled then
            GameSettings.TouchMovementMode = newEnumSetting
          else
            GameSettings.ComputerMovementMode = newEnumSetting
          end
        end)
    end


    ------------------------------------------------------
    ------------------
    ------------------------- Connection Setup -----------
    function setCameraModeVisible(visible)
      if this.CameraMode then
        this.CameraMode.SelectorFrame.Visible = visible
        this.CameraMode:SetInteractable(visible)
      end
    end

    function setMovementModeVisible(visible)
      if this.MovementMode then
        this.MovementMode.SelectorFrame.Visible = visible
        this.MovementMode:SetInteractable(visible)
      end
    end

    function setShiftLockVisible(visible)
      if this.ShiftLockMode then
        this.ShiftLockMode.SelectorFrame.Visible = visible
        this.ShiftLockMode:SetInteractable(visible)
      end
    end

    do -- initial set of dev vs user choice for guis
      local isUserChoiceCamera = false
      if UserInputService.TouchEnabled then
        isUserChoiceCamera = LocalPlayer.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice
      else
        isUserChoiceCamera = LocalPlayer.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice
      end

      if not isUserChoiceCamera then
        this.CameraModeOverrideText.Visible = true
        setCameraModeVisible(false)
      else
        this.CameraModeOverrideText.Visible = false
        setCameraModeVisible(true)
      end


      local isUserChoiceMovement = false
      if UserInputService.TouchEnabled then
        isUserChoiceMovement = LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice
      else
        isUserChoiceMovement = LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice
      end

      if this.MovementModeOverrideText then
        if not isUserChoiceMovement then
          this.MovementModeOverrideText.Visible = true
          setMovementModeVisible(false)
        else
          this.MovementModeOverrideText.Visible = false
          setMovementModeVisible(true)
        end
      end

      if this.ShiftLockOverrideText then
        this.ShiftLockOverrideText.Visible = not LocalPlayer.DevEnableMouseLock
        setShiftLockVisible(LocalPlayer.DevEnableMouseLock)
      end
    end

    local function updateUserSettingsMenu(property)
      if this.ShiftLockOverrideText and property == "DevEnableMouseLock" then
        this.ShiftLockOverrideText.Visible = not LocalPlayer.DevEnableMouseLock
        setShiftLockVisible(LocalPlayer.DevEnableMouseLock)
      elseif property == "DevComputerCameraMode" then
        local isUserChoice = LocalPlayer.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice
        setCameraModeVisible(isUserChoice)
        this.CameraModeOverrideText.Visible = not isUserChoice
      elseif property == "DevComputerMovementMode" then
        local isUserChoice = LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice
        setMovementModeVisible(isUserChoice)
        if this.MovementModeOverrideText then
          this.MovementModeOverrideText.Visible = not isUserChoice
        end
        -- TOUCH
      elseif property == "DevTouchMovementMode" then
        local isUserChoice = LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice
        setMovementModeVisible(isUserChoice)
        if this.MovementModeOverrideText then
          this.MovementModeOverrideText.Visible = not isUserChoice
        end
      elseif property == "DevTouchCameraMode" then
        local isUserChoice = LocalPlayer.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice
        setCameraModeVisible(isUserChoice)
        this.CameraModeOverrideText.Visible = not isUserChoice
      end
    end

    LocalPlayer.Changed:connect(function(property)
        if UserInputService.TouchEnabled then
          if TOUCH_CHANGED_PROPS[property] then
            updateUserSettingsMenu(property)
          end
        end
        if UserInputService.KeyboardEnabled then
          if PC_CHANGED_PROPS[property] then
            updateUserSettingsMenu(property)
          end
        end
      end)
  end

  local function createVolumeOptions()
    local startVolumeLevel = math.floor(GameSettings.MasterVolume * 10)
    this.VolumeFrame, 
    this.VolumeLabel,
    this.VolumeSlider = utility:AddNewRow(this, "Volume", "Slider", 10, startVolumeLevel)

    local volumeSound = Instance.new("Sound", game.CoreGui.RobloxGui.Sounds)
    volumeSound.Name = "VolumeChangeSound"
    volumeSound.SoundId = "rbxasset://sounds/metalstone2.mp3"

    this.VolumeSlider.ValueChanged:connect(function(newValue)
        local soundPercent = newValue/10
        volumeSound.Volume = soundPercent
        volumeSound:Play()
        GameSettings.MasterVolume = soundPercent
      end)
  end

  local function createMouseOptions()
    local MouseSteps = 10
    local MinMouseSensitivity = 0.2
    local AdvancedSuccess, AdvancedValue = pcall(function() return settings():GetFFlag("AdvancedMouseSensitivityEnabled") end)
    local AdvancedEnabled = AdvancedSuccess and AdvancedValue 

    -- equations below map a function to include points (0, 0.2) (5, 1) (10, 4)
    -- where x is the slider position, y is the mouse sensitivity
    local function translateEngineMouseSensitivityToGui(engineSensitivity)
      return math.floor((2.0/3.0) * (math.sqrt(75.0 * engineSensitivity - 11.0) - 2))
    end

    local function translateGuiMouseSensitivityToEngine(guiSensitivity)
      return 0.03 * math.pow(guiSensitivity,2) + (0.08 * guiSensitivity) + MinMouseSensitivity
    end

    local startMouseLevel = translateEngineMouseSensitivityToGui(GameSettings.MouseSensitivity)

    ------------------ Mouse Selection GUI Setup ------------------
    -- switch between basic mode and advanced mode.
    local MouseModeEnablerStart = 2
    if GameSettings.UseBasicMouseSensitivity or not AdvancedEnabled then
      MouseModeEnablerStart = 1
    end

    -- auto-detect mouse invert
    local MouseInvertStart = 1
    if GameSettings.MouseSensitivityFirstPerson.y < 0 then
      MouseInvertStart = 2
    end

    if AdvancedEnabled then
      this.MouseModeFrame, 
      this.MouseModeLabel,
      this.MouseModeEnabler = utility:AddNewRow(this, "Mouse Sensitivity Mode", "Selector", {"Basic", "Advanced"}, MouseModeEnablerStart)
    end

    ------------------ Basic Mouse Sensitivity Slider ------------------
    -- basic quantized sensitivity with a weird number of settings.
    local SliderLabel = "Basic Mouse Sensitivity"
    if not AdvancedEnabled then
      SliderLabel = "Mouse Sensitivity"
    end
    this.MouseSensitivityFrame, 
    this.MouseSensitivityLabel,
    this.MouseSensitivitySlider = utility:AddNewRow(this, SliderLabel, "Slider", MouseSteps, startMouseLevel)
    this.MouseSensitivitySlider:SetMinStep(1)

    this.MouseSensitivitySlider.ValueChanged:connect(function(newValue)
        GameSettings.MouseSensitivity = translateGuiMouseSensitivityToEngine(newValue)
      end)

    ------------------ 3D Sensitivity ------------------
    -- affects both first and third person.
    if AdvancedEnabled then
      local MouseAdvancedStart = tostring(GameSettings.MouseSensitivityFirstPerson.y)
      this.MouseAdvancedFrame, 
      this.MouseAdvancedLabel,
      this.MouseAdvancedEntry = utility:AddNewRow(this, "Advanced Mouse Sensitivity", "TextEntry", 1.0, 1.0, MouseAdvancedStart)

      this.MouseAdvancedEntry.ValueChanged:connect(function(newValueText)
          local currentFirstSensitivity = GameSettings.MouseSensitivityFirstPerson
          local currentThirdSensitivity = GameSettings.MouseSensitivityThirdPerson

          local newValue = tonumber(newValueText)
          if not newValue then
            this.MouseAdvancedEntry:SetValue(string.format("%.3f",currentFirstSensitivity.x))
            return
          end

          -- inverted mouse will be handled later
          if newValue < 0.0 then
            newValue = -newValue
          end

          -- * assume a minimum that allows a 16000 dpi mouse a full 800mm travel for 360deg 
          --   ~0.0029: min of 0.001 seems ok.
          -- * assume a max that allows a 400 dpi mouse a 360deg travel in 10mm
          --   ~9.2: max of 10 seems ok, but users will want to have a bit of fun with crazy settings.
          if newValue > 100.0 then
            newValue = 100.0
          elseif newValue < 0.001 then
            newValue = 0.001
          end

          -- try to keep ratios the same, even though they aren't exposed to the GUI
          local firstPersonX = newValue
          local firstPersonY = newValue * (currentFirstSensitivity.y / currentFirstSensitivity.x)
          local thirdPersonX = newValue * (currentFirstSensitivity.x / currentThirdSensitivity.x)
          local thirdPersonY = thirdPersonX * (currentThirdSensitivity.y / currentThirdSensitivity.x)

          GameSettings.MouseSensitivityFirstPerson = Vector2.new(firstPersonX, firstPersonY)
          GameSettings.MouseSensitivityThirdPerson = Vector2.new(thirdPersonX, thirdPersonY)
          this.MouseAdvancedEntry:SetValue(string.format("%.3f",firstPersonX))

        end)
    end

    ------------------ Mouse Invert ------------------
    -- This is a common setting in games, even if it is rare
    if AdvancedEnabled then
      this.MouseInvertFrame, 
      this.MouseInvertLabel,
      this.MouseInvertEnabler = utility:AddNewRow(this, "Advanced Mouse Invert", "Selector", {"Normal", "Inverted"}, MouseInvertStart)

      this.MouseInvertEnabler.IndexChanged:connect(function(newIndex)
          local currentFirstSensitivity = GameSettings.MouseSensitivityFirstPerson
          local currentThirdSensitivity = GameSettings.MouseSensitivityThirdPerson

          if newIndex == 1 then
            if currentFirstSensitivity.y < 0.0 then
              currentFirstSensitivity = Vector2.new(currentFirstSensitivity.x, -currentFirstSensitivity.y)
              currentThirdSensitivity = Vector2.new(currentThirdSensitivity.x, -currentThirdSensitivity.y)
            end
          elseif newIndex == 2 then
            if currentFirstSensitivity.y > 0.0 then
              currentFirstSensitivity = Vector2.new(currentFirstSensitivity.x, -currentFirstSensitivity.y)
              currentThirdSensitivity = Vector2.new(currentThirdSensitivity.x, -currentThirdSensitivity.y)
            end
          end
          GameSettings.MouseSensitivityFirstPerson = currentFirstSensitivity
          GameSettings.MouseSensitivityThirdPerson = currentThirdSensitivity
        end)
    end

    ------------------ Init ------------------
    if AdvancedEnabled then
      local function setMouseModeToBasic()
        this.MouseSensitivitySlider:SetZIndex(2)
        this.MouseSensitivityLabel.ZIndex = 2
        this.MouseSensitivitySlider:SetInteractable(true)
        this.MouseSensitivitySlider:SetValue(translateEngineMouseSensitivityToGui(GameSettings.MouseSensitivity))

        this.MouseAdvancedLabel.ZIndex = 1
        this.MouseAdvancedEntry:SetInteractable(false)

        this.MouseInvertLabel.ZIndex = 1
        this.MouseInvertEnabler:SetInteractable(false)

      end
      local function setMouseModeToAdvanced()
        this.MouseSensitivitySlider:SetZIndex(1)
        this.MouseSensitivityLabel.ZIndex = 1
        this.MouseSensitivitySlider:SetInteractable(false)

        this.MouseAdvancedLabel.ZIndex = 2
        this.MouseAdvancedEntry:SetInteractable(true)
        local MouseSensitivity3d = GameSettings.MouseSensitivityFirstPerson
        this.MouseAdvancedEntry:SetValue(tostring(MouseSensitivity3d.x));

        this.MouseInvertLabel.ZIndex = 2
        this.MouseInvertEnabler:SetInteractable(true)

      end

      this.MouseModeEnabler.IndexChanged:connect(function(newIndex)
          if newIndex == 1 then
            GameSettings.UseBasicMouseSensitivity = true
            setMouseModeToBasic()
          elseif newIndex == 2 then
            GameSettings.UseBasicMouseSensitivity = false
            setMouseModeToAdvanced()
          end
        end)

      if GameSettings.UseBasicMouseSensitivity then
        local MouseAdvancedStart = tostring(GameSettings.MouseSensitivityFirstPerson.x)
        setMouseModeToBasic()
        this.MouseAdvancedEntry:SetValue(MouseAdvancedStart)
      else
        setMouseModeToAdvanced()
      end
    end

  end

  local function createOverscanOption()
    local showOverscanScreen = function()

      if not overscanScreen then
        local overscanModule = RobloxGui.Modules:FindFirstChild('OverscanScreen')
        if not overscanModule then
          overscanModule = RobloxGui.Modules.Shell.OverscanScreen
        end
        local createOverscanFunc = require(overscanModule)
        overscanScreen = createOverscanFunc(RobloxGui)
        overscanScreen:SetStyleForInGame()
      end

      local MenuModule = require(RobloxGui.Modules.Settings.SettingsHub)
      MenuModule:SetVisibility(false, true)

      local closedCon = nil
      closedCon = overscanScreen.Closed:connect(function()
          closedCon:disconnect()
          pcall(function() PlatformService.BlurIntensity = 0 end)
          ContextActionService:UnbindCoreAction("RbxStopOverscanMovement")
          MenuModule:SetVisibility(true, true)
        end)

      pcall(function() PlatformService.BlurIntensity = 10 end)

      local noOpFunc = function() end
      ContextActionService:BindCoreAction("RbxStopOverscanMovement", noOpFunc, false,
        Enum.UserInputType.Gamepad1, Enum.UserInputType.Gamepad2,
        Enum.UserInputType.Gamepad3, Enum.UserInputType.Gamepad4)

      local screenManagerModule = RobloxGui.Modules:FindFirstChild('ScreenManager')
      if not screenManagerModule then
        screenManagerModule = RobloxGui.Modules.Shell.ScreenManager
      end
      local ScreenManager = require(screenManagerModule)
      ScreenManager:OpenScreen(overscanScreen)

    end

    local adjustButton, adjustText, setButtonRowRef = utility:MakeStyledButton("AdjustButton", "Adjust", UDim2.new(0,300,1,-20), showOverscanScreen, this)
    adjustText.Font = Enum.Font.SourceSans
    adjustButton.Position = UDim2.new(1,-400,0,12)

    local row = utility:AddNewRowObject(this, "Safe Zone", adjustButton)
    setButtonRowRef(row)
  end

  local function createDeveloperConsoleOption()
    -- makes button in settings menu to open dev console
    local function makeDevConsoleOption()
      local devConsoleModule = require(RobloxGui.Modules.DeveloperConsoleModule)
      local function onOpenDevConsole()
        if devConsoleModule then
          devConsoleModule:SetVisibility(true)
        end
      end

      local devConsoleButton, devConsoleText, setButtonRowRef = utility:MakeStyledButton("DevConsoleButton", "Open", UDim2.new(0, 300, 1, -20), onOpenDevConsole, this)
      devConsoleText.Font = Enum.Font.SourceSans
      devConsoleButton.Position = UDim2.new(1, -400, 0, 12)
      local row = utility:AddNewRowObject(this, "Developer Console", devConsoleButton)
      setButtonRowRef(row)
    end

    -- Only show option if we are place/group owner
    if game.CreatorType == Enum.CreatorType.Group then
      spawn(function()
          -- spawn since GetRankInGroup is async
          local success, result = pcall(function()
              return LocalPlayer:GetRankInGroup(game.CreatorId) == 255
            end)
          if success then
            if result == true then
              makeDevConsoleOption()
            end
          else
            print("DeveloperConsoleModule: GetRankInGroup failed because", result)
          end
        end)
    elseif LocalPlayer.UserId == game.CreatorId and game.CreatorType == Enum.CreatorType.User then
      makeDevConsoleOption()
    end
  end

  createCameraModeOptions(not isTenFootInterface and 
    (UserInputService.TouchEnabled or UserInputService.MouseEnabled or UserInputService.KeyboardEnabled))

  if UserInputService.MouseEnabled then
    createMouseOptions()
  end

  createVolumeOptions()

  if platform == Enum.Platform.Windows or platform == Enum.Platform.UWP or platform == Enum.Platform.OSX then
    createGraphicsOptions()
  end

  createPerformanceStatsOptions()

  if isTenFootInterface then
    createOverscanOption()

    -- enable dev console for xbox
    local success, result = pcall(function()
        return settings():GetFFlag("EnableDevConsoleOnXbox")
      end)
    if success and result == true then
      createDeveloperConsoleOption()
    end
  end

  allSettingsCreated = true
  if UserInputService.VREnabled then
    onVRSettingsReady()
  end

  ------ TAB CUSTOMIZATION -------
  this.TabHeader.Name = "GameSettingsTab"

  this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/GameSettingsTab.png"
  if utility:IsSmallTouchScreen() then
    this.TabHeader.Icon.Size = UDim2.new(0,34,0,34)
    this.TabHeader.Icon.Position = UDim2.new(this.TabHeader.Icon.Position.X.Scale,this.TabHeader.Icon.Position.X.Offset,0.5,-17)
    this.TabHeader.Size = UDim2.new(0,125,1,0)
  elseif isTenFootInterface then
    this.TabHeader.Icon.Image = "rbxasset://textures/ui/Settings/MenuBarIcons/GameSettingsTab@2x.png"
    this.TabHeader.Icon.Size = UDim2.new(0,90,0,90)
    this.TabHeader.Icon.Position = UDim2.new(0,0,0.5,-43)
    this.TabHeader.Size = UDim2.new(0,280,1,0)
  else
    this.TabHeader.Icon.Size = UDim2.new(0,45,0,45)
    this.TabHeader.Icon.Position = UDim2.new(0,15,0.5,-22)
  end


  this.TabHeader.Icon.Title.Text = "Settings"

  ------ PAGE CUSTOMIZATION -------
  this.Page.ZIndex = 5

  return this
end


----------- Page Instantiation --------------

PageInstance = Initialize()

return PageInstance
]]></ProtectedString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXC6220306B77441FEB1465E2CA6C66023">
				<Properties>
					<string name="Name">Server</string>
				</Properties>
				<Item class="ModuleScript" referent="RBX3D3EA4DEE1B146F88374025293FB494E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ServerUtil</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source">return {}</ProtectedString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX8A054DF45876487EAE61A7DC7C71C6E4">
					<Properties>
						<string name="Name">ServerChat</string>
					</Properties>
					<Item class="Folder" referent="RBX467FDC4413BA4C84B1FE49F65721F56A">
						<Properties>
							<string name="Name">DefaultChatModules</string>
						</Properties>
						<Item class="ModuleScript" referent="RBX83EA18494776488CA990BD53FB103132">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">MeCommand</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: MeCommand.lua
--	// Written by: TheGamer101
--	// Description: Sets the type of /me messages.

local Chat = game:GetService("Chat")
local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))

local function Run(ChatService)

	local function MeCommandFilterFunction(speakerName, messageObj, channelName)
		local message = messageObj.Message
		if message and string.sub(message, 1, 4):lower() == "/me " then
			-- Set a different message type so that clients can render the message differently.
			messageObj.MessageType = ChatConstants.MessageTypeMeCommand
		end
	end

	ChatService:RegisterFilterMessageFunction("me_command", MeCommandFilterFunction)
end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX49BA5AA8939A4C0C9CE3103BE964CEFC">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ExtraDataInitializer</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: ExtraDataInitializer.lua
--	// Written by: Xsitsu
--	// Description: Module that sets some basic ExtraData such as name color, and chat color.

local SpecialChatColors = {
	Groups = {
		{
			--- ROBLOX Interns group
			GroupId = 2868472,
			Rank = 100,
			ChatColor = Color3.new(175/255, 221/255, 1),
		},
		{
			--- ROBLOX Admins group
			GroupId = 1200769,
			ChatColor = Color3.new(1, 215/255, 0),
		},
	},
	Players = {
		{
			--- Left as an example
			--  UserId = 2231221,
			--  ChatColor = Color3.new(205/255, 0, 0)
		}
	}
}

local function MakeIsInGroup(groupId, requiredRank)
	assert(type(requiredRank) == "nil" or type(requiredRank) == "number", "requiredRank must be a number or nil")

	local inGroupCache = {}
	return function(player)
		if player and player.userId then
			local userId = player.userId

			if inGroupCache[userId] == nil then
				local inGroup = false
				local success, err = pcall(function() -- Many things can error is the IsInGroup check
					if requiredRank then
						inGroup = player:GetRankInGroup(groupId) > requiredRank
					else
						inGroup = player:IsInGroup(groupId)
					end
				end)
				if not success and err then
					print("Error checking in group: " ..err)
				end
				inGroupCache[userId] = inGroup
			end

			return inGroupCache[userId]
		end

		return false
	end
end

local function ConstructIsInGroups()
	if SpecialChatColors.Groups then
		for _, group in pairs(SpecialChatColors.Groups) do
			group.IsInGroup = MakeIsInGroup(group.GroupId, group.Rank)
		end
	end
end
ConstructIsInGroups()

local Players = game:GetService("Players")

function GetSpecialChatColor(speakerName)
	if SpecialChatColors.Players then
		local playerFromSpeaker = Players:FindFirstChild(speakerName)
		if playerFromSpeaker then
			for _, player in pairs(SpecialChatColors.Players) do
				if playerFromSpeaker.UserId == player.UserId then
					return player.ChatColor
				end
			end
		end
	end
	if SpecialChatColors.Groups then
		for _, group in pairs(SpecialChatColors.Groups) do
			if group.IsInGroup(Players:FindFirstChild(speakerName)) then
				return group.ChatColor
			end
		end
	end
end

local function Run(ChatService)
	local NAME_COLORS =
	{
		Color3.new(253/255, 41/255, 67/255), -- BrickColor.new("Bright red").Color,
		Color3.new(1/255, 162/255, 255/255), -- BrickColor.new("Bright blue").Color,
		Color3.new(2/255, 184/255, 87/255), -- BrickColor.new("Earth green").Color,
		BrickColor.new("Bright violet").Color,
		BrickColor.new("Bright orange").Color,
		BrickColor.new("Bright yellow").Color,
		BrickColor.new("Light reddish violet").Color,
		BrickColor.new("Brick yellow").Color,
	}

	local function GetNameValue(pName)
		local value = 0
		for index = 1, #pName do
			local cValue = string.byte(string.sub(pName, index, index))
			local reverseIndex = #pName - index + 1
			if #pName%2 == 1 then
				reverseIndex = reverseIndex - 1
			end
			if reverseIndex%4 >= 2 then
				cValue = -cValue
			end
			value = value + cValue
		end
		return value
	end

	local color_offset = 0
	local function ComputeNameColor(pName)
		return NAME_COLORS[((GetNameValue(pName) + color_offset) % #NAME_COLORS) + 1]
	end

	local function GetNameColor(speaker)
		local player = speaker:GetPlayer()
		if player then
			if player.Team ~= nil then
				return player.TeamColor.Color
			end
		end
		return ComputeNameColor(speaker.Name)
	end

	ChatService.SpeakerAdded:connect(function(speakerName)
		local speaker = ChatService:GetSpeaker(speakerName)
		local player = speaker:GetPlayer()

		if (not speaker:GetExtraData("NameColor")) then
			speaker:SetExtraData("NameColor", GetNameColor(speaker))
		end
		if (player) then
			player.Changed:connect(function(property)
				if property == "TeamColor" or property == "Neutral" or property == "Team" then
					speaker:SetExtraData("NameColor", GetNameColor(speaker))
				end
			end)
		end
		if (not speaker:GetExtraData("ChatColor")) then
			local specialChatColor = GetSpecialChatColor(speakerName)
			if specialChatColor then
				speaker:SetExtraData("ChatColor", specialChatColor)
			end
		end
		if (not speaker:GetExtraData("Tags")) then
			speaker:SetExtraData("Tags", {})
		end


	end)
end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD1265F4D1D1244F1BA69D67CFC29FED7">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ChatMessageValidator</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: ChatMessageValidator.lua
--	// Written by: TheGamer101
--	// Description: Validate things such as no disallowed whitespace and chat message length on the server.

local Chat = game:GetService("Chat")
local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))

local DISALLOWED_WHITESPACE = {"\n", "\r", "\t", "\v", "\f"}

if ChatSettings.DisallowedWhiteSpace then
	DISALLOWED_WHITESPACE = ChatSettings.DisallowedWhiteSpace
end

local function Run(ChatService)
	local function ValidateChatFunction(speakerName, message, channel)
		local speakerObj = ChatService:GetSpeaker(speakerName)
		if not speakerObj then return false end

		if message:len() > ChatSettings.MaximumMessageLength + 1 then
			speakerObj:SendSystemMessage("Your message exceeds the maximum message length.", channel)
			return true
		end

		for i = 1, #DISALLOWED_WHITESPACE do
			if string.find(message, DISALLOWED_WHITESPACE[i]) then
				speakerObj:SendSystemMessage("Your message contains whitespace that is not allowed.", channel)
				return true
			end
		end
		return false
	end

	ChatService:RegisterProcessCommandsFunction("message_validation", ValidateChatFunction)
end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3596D73660C0477D9D8AEC5C39E997CF">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ChatFloodDetector</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: ChatFloodDetector.lua
--	// Written by: Xsitsu
--	// Description: Module that limits the number of messages a speaker can send in a given period of time.

local doFloodCheckByChannel = true
local informSpeakersOfWaitTimes = true
local chatBotsBypassFloodCheck = true
local numberMessagesAllowed = 7
local decayTimePeriod = 15

local floodCheckTable = {}
local whitelistedSpeakers = {}

local function EnterTimeIntoLog(tbl)
	table.insert(tbl, tick() + decayTimePeriod)
end

local function Run(ChatService)
	local function FloodDetectionProcessCommandsFunction(speakerName, message, channel)
		if (whitelistedSpeakers[speakerName]) then return false end

		local speakerObj = ChatService:GetSpeaker(speakerName)
		if (not speakerObj) then return false end
		if (chatBotsBypassFloodCheck and not speakerObj:GetPlayer()) then return false end

		if (not floodCheckTable[speakerName]) then
			floodCheckTable[speakerName] = {}
		end

		local t = nil

		if (doFloodCheckByChannel) then
			if (not floodCheckTable[speakerName][channel]) then
				floodCheckTable[speakerName][channel] = {}
			end

			t = floodCheckTable[speakerName][channel]
		else
			t = floodCheckTable[speakerName]
		end

		local now = tick()
		while (#t > 0 and t[1] < now) do
			table.remove(t, 1)
		end

		if (#t < numberMessagesAllowed) then
			EnterTimeIntoLog(t)
			return false
		else

			local timeDiff = math.ceil(t[1] - now)
			local msg = ""
			if (informSpeakersOfWaitTimes) then
				msg = string.format("You must wait %d %s before sending another message!", timeDiff, (timeDiff > 1) and "seconds" or "second")
			else
				msg = "You must wait before sending another message!"
			end
			speakerObj:SendSystemMessage(msg, channel)

			return true
		end
	end

	ChatService:RegisterProcessCommandsFunction("flood_detection", FloodDetectionProcessCommandsFunction)

	ChatService.SpeakerRemoved:connect(function(speakerName)
		floodCheckTable[speakerName] = nil
	end)
end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX76936113C6EB4DF98DD39EEC62CB01CB">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ChatCommandsTeller</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: ChatCommandsTeller.lua
--	// Written by: Xsitsu
--	// Description: Module that provides information on default chat commands to players.

local function Run(ChatService)

	local function ProcessCommandsFunction(fromSpeaker, message, channel)
		if (message == "/?" or message == "/help") then
			local speaker = ChatService:GetSpeaker(fromSpeaker)
			speaker:SendSystemMessage("These are the basic chat commands.", channel)
			speaker:SendSystemMessage("/me <text> : roleplaying command for doing actions.", channel)
			speaker:SendSystemMessage("/c <channel> : switch channel menu tabs.", channel)
			speaker:SendSystemMessage("/join <channel> or /j <channel> : join channel.", channel)
			speaker:SendSystemMessage("/leave <channel> or /l <channel> : leave channel. (leaves current if none specified)", channel)
			speaker:SendSystemMessage("/whisper <speaker> or /w <speaker> : open private message channel with speaker.", channel)
			speaker:SendSystemMessage("/mute <speaker> : mute a speaker.", channel)
			speaker:SendSystemMessage("/unmute <speaker> : unmute a speaker.", channel)

			local player = speaker:GetPlayer()
			if player and player.Team then
				speaker:SendSystemMessage("/team <message> or /t <message> : send a team chat to players on your team.", channel)
			end

			return true
		end

		return false
	end

	ChatService:RegisterProcessCommandsFunction("chat_commands_inquiry", ProcessCommandsFunction)

	local allChannel = ChatService:GetChannel("All")
	if (allChannel) then
		allChannel.WelcomeMessage = "Chat '/?' or '/help' for a list of chat commands."
	end
end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF026EC5D85FA46418A62962DD42198D9">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PrivateMessaging</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: PrivateMessaging.lua
--	// Written by: Xsitsu
--	// Description: Module that handles all private messaging.

local Chat = game:GetService("Chat")
local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))

local errorExtraData = {ChatColor = Color3.fromRGB(245, 50, 50)}

local function Run(ChatService)

	local function DoWhisperCommand(fromSpeaker, message, channel)
		local otherSpeakerName = message
		local sendMessage = nil

		if (string.sub(message, 1, 1) == "\"") then
			local pos = string.find(message, "\"", 2)
			if (pos) then
				otherSpeakerName = string.sub(message, 2, pos - 1)
				sendMessage = string.sub(message, pos + 1)
			end
		else
			local first = string.match(message, "^[^%s]+")
			if (first) then
				otherSpeakerName = first
				sendMessage = string.sub(message, string.len(otherSpeakerName) + 1)
			end
		end

		local speaker = ChatService:GetSpeaker(fromSpeaker)
		local channelObj = ChatService:GetChannel("To " .. otherSpeakerName)
		if (channelObj and ChatService:GetSpeaker(otherSpeakerName)) then

			if (channelObj.Name == "To " .. speaker.Name) then
				speaker:SendSystemMessage("You cannot whisper to yourself.", channel, errorExtraData)
			else
				if (not speaker:IsInChannel(channelObj.Name)) then
					speaker:JoinChannel(channelObj.Name)
				end

				if (sendMessage and (string.len(sendMessage) > 0) ) then
					speaker:SayMessage(sendMessage, channelObj.Name)
				end

				speaker:SetMainChannel(channelObj.Name)

			end

		else
			speaker:SendSystemMessage(string.format("Speaker '%s' does not exist.", tostring(otherSpeakerName)), channel, errorExtraData)

		end
	end

	local function WhisperCommandsFunction(fromSpeaker, message, channel)
		local processedCommand = false

		if (string.sub(message, 1, 3):lower() == "/w ") then
			DoWhisperCommand(fromSpeaker, string.sub(message, 4), channel)
			processedCommand = true

		elseif (string.sub(message, 1, 9):lower() == "/whisper ") then
			DoWhisperCommand(fromSpeaker, string.sub(message, 10), channel)
			processedCommand = true

		end

		return processedCommand
	end

	local function PrivateMessageReplicationFunction(fromSpeaker, message, channelName)
		local sendingSpeaker = ChatService:GetSpeaker(fromSpeaker)
		local extraData = sendingSpeaker.ExtraData
		sendingSpeaker:SendMessage(message, channelName, fromSpeaker, extraData)

		local toSpeaker = ChatService:GetSpeaker(string.sub(channelName, 4))
		if (toSpeaker) then
			if (not toSpeaker:IsInChannel("To " .. fromSpeaker)) then
				toSpeaker:JoinChannel("To " .. fromSpeaker)
			end
			toSpeaker:SendMessage(message, "To " .. fromSpeaker, fromSpeaker, extraData)
		end

		return true
	end

	local function PrivateMessageAddTypeFunction(speakerName, messageObj, channelName)
		if ChatConstants.MessageTypeWhisper then
			messageObj.MessageType = ChatConstants.MessageTypeWhisper
		end
	end

	ChatService:RegisterProcessCommandsFunction("whisper_commands", WhisperCommandsFunction)

	ChatService.SpeakerAdded:connect(function(speakerName)
		if (ChatService:GetChannel("To " .. speakerName)) then
			ChatService:RemoveChannel("To " .. speakerName)
		end

		local channel = ChatService:AddChannel("To " .. speakerName)
		channel.Joinable = false
		channel.Leavable = true
		channel.AutoJoin = false
		channel.Private = true

		channel.WelcomeMessage = "You are now privately chatting with " .. speakerName .. "."

		channel:RegisterProcessCommandsFunction("replication_function", PrivateMessageReplicationFunction)
		channel:RegisterFilterMessageFunction("message_type_function", PrivateMessageAddTypeFunction)
	end)

	ChatService.SpeakerRemoved:connect(function(speakerName)
		if (ChatService:GetChannel("To " .. speakerName)) then
			ChatService:RemoveChannel("To " .. speakerName)
		end
	end)
end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA1B6D2FD14614F43A2E19D0530B672EE">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">MuteSpeaker</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: MuteSpeaker.lua
--	// Written by: TheGamer101
--	// Description: Module that handles all the mute and unmute commands.

local errorExtraData = {ChatColor = Color3.fromRGB(245, 50, 50)}

local function Run(ChatService)

	local function GetSpeakerNameFromMessage(message)
		local speakerName = message
		if string.sub(message, 1, 1) == "\"" then
			local pos = string.find(message, "\"", 2)
			if pos then
				speakerName = string.sub(message, 2, pos - 1)
			end
		else
			local first = string.match(message, "^[^%s]+")
			if first then
				speakerName = first
			end
		end
		return speakerName
	end

	local function DoMuteCommand(speakerName, message, channel)
		local muteSpeakerName = GetSpeakerNameFromMessage(message)
		local speaker = ChatService:GetSpeaker(speakerName)
		if speaker then
			if muteSpeakerName == speakerName then
				speaker:SendSystemMessage("You cannot mute yourself.", channel, errorExtraData)
				return
			end

			local muteSpeaker = ChatService:GetSpeaker(muteSpeakerName)
			if muteSpeaker then
				speaker:AddMutedSpeaker(muteSpeakerName)
				speaker:SendSystemMessage(string.format("Speaker '%s' has been muted.", tostring(muteSpeakerName)), channel)
			else
				speaker:SendSystemMessage(string.format("Speaker '%s' does not exist.", tostring(muteSpeakerName)), channel, errorExtraData)
			end
		end
	end

	local function DoUnmuteCommand(speakerName, message, channel)
		local unmuteSpeakerName = GetSpeakerNameFromMessage(message)
		local speaker = ChatService:GetSpeaker(speakerName)
		if speaker then
			if unmuteSpeakerName == speakerName then
				speaker:SendSystemMessage("You cannot mute yourself.", channel, errorExtraData)
				return
			end

			local unmuteSpeaker = ChatService:GetSpeaker(unmuteSpeakerName)
			if unmuteSpeaker then
				speaker:RemoveMutedSpeaker(unmuteSpeakerName)
				speaker:SendSystemMessage(string.format("Speaker '%s' has been unmuted.", tostring(unmuteSpeakerName)), channel)
			else
				speaker:SendSystemMessage(string.format("Speaker '%s' does not exist.", tostring(unmuteSpeakerName)), channel, errorExtraData)
			end
		end
	end

	local function MuteCommandsFunction(fromSpeaker, message, channel)
		local processedCommand = false

		if string.sub(message, 1, 6):lower() == "/mute " then
			DoMuteCommand(fromSpeaker, string.sub(message, 7), channel)
			processedCommand = true
		elseif string.sub(message, 1, 8):lower() == "/unmute " then
			DoUnmuteCommand(fromSpeaker, string.sub(message, 9), channel)
			processedCommand = true
		end
		return processedCommand
	end

	ChatService:RegisterProcessCommandsFunction("mute_commands", MuteCommandsFunction)
end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3716962DDC994EDE8B35C33949EF2079">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TeamChat</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: TeamChat.lua
--	// Written by: Xsitsu
--	// Description: Module that handles all team chat.

local errorExtraData = {ChatColor = Color3.fromRGB(245, 50, 50)}

local function Run(ChatService)

	local Players = game:GetService("Players")

	local channel = ChatService:AddChannel("Team")
	channel.WelcomeMessage = "This is a private channel between you and your team members."
	channel.Joinable = false
	channel.Leavable = false
	channel.AutoJoin = false
	channel.Private = true

	local function TeamChatReplicationFunction(fromSpeaker, message, channelName)
		local speakerObj = ChatService:GetSpeaker(fromSpeaker)
		local channelObj = ChatService:GetChannel(channelName)
		if (speakerObj and channelObj) then
			local player = speakerObj:GetPlayer()
			if (player) then

				for i, speakerName in pairs(channelObj:GetSpeakerList()) do
					local otherSpeaker = ChatService:GetSpeaker(speakerName)
					if (otherSpeaker) then
						local otherPlayer = otherSpeaker:GetPlayer()
						if (otherPlayer) then

							if (player.Team == otherPlayer.Team) then
								local extraData = {
									NameColor = player.TeamColor.Color,
									ChatColor = player.TeamColor.Color,
									ChannelColor = player.TeamColor.Color
								}
								otherSpeaker:SendMessage(message, channelName, fromSpeaker, extraData)
							else
								--// Could use this line to obfuscate message for cool effects
								--otherSpeaker:SendMessage(message, channelName, fromSpeaker)
							end

						end
					end
				end

			end
		end

		return true
	end

	channel:RegisterProcessCommandsFunction("replication_function", TeamChatReplicationFunction)

	local function DoTeamCommand(fromSpeaker, message, channel)
		if message == nil then
			message = ""
		end

		local speaker = ChatService:GetSpeaker(fromSpeaker)
		if speaker then
			local player = speaker:GetPlayer()

			if player then
				if player.Team == nil then
					speaker:SendSystemMessage("You cannot team chat if you are not on a team!", channel, errorExtraData)
					return
				end

				local channelObj = ChatService:GetChannel("Team")
				if channelObj then
					if not speaker:IsInChannel(channelObj.Name) then
						speaker:JoinChannel(channelObj.Name)
					end
					if message and string.len(message) > 0 then
						speaker:SayMessage(message, channelObj.Name)
					end
					speaker:SetMainChannel(channelObj.Name)
				end
			end
		end
	end

	local function TeamCommandsFunction(fromSpeaker, message, channel)
		local processedCommand = false

		if message == nil then
			error("Message is nil")
		end

		if channel == "Team" then
			return false
		end

		if string.sub(message, 1, 6):lower() == "/team " or message:lower() == "/team" then
			DoTeamCommand(fromSpeaker, string.sub(message, 7), channel)
			processedCommand = true
		elseif string.sub(message, 1, 3):lower() == "/t " or message:lower() == "/t" then
			DoTeamCommand(fromSpeaker, string.sub(message, 4), channel)
			processedCommand = true
		elseif string.sub(message, 1, 2):lower() == "% " or message:lower() == "%" then
			DoTeamCommand(fromSpeaker, string.sub(message, 3), channel)
			processedCommand = true
		end

		return processedCommand
	end

	ChatService:RegisterProcessCommandsFunction("team_commands", TeamCommandsFunction)

	local function PutSpeakerInCorrectTeamChatState(speakerObj, playerObj)
		if (playerObj.Neutral or playerObj.Team == nil) and speakerObj:IsInChannel(channel.Name) then
			speakerObj:LeaveChannel(channel.Name)

		elseif not playerObj.Neutral and playerObj.Team and not speakerObj:IsInChannel(channel.Name) then
			speakerObj:JoinChannel(channel.Name)

		end
	end

	ChatService.SpeakerAdded:connect(function(speakerName)
		local speakerObj = ChatService:GetSpeaker(speakerName)
		if (speakerObj) then
			local player = speakerObj:GetPlayer()
			if (player) then
				player.Changed:connect(function(property)
					if (property == "Neutral") then
						PutSpeakerInCorrectTeamChatState(speakerObj, player)

					elseif (property == "Team") then
						PutSpeakerInCorrectTeamChatState(speakerObj, player)
						if (speakerObj:IsInChannel(channel.Name)) then
							speakerObj:SendSystemMessage(string.format("You are now on the '%s' team.", player.Team.Name), channel.Name)
						end

					end
				end)

				PutSpeakerInCorrectTeamChatState(speakerObj, player)
			end
		end
	end)

end

return Run
]]></ProtectedString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX88E59F460AB9486391B7E6304181CDE3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatService</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatService.lua
--	// Written by: Xsitsu
--	// Description: Manages creating and destroying ChatChannels and Speakers.

local module = {}

local modulesFolder = script.Parent
local RunService = game:GetService("RunService")
local Chat = game:GetService("Chat")

--////////////////////////////// Include
--//////////////////////////////////////
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local ChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
local Speaker = require(modulesFolder:WaitForChild("Speaker"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function methods:AddChannel(channelName)
	if (self.ChatChannels[channelName:lower()]) then
		error(string.format("Channel %q alrady exists.", channelName))
	end

	local channel = ChatChannel.new(self, channelName)
	self.ChatChannels[channelName:lower()] = channel

	channel:RegisterProcessCommandsFunction("default_commands", function(fromSpeaker, message)
		if (message:lower() == "/leave") then
			local channel = self:GetChannel(channelName)
			local speaker = self:GetSpeaker(fromSpeaker)
			if (channel and speaker) then
				if (channel.Leavable) then
					speaker:LeaveChannel(channelName)
				else
					speaker:SendSystemMessage("You cannot leave this channel.", channelName)
				end
			end

			return true
		end

		return false
	end)

	local success, err = pcall(function() self.eChannelAdded:Fire(channelName) end)
	if not success and err then
		print("Error addding channel: " ..err)
	end

	return channel
end

function methods:RemoveChannel(channelName)
	if (self.ChatChannels[channelName:lower()]) then
		local n = self.ChatChannels[channelName:lower()].Name

		self.ChatChannels[channelName:lower()]:InternalDestroy()
		self.ChatChannels[channelName:lower()] = nil

		local success, err = pcall(function() self.eChannelRemoved:Fire(n) end)
		if not success and err then
			print("Error removing channel: " ..err)
		end
	else
		warn(string.format("Channel %q does not exist.", channelName))
	end
end

function methods:GetChannel(channelName)
	return self.ChatChannels[channelName:lower()]
end


function methods:AddSpeaker(speakerName)
	if (self.Speakers[speakerName:lower()]) then
		error("Speaker \"" .. speakerName .. "\" already exists!")
	end

	local speaker = Speaker.new(self, speakerName)
	self.Speakers[speakerName:lower()] = speaker

	local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
	if not success and err then
		print("Error adding speaker: " ..err)
	end

	return speaker
end

function methods:RemoveSpeaker(speakerName)
	if (self.Speakers[speakerName:lower()]) then
		local n = self.Speakers[speakerName:lower()].Name

		self.Speakers[speakerName:lower()]:InternalDestroy()
		self.Speakers[speakerName:lower()] = nil

		local success, err = pcall(function() self.eSpeakerRemoved:Fire(n) end)
		if not success and err then
			print("Error removing speaker: " ..err)
		end

	else
		warn("Speaker \"" .. speakerName .. "\" does not exist!")
	end
end

function methods:GetSpeaker(speakerName)
	return self.Speakers[speakerName:lower()]
end

function methods:GetChannelList()
	local list = {}
	for i, channel in pairs(self.ChatChannels) do
		if (not channel.Private) then
			table.insert(list, channel.Name)
		end
	end
	return list
end

function methods:GetAutoJoinChannelList()
	local list = {}
	for i, channel in pairs(self.ChatChannels) do
		if channel.AutoJoin then
			table.insert(list, channel)
		end
	end
	return list
end

function methods:GetSpeakerList()
	local list = {}
	for i, speaker in pairs(self.Speakers) do
		table.insert(list, speaker.Name)
	end
	return list
end

function methods:SendGlobalSystemMessage(message)
	for i, speaker in pairs(self.Speakers) do
		speaker:SendSystemMessage(message, nil)
	end
end

function methods:RegisterFilterMessageFunction(funcId, func)
	if self.FilterMessageFunctions[funcId] then
		error(funcId .. " is already in use!")
	end

	self.FilterMessageFunctions[funcId] = func
end

function methods:UnregisterFilterMessageFunction(funcId)
	self.FilterMessageFunctions[funcId] = nil
end

function methods:RegisterProcessCommandsFunction(funcId, func)
	if self.ProcessCommandsFunctions[funcId] then
		error(funcId .. " is already in use!")
	end

	self.ProcessCommandsFunctions[funcId] = func
end

function methods:UnregisterProcessCommandsFunction(funcId)
	self.ProcessCommandsFunctions[funcId] = nil
end

--///////////////// Internal-Use Methods
--//////////////////////////////////////
--DO NOT REMOVE THIS. Chat must be filtered or your game will face
--moderation.
function methods:InternalApplyRobloxFilter(speakerName, message, toSpeakerName)
	if (RunService:IsServer() and not RunService:IsStudio()) then
		local fromSpeaker = self:GetSpeaker(speakerName)
		local toSpeaker = self:GetSpeaker(toSpeakerName)
		if (fromSpeaker and toSpeaker) then
			local fromPlayerObj = fromSpeaker:GetPlayer()
			local toPlayerObj = toSpeaker:GetPlayer()
			if (fromPlayerObj and toPlayerObj) then
				message = Chat:FilterStringAsync(message, fromPlayerObj, toPlayerObj)
			end
		end
	else
		--// Simulate filtering latency.
		wait(0.2)
	end

	return message
end

function methods:InternalDoMessageFilter(speakerName, messageObj, channel)
	for funcId, func in pairs(self.FilterMessageFunctions) do
		local s, m = pcall(function()
			func(speakerName, messageObj, channel)
		end)

		if (not s) then
			warn(string.format("DoMessageFilter Function '%s' failed for reason: %s", funcId, m))
		end
	end
end

function methods:InternalDoProcessCommands(speakerName, message, channel)
	local processed = false

	processed = self.ProcessCommandsFunctions["default_commands"](speakerName, message, channel)
	if (processed) then return processed end

	for funcId, func in pairs(self.ProcessCommandsFunctions) do
		local s, m = pcall(function()
			local ret = func(speakerName, message, channel)
			assert(type(ret) == "boolean")
			processed = ret
		end)

		if (not s) then
			warn(string.format("DoProcessCommands Function '%s' failed for reason: %s", funcId, m))
		end

		if (processed) then break end
	end

	return processed
end

function methods:InternalGetUniqueMessageId()
	local id = self.MessageIdCounter
	self.MessageIdCounter = id + 1
	return id
end

function methods:InternalAddSpeakerWithPlayerObject(speakerName, playerObj)
	if (self.Speakers[speakerName:lower()]) then
		error("Speaker \"" .. speakerName .. "\" already exists!")
	end

	local speaker = Speaker.new(self, speakerName)
	speaker:InternalAssignPlayerObject(playerObj)
	self.Speakers[speakerName:lower()] = speaker

	local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
	if not success and err then
		print("Error adding speaker: " ..err)
	end

	return speaker
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ChatService", methods)

function module.new()
	local obj = {}

	obj.MessageIdCounter = 0

	obj.ChatChannels = {}
	obj.Speakers = {}

	obj.FilterMessageFunctions = {}
	obj.ProcessCommandsFunctions = {}

	obj.eChannelAdded = Instance.new("BindableEvent")
	obj.eChannelRemoved = Instance.new("BindableEvent")
	obj.eSpeakerAdded = Instance.new("BindableEvent")
	obj.eSpeakerRemoved = Instance.new("BindableEvent")

	obj.ChannelAdded = obj.eChannelAdded.Event
	obj.ChannelRemoved = obj.eChannelRemoved.Event
	obj.SpeakerAdded = obj.eSpeakerAdded.Event
	obj.SpeakerRemoved = obj.eSpeakerRemoved.Event

	ClassMaker.MakeClass("ChatService", obj)

	return obj
end

return module.new()
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0E6EECD24B254F9AAE10B40D2FD91319">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatChannel</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatChannel.lua
--	// Written by: Xsitsu
--	// Description: A representation of one channel that speakers can chat in.

local module = {}

local modulesFolder = script.Parent
local HttpService = game:GetService("HttpService")
local Chat = game:GetService("Chat")
local replicatedModules = Chat:WaitForChild("ClientChatModules")

--////////////////////////////// Include
--//////////////////////////////////////
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local ChatConstants = require(replicatedModules:WaitForChild("ChatConstants"))

--////////////////////////////// Methods
--//////////////////////////////////////

local methods = {}

function methods:SendSystemMessage(message, extraData)
	local messageObj = self:InternalCreateMessageObject(message, nil, true, extraData)

	self:InternalAddMessageToHistoryLog(messageObj)

	for i, speaker in pairs(self.Speakers) do
		speaker:InternalSendSystemMessage(messageObj, self.Name)
	end

	return messageObj
end

function methods:SendSystemMessageToSpeaker(message, speakerName, extraData)
	local speaker = self.Speakers[speakerName]
	if (speaker) then
		local messageObj = self:InternalCreateMessageObject(message, nil, true, extraData)
		speaker:InternalSendSystemMessage(messageObj, self.Name)
	else
		warn(string.format("Speaker '%s' is not in channel '%s' and cannot be sent a system message", speakerName, self.Name))
	end
end

function methods:SendMessageObjToFilters(message, messageObj, fromSpeaker)
	local oldMessage = messageObj.Message
	messageObj.Message = message
	self:InternalDoMessageFilter(fromSpeaker.Name, messageObj, self.Name)
	self.ChatService:InternalDoMessageFilter(fromSpeaker.Name, messageObj, self.Name)
	local newMessage = messageObj.Message
	messageObj.Message = oldMessage
	return newMessage
end

function methods:SendMessageToSpeaker(message, speakerName, fromSpeaker, extraData)
	local speaker = self.Speakers[speakerName]
	if (speaker) then
		local isMuted = speaker:IsSpeakerMuted(fromSpeaker)
		if isMuted then
			return
		end

		local isFiltered = speakerName == fromSpeaker
		local messageObj = self:InternalCreateMessageObject(message, fromSpeaker, isFiltered, extraData)
		message = self:SendMessageObjToFilters(message, messageObj, fromSpeaker)
		speaker:InternalSendMessage(messageObj, self.Name)

		if not isFiltered then
			messageObj.Message = self.ChatService:InternalApplyRobloxFilter(messageObj.FromSpeaker, message, speakerName)
			messageObj.IsFiltered = true
			speaker:InternalSendFilteredMessage(messageObj, self.Name)
		end
	else
		warn(string.format("Speaker '%s' is not in channel '%s' and cannot be sent a message", speakerName, self.Name))
	end
end

function methods:KickSpeaker(speakerName, reason)
	local speaker = self.ChatService:GetSpeaker(speakerName)
	if (not speaker) then
		error("Speaker \"" .. speakerName .. "\" does not exist!")
	end

	local messageToSpeaker = ""
	local messageToChannel = ""

	if (reason) then
		messageToSpeaker = string.format("You were kicked from '%s' for the following reason(s): %s", self.Name, reason)
		messageToChannel = string.format("%s was kicked for the following reason(s): %s", speakerName, reason)
	else
		messageToSpeaker = string.format("You were kicked from '%s'", self.Name)
		messageToChannel = string.format("%s was kicked", speakerName)
	end

	self:SendSystemMessageToSpeaker(messageToSpeaker, speakerName)
	speaker:LeaveChannel(self.Name)
	self:SendSystemMessage(messageToChannel)
end

function methods:MuteSpeaker(speakerName, reason, length)
	local speaker = self.ChatService:GetSpeaker(speakerName)
	if (not speaker) then
		error("Speaker \"" .. speakerName .. "\" does not exist!")
	end

	self.Mutes[speakerName:lower()] = (length == 0 or length == nil) and 0 or (os.time() + length)

	if (reason) then
		self:SendSystemMessage(string.format("%s was muted for the following reason(s): %s", speakerName, reason))
	end

	local success, err = pcall(function() self.eSpeakerMuted:Fire(speakerName, reason, length) end)
	if not success and err then
		print("Error mutting speaker: " ..err)
	end

	local spkr = self.ChatService:GetSpeaker(speakerName)
	if (spkr) then
		local success, err = pcall(function() spkr.eMuted:Fire(self.Name, reason, length) end)
		if not success and err then
			print("Error mutting speaker: " ..err)
		end
	end

end

function methods:UnmuteSpeaker(speakerName)
	local speaker = self.ChatService:GetSpeaker(speakerName)
	if (not speaker) then
		error("Speaker \"" .. speakerName .. "\" does not exist!")
	end

	self.Mutes[speakerName:lower()] = nil

	local success, err = pcall(function() self.eSpeakerUnmuted:Fire(speakerName) end)
	if not success and err then
		print("Error unmuting speaker: " ..err)
	end

	local spkr = self.ChatService:GetSpeaker(speakerName)
	if (spkr) then
		local success, err = pcall(function() spkr.eUnmuted:Fire(self.Name) end)
		if not success and err then
			print("Error unmuting speaker: " ..err)
		end
	end
end

function methods:IsSpeakerMuted(speakerName)
	return (self.Mutes[speakerName:lower()] ~= nil)
end

function methods:GetSpeakerList()
	local list = {}
	for i, speaker in pairs(self.Speakers) do
		table.insert(list, speaker.Name)
	end
	return list
end

function methods:RegisterFilterMessageFunction(funcId, func)
	if self.FilterMessageFunctions[funcId] then
		error(funcId .. " is already in use!")
	end

	self.FilterMessageFunctions[funcId] = func
end

function methods:UnregisterFilterMessageFunction(funcId)
	self.FilterMessageFunctions[funcId] = nil
end

function methods:RegisterProcessCommandsFunction(funcId, func)
	if (self.ProcessCommandsFunctions[funcId]) then
		error(funcId .. " is already in use!")
	end

	self.ProcessCommandsFunctions[funcId] = func
end

function methods:UnregisterProcessCommandsFunction(funcId)
	self.ProcessCommandsFunctions[funcId] = nil
end

local function DeepCopy(table)
	local copy =	{}
	for i, v in pairs(table) do
		if (type(v) == table) then
			copy[i] = DeepCopy(v)
		else
			copy[i] = v
		end
	end
	return copy
end

function methods:GetHistoryLog()
	return DeepCopy(self.ChatHistory)
end

--///////////////// Internal-Use Methods
--//////////////////////////////////////
function methods:InternalDestroy()
	for i, speaker in pairs(self.Speakers) do
		speaker:LeaveChannel(self.Name)
	end

	self.eDestroyed:Fire()
end

function methods:InternalDoMessageFilter(speakerName, messageObj, channel)
	for funcId, func in pairs(self.FilterMessageFunctions) do
		local s, m = pcall(function()
			func(speakerName, messageObj, channel)
		end)

		if (not s) then
			warn(string.format("DoMessageFilter Function '%s' failed for reason: %s", funcId, m))
		end
	end
end

function methods:InternalDoProcessCommands(speakerName, message, channel)
	local processed = false

	processed = self.ProcessCommandsFunctions["default_commands"](speakerName, message, channel)
	if (processed) then return processed end

	for funcId, func in pairs(self.ProcessCommandsFunctions) do
		local s, m = pcall(function()
			local ret = func(speakerName, message, channel)
			assert(type(ret) == "boolean")
			processed = ret
		end)

		if (not s) then
			warn(string.format("DoProcessCommands Function '%s' failed for reason: %s", funcId, m))
		end

		if (processed) then break end
	end

	return processed
end

function methods:InternalPostMessage(fromSpeaker, message, extraData)
	if (self:InternalDoProcessCommands(fromSpeaker.Name, message, self.Name)) then return false end

	if (self.Mutes[fromSpeaker.Name:lower()] ~= nil) then
		local t = self.Mutes[fromSpeaker.Name:lower()]
		if (t > 0 and os.time() > t) then
			self:UnmuteSpeaker(fromSpeaker.Name)
		else
			self:SendSystemMessageToSpeaker("You are muted and cannot talk in this channel", fromSpeaker.Name)
			return false
		end
	end

	local messageObj = self:InternalCreateMessageObject(message, fromSpeaker.Name, false, extraData)
	message = self:SendMessageObjToFilters(message, messageObj, fromSpeaker)

	local sentToList = {}
	for i, speaker in pairs(self.Speakers) do
		local isMuted = speaker:IsSpeakerMuted(fromSpeaker.Name)
		if not isMuted then
			table.insert(sentToList, speaker.Name)
			if speaker.Name == fromSpeaker.Name then
				-- Send unfiltered message to speaker who sent the message.
				local cMessageObj = DeepCopy(messageObj)
				cMessageObj.Message = message
				cMessageObj.IsFiltered = true
				speaker:InternalSendMessage(cMessageObj, self.Name)
			else
				speaker:InternalSendMessage(messageObj, self.Name)
			end
		end
	end

	local success, err = pcall(function() self.eMessagePosted:Fire(messageObj) end)
	if not success and err then
		print("Error posting message: " ..err)
	end

	local filteredMessages = {}
	for i, speakerName in pairs(sentToList) do
		filteredMessages[speakerName] = self.ChatService:InternalApplyRobloxFilter(messageObj.FromSpeaker, message, speakerName)
	end

	for i, speakerName in pairs(sentToList) do
		local speaker = self.Speakers[speakerName]
		if (speaker) then
			local cMessageObj = DeepCopy(messageObj)
			cMessageObj.Message = filteredMessages[speakerName]
			cMessageObj.IsFiltered = true
			speaker:InternalSendFilteredMessage(cMessageObj, self.Name)
		end
	end

	messageObj.Message = self.ChatService:InternalApplyRobloxFilter(messageObj.FromSpeaker, message, messageObj.FromSpeaker)
	messageObj.IsFiltered = true
	self:InternalAddMessageToHistoryLog(messageObj)

	return messageObj
end

function methods:InternalAddSpeaker(speaker)
	if (self.Speakers[speaker.Name]) then
		warn("Speaker \"" .. speaker.name .. "\" is already in the channel!")
		return
	end

	self.Speakers[speaker.Name] = speaker
	local success, err = pcall(function() self.eSpeakerJoined:Fire(speaker.Name) end)
	if not success and err then
		print("Error removing channel: " ..err)
	end
end

function methods:InternalRemoveSpeaker(speaker)
	if (not self.Speakers[speaker.Name]) then
		warn("Speaker \"" .. speaker.name .. "\" is not in the channel!")
		return
	end

	self.Speakers[speaker.Name] = nil
	local success, err = pcall(function() self.eSpeakerLeft:Fire(speaker.Name) end)
	if not success and err then
		print("Error removing speaker: " ..err)
	end
end

function methods:InternalRemoveExcessMessagesFromLog()
	local remove = table.remove
	while (#self.ChatHistory > self.MaxHistory) do
		remove(self.ChatHistory, 1)
	end
end

local function ChatHistorySortFunction(message1, message2)
	return (message1.Time < message2.Time)
end

function methods:InternalAddMessageToHistoryLog(messageObj)
	table.insert(self.ChatHistory, messageObj)
	--table.sort(self.ChatHistory, ChatHistorySortFunction)

	self:InternalRemoveExcessMessagesFromLog()
end

function methods:GetMessageType(message, fromSpeaker)
	if fromSpeaker == nil then
		return ChatConstants.MessageTypeSystem
	end
	return ChatConstants.MessageTypeDefault
end

function methods:InternalCreateMessageObject(message, fromSpeaker, isFiltered, extraData)
	local messageType = self:GetMessageType(message, fromSpeaker)
	local messageObj =
	{
		ID = self.ChatService:InternalGetUniqueMessageId(),
		FromSpeaker = fromSpeaker,
		OriginalChannel = self.Name,
		MessageLength = string.len(message),
		MessageType = messageType,
		IsFiltered = isFiltered,
		Message = isFiltered and message or nil,
		Time = os.time(),
		ExtraData = {},
	}

	if (fromSpeaker) then
		local speaker = self.Speakers[fromSpeaker]
		if (speaker) then
			for k, v in pairs(speaker.ExtraData) do
				messageObj.ExtraData[k] = v
			end
		end
	end

	if (extraData) then
		for k, v in pairs(extraData) do
			messageObj.ExtraData[k] = v
		end
	end

	return messageObj
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ChatChannel", methods)

function module.new(vChatService, name, welcomeMessage)
	local obj = {}

	obj.ChatService = vChatService

	obj.Name = name
	obj.WelcomeMessage = welcomeMessage or ""

	obj.Joinable = true
	obj.Leavable = true
	obj.AutoJoin = false
	obj.Private = false

	obj.Speakers = {}
	obj.Mutes = {}

	obj.MaxHistory = 200
	obj.HistoryIndex = 0
	obj.ChatHistory = {}
	obj.MessageQueue = {}
	obj.InternalMessageQueueChanged = Instance.new("BindableEvent")

	obj.FilterMessageFunctions = {}
	obj.ProcessCommandsFunctions = {}

	obj.eDestroyed = Instance.new("BindableEvent")
	obj.Destroyed = obj.eDestroyed.Event

	obj.eMessagePosted = Instance.new("BindableEvent")
	obj.eSpeakerJoined = Instance.new("BindableEvent")
	obj.eSpeakerLeft = Instance.new("BindableEvent")
	obj.eSpeakerMuted = Instance.new("BindableEvent")
	obj.eSpeakerUnmuted = Instance.new("BindableEvent")

	obj.MessagePosted = obj.eMessagePosted.Event
	obj.SpeakerJoined = obj.eSpeakerJoined.Event
	obj.SpeakerLeft = obj.eSpeakerLeft.Event
	obj.SpeakerMuted = obj.eSpeakerMuted.Event
	obj.SpeakerUnmuted = obj.eSpeakerUnmuted.Event

	ClassMaker.MakeClass("ChatChannel", obj)

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3D7E46D37BC34919BE66630EEE7C8E08">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatServiceRunner</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatServiceRunner.lua
--	// Written by: Xsitsu
--	// Description: Main script to initialize ChatService and run ChatModules.

local EventFolderName = "DefaultChatSystemChatEvents"
local EventFolderParent = game:GetService("ReplicatedStorage")
local modulesFolder = script

local ChatService = require(modulesFolder:WaitForChild("ChatService"))

local useEvents = {}

local EventFolder = EventFolderParent:FindFirstChild(EventFolderName)
if (not EventFolder) then
	EventFolder = Instance.new("Folder")
	EventFolder.Name = EventFolderName
	EventFolder.Archivable = false
	EventFolder.Parent = EventFolderParent
end

local function GetObjectWithNameAndType(parentObject, objectName, objectType)
	for i, child in pairs(parentObject:GetChildren()) do
		if (child:IsA(objectType) and child.Name == objectName) then
			return child
		end
	end

	return nil
end

local function CreateIfDoesntExist(parentObject, objectName, objectType)
	local obj = GetObjectWithNameAndType(parentObject, objectName, objectType)
	if (not obj) then
		obj = Instance.new(objectType)
		obj.Name = objectName
		obj.Parent = parentObject
	end
	useEvents[objectName] = obj

	return obj
end

CreateIfDoesntExist(EventFolder, "OnNewMessage", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "OnMessageDoneFiltering", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "OnNewSystemMessage", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "OnChannelJoined", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "OnChannelLeft", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "OnMuted", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "OnUnmuted", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "OnMainChannelSet", "RemoteEvent")

CreateIfDoesntExist(EventFolder, "SayMessageRequest", "RemoteEvent")
CreateIfDoesntExist(EventFolder, "GetInitDataRequest", "RemoteFunction")

EventFolder = useEvents


local function CreatePlayerSpeakerObject(playerObj)
	--// If a developer already created a speaker object with the
	--// name of a player and then a player joins and tries to
	--// take that name, we first need to remove the old speaker object
	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if (speaker) then
		ChatService:RemoveSpeaker(playerObj.Name)
	end

	speaker = ChatService:InternalAddSpeakerWithPlayerObject(playerObj.Name, playerObj)

	for i, channel in pairs(ChatService:GetAutoJoinChannelList()) do
		speaker:JoinChannel(channel.Name)
	end

	speaker.ReceivedMessage:connect(function(messageObj, channel)
		EventFolder.OnNewMessage:FireClient(playerObj, messageObj, channel)
	end)

	speaker.MessageDoneFiltering:connect(function(messageObj, channel)
		EventFolder.OnMessageDoneFiltering:FireClient(playerObj, messageObj, channel)
	end)

	speaker.ReceivedSystemMessage:connect(function(messageObj, channel)
		EventFolder.OnNewSystemMessage:FireClient(playerObj, messageObj, channel)
	end)

	speaker.ChannelJoined:connect(function(channel, welcomeMessage)
		local log = nil

		local channelObject = ChatService:GetChannel(channel)
		if (channelObject) then
			log = channelObject:GetHistoryLog()
		end
		EventFolder.OnChannelJoined:FireClient(playerObj, channel, welcomeMessage, log)
	end)

	speaker.ChannelLeft:connect(function(channel)
		EventFolder.OnChannelLeft:FireClient(playerObj, channel)
	end)

	speaker.Muted:connect(function(channel, reason, length)
		EventFolder.OnMuted:FireClient(playerObj, channel, reason, length)
	end)

	speaker.Unmuted:connect(function(channel)
		EventFolder.OnUnmuted:FireClient(playerObj, channel)
	end)

	speaker.MainChannelSet:connect(function(channel)
		EventFolder.OnMainChannelSet:FireClient(playerObj, channel)
	end)
end

EventFolder.SayMessageRequest.OnServerEvent:connect(function(playerObj, message, channel)
	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if (speaker) then
		return speaker:SayMessage(message, channel)
	end

	return nil
end)

EventFolder.GetInitDataRequest.OnServerInvoke = (function(playerObj)
	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if not (speaker and speaker:GetPlayer()) then
		CreatePlayerSpeakerObject(playerObj)
		speaker = ChatService:GetSpeaker(playerObj.Name)
	end

	local data = {}
	data.Channels = {}
	data.SpeakerExtraData = {}

	for i, channelName in pairs(speaker:GetChannelList()) do
		local channelObj = ChatService:GetChannel(channelName)
		if (channelObj) then
			local channelData =
			{
				channelName,
				channelObj.WelcomeMessage,
				channelObj:GetHistoryLog(),
			}

			table.insert(data.Channels, channelData)
		end
	end

	for i, oSpeakerName in pairs(ChatService:GetSpeakerList()) do
		local oSpeaker = ChatService:GetSpeaker(oSpeakerName)
		data.SpeakerExtraData[oSpeakerName] = oSpeaker.ExtraData
	end

	return data
end)

local function DoJoinCommand(speakerName, channelName, fromChannelName)
	local speaker = ChatService:GetSpeaker(speakerName)
	local channel = ChatService:GetChannel(channelName)

	if (speaker) then
		if (channel) then
			if (channel.Joinable) then
				if (not speaker:IsInChannel(channel.Name)) then
					speaker:JoinChannel(channel.Name)
				end
			else
				speaker:SendSystemMessage("You cannot join channel '" .. channelName .. "'.", fromChannelName)
			end
		else
			speaker:SendSystemMessage("Channel '" .. channelName .. "' does not exist.", fromChannelName)
		end
	end
end

local function DoLeaveCommand(speakerName, channelName, fromChannelName)
	local speaker = ChatService:GetSpeaker(speakerName)
	local channel = ChatService:GetChannel(channelName)

	if (speaker) then
		if (speaker:IsInChannel(channelName)) then
			if (channel.Leavable) then
				speaker:LeaveChannel(channel.Name)
			else
				speaker:SendSystemMessage("You cannot leave channel '" .. channelName .. "'.", fromChannelName)
			end
		else
			speaker:SendSystemMessage("You are not in channel '" .. channelName .. "'.", fromChannelName)
		end
	end
end

ChatService:RegisterProcessCommandsFunction("default_commands", function(fromSpeaker, message, channel)
	if (string.sub(message, 1, 6):lower() == "/join ") then
		DoJoinCommand(fromSpeaker, string.sub(message, 7), channel)
		return true
	elseif (string.sub(message, 1, 3):lower() == "/j ") then
		DoJoinCommand(fromSpeaker, string.sub(message, 4), channel)
		return true

	elseif (string.sub(message, 1, 7):lower() == "/leave ") then
		DoLeaveCommand(fromSpeaker, string.sub(message, 8), channel)
		return true
	elseif (string.sub(message, 1, 3):lower() == "/l ") then
		DoLeaveCommand(fromSpeaker, string.sub(message, 4), channel)
		return true

	elseif (string.sub(message, 1, 3) == "/e " or string.sub(message, 1, 7) == "/emote ") then
		-- Just don't show these in the chatlog. The animation script listens on these.
		return true

	end

	return false
end)


local allChannel = ChatService:AddChannel("All")
local systemChannel = ChatService:AddChannel("System")

allChannel.Leavable = false
allChannel.AutoJoin = true

systemChannel.Leavable = false
systemChannel.AutoJoin = true
systemChannel.WelcomeMessage = "This channel is for system and game notifications."

systemChannel.SpeakerJoined:connect(function(speakerName)
	systemChannel:MuteSpeaker(speakerName)
end)


local function TryRunModule(module)
	if module:IsA("ModuleScript") then
		local ret = require(module)
		if (type(ret) == "function") then
			ret(ChatService)
		end
	end
end

local modules = game:GetService("Chat"):WaitForChild("ChatModules")
modules.ChildAdded:connect(function(child)
	local success, returnval = pcall(TryRunModule, child)
	if not success and returnval then
		print("Error running module " ..child.Name.. ": " ..returnval)
	end
end)

for i, module in pairs(modules:GetChildren()) do
	local success, returnval = pcall(TryRunModule, module)
	if not success and returnval then
		print("Error running module " ..module.Name.. ": " ..returnval)
	end
end

local Players = game:GetService("Players")
Players.PlayerRemoving:connect(function(playerObj)
	if (ChatService:GetSpeaker(playerObj.Name)) then
		ChatService:RemoveSpeaker(playerObj.Name)
	end
end)
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEBCE7523CE7548FBB7880B421F2511DD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Speaker</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: Speaker.lua
--	// Written by: Xsitsu
--	// Description: A representation of one entity that can chat in different ChatChannels.

local module = {}

local modulesFolder = script.Parent

--////////////////////////////// Include
--//////////////////////////////////////
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function methods:SayMessage(message, channelName, extraData)
	if (self.ChatService:InternalDoProcessCommands(self.Name, message, channelName)) then return end
	if (not channelName) then return end

	local channel = self.Channels[channelName:lower()]
	if (not channel) then
		error("Speaker is not in channel \"" .. channelName .. "\"")
	end

	local messageObj = channel:InternalPostMessage(self, message, extraData)
	if (messageObj) then
		local success, err = pcall(function() self.eSaidMessage:Fire(messageObj) end)
		if not success and err then
			print("Error saying message: " ..err)
		end
	end

	return messageObj
end

function methods:JoinChannel(channelName)
	if (self.Channels[channelName:lower()]) then
		warn("Speaker is already in channel \"" .. channelName .. "\"")
		return
	end

	local channel = self.ChatService:GetChannel(channelName)
	if (not channel) then
		error("Channel \"" .. channelName .. "\" does not exist!")
	end

	self.Channels[channelName:lower()] = channel
	channel:InternalAddSpeaker(self)
	local success, err = pcall(function()
		self.eChannelJoined:Fire(channel.Name, channel.WelcomeMessage)
	end)
	if not success and err then
		print("Error joining channel: " ..err)
	end
end

function methods:LeaveChannel(channelName)
	if (not self.Channels[channelName:lower()]) then
		warn("Speaker is not in channel \"" .. channelName .. "\"")
		return
	end

	local channel = self.Channels[channelName:lower()]

	self.Channels[channelName:lower()] = nil
	channel:InternalRemoveSpeaker(self)
	local success, err = pcall(function()
		self.eChannelLeft:Fire(channel.Name)
	end)
	if not success and err then
		print("Error leaving channel: " ..err)
	end
end

function methods:IsInChannel(channelName)
	return (self.Channels[channelName:lower()] ~= nil)
end

function methods:GetChannelList()
	local list = {}
	for i, channel in pairs(self.Channels) do
		table.insert(list, channel.Name)
	end
	return list
end

function methods:SendMessage(message, channelName, fromSpeaker, extraData)
	local channel = self.Channels[channelName:lower()]
	if (channel) then
		channel:SendMessageToSpeaker(message, self.Name, fromSpeaker, extraData)

	else
		warn(string.format("Speaker '%s' is not in channel '%s' and cannot receive a message in it.", self.Name, channelName))

	end
end

function methods:SendSystemMessage(message, channelName, extraData)
	local channel = self.Channels[channelName:lower()]
	if (channel) then
		channel:SendSystemMessageToSpeaker(message, self.Name, extraData)

	else
		warn(string.format("Speaker '%s' is not in channel '%s' and cannot receive a system message in it.", self.Name, channelName))

	end
end

function methods:GetPlayer()
	return rawget(self, "PlayerObj")
end

function methods:SetExtraData(key, value)
	self.ExtraData[key] = value
end

function methods:GetExtraData(key)
	return self.ExtraData[key]
end

function methods:SetMainChannel(channel)
	local success, err = pcall(function() self.eMainChannelSet:Fire(channel) end)
	if not success and err then
		print("Error setting main channel: " ..err)
	end
end

--- Used to mute a speaker so that this speaker does not see their messages.
function methods:AddMutedSpeaker(speakerName)
	self.MutedSpeakers[speakerName] = true
end

function methods:RemoveMutedSpeaker(speakerName)
	self.MutedSpeakers[speakerName] = false
end

function methods:IsSpeakerMuted(speakerName)
	return self.MutedSpeakers[speakerName]
end

--///////////////// Internal-Use Methods
--//////////////////////////////////////
function methods:InternalDestroy()
	for i, channel in pairs(self.Channels) do
		channel:InternalRemoveSpeaker(self)
	end

	self.eDestroyed:Fire()
end

function methods:InternalAssignPlayerObject(playerObj)
	rawset(self, "PlayerObj", playerObj)
end

function methods:InternalSendMessage(messageObj, channel)
	local success, err = pcall(function()
		self.eReceivedMessage:Fire(messageObj, channel)
	end)
	if not success and err then
		print("Error sending internal message: " ..err)
	end
end

function methods:InternalSendFilteredMessage(messageObj, channel)
	local success, err = pcall(function()
		self.eMessageDoneFiltering:Fire(messageObj, channel)
	end)
	if not success and err then
		print("Error sending internal filtered message: " ..err)
	end
end

function methods:InternalSendSystemMessage(messageObj, channel)
	local success, err = pcall(function()
		self.eReceivedSystemMessage:Fire(messageObj, channel)
	end)
	if not success and err then
		print("Error sending internal system message: " ..err)
	end
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("Speaker", methods)

function module.new(vChatService, name)
	local obj = {}

	obj.ChatService = vChatService

	obj.PlayerObj = nil

	obj.Name = name
	obj.ExtraData = {}

	obj.Channels = {}
	obj.MutedSpeakers = {}

	obj.eDestroyed = Instance.new("BindableEvent")
	obj.Destroyed = obj.eDestroyed.Event

	obj.eSaidMessage = Instance.new("BindableEvent")
	obj.eReceivedMessage = Instance.new("BindableEvent")
	obj.eMessageDoneFiltering = Instance.new("BindableEvent")
	obj.eReceivedSystemMessage = Instance.new("BindableEvent")
	obj.eChannelJoined = Instance.new("BindableEvent")
	obj.eChannelLeft = Instance.new("BindableEvent")
	obj.eMuted = Instance.new("BindableEvent")
	obj.eUnmuted = Instance.new("BindableEvent")
	obj.eMainChannelSet = Instance.new("BindableEvent")

	obj.SaidMessage = obj.eSaidMessage.Event
	obj.ReceivedMessage = obj.eReceivedMessage.Event
	obj.MessageDoneFiltering = obj.eMessageDoneFiltering.Event
	obj.ReceivedSystemMessage = obj.eReceivedSystemMessage.Event
	obj.ChannelJoined = obj.eChannelJoined.Event
	obj.ChannelLeft = obj.eChannelLeft.Event
	obj.Muted = obj.eMuted.Event
	obj.Unmuted = obj.eUnmuted.Event
	obj.MainChannelSet = obj.eMainChannelSet.Event

	ClassMaker.MakeClass("Speaker", obj)

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF58200841CE448E0A43DF8B5E054091C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatServiceInstaller</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local runnerScriptName = "ChatServiceRunner"

local installDirectory = game:GetService("Chat")
local ServerScriptService = game:GetService("ServerScriptService")

local function LoadScript(name, parent)
	local originalModule = script.Parent:WaitForChild(name)
	local script = Instance.new("Script")
	script.Name = name
	script.Source = originalModule.Source
	script.Parent = parent
	return script
end

local function LoadModule(location, name, parent)
	local originalModule = location:WaitForChild(name)
	local module = Instance.new("ModuleScript")
	module.Name = name
	module.Source = originalModule.Source
	module.Parent = parent
	return module
end

local function Install()

	local chatServiceRunnerArchivable = true
	local ChatServiceRunner = installDirectory:FindFirstChild(runnerScriptName)
	if not ChatServiceRunner then
		chatServiceRunnerArchivable = false
		ChatServiceRunner = LoadScript(runnerScriptName, installDirectory)

		LoadModule(script.Parent, "ChatService", ChatServiceRunner)
		LoadModule(script.Parent, "ChatChannel", ChatServiceRunner)
		LoadModule(script.Parent, "Speaker", ChatServiceRunner)
		LoadModule(script.Parent.Parent.Parent.Common, "ClassMaker", ChatServiceRunner)
	end

	local ChatModules = installDirectory:FindFirstChild("ChatModules")
	if not ChatModules then
		ChatModules = Instance.new("Folder")
		ChatModules.Name = "ChatModules"
		ChatModules.Archivable = false

		local defaultChatModules = script.Parent.DefaultChatModules:GetChildren()
		for i = 1, #defaultChatModules do
			LoadModule(script.Parent.DefaultChatModules, defaultChatModules[i].Name, ChatModules)
		end

		ChatModules.Parent = installDirectory
	end

	if not ServerScriptService:FindFirstChild(runnerScriptName) then
		local ChatServiceRunnerCopy = ChatServiceRunner:Clone()
		ChatServiceRunnerCopy.Archivable = false
		ChatServiceRunnerCopy.Parent = ServerScriptService
	end

	ChatServiceRunner.Archivable = chatServiceRunnerArchivable
end

return Install
]]></ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX15350DFC106546C98D3F78F659F5FF96">
					<Properties>
						<string name="Name">ClientChat</string>
					</Properties>
					<Item class="Folder" referent="RBXFCC7B0CA9025488098C11FBFABC38E7D">
						<Properties>
							<string name="Name">DefaultClientChatModules</string>
						</Properties>
						<Item class="Folder" referent="RBX8CFED250F3C04178B035BB12C55E2179">
							<Properties>
								<string name="Name">CommandModules</string>
							</Properties>
							<Item class="ModuleScript" referent="RBXB0A14050E29E48E3B4AA364147783525">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">DeveloperConsole</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: DeveloperConsole.lua
--	// Written by: TheGamer101
--	// Description: Command to open or close the developer console.

local StarterGui = game:GetService("StarterGui")
local util = require(script.Parent:WaitForChild("Util"))

function ProcessMessage(message, ChatWindow, ChatSettings)
	if string.sub(message, 1, 8) == "/console" then
		local success, developerConsoleVisible = pcall(function() return StarterGui:GetCore("DeveloperConsoleVisible") end)
		if success then
			local success, err = pcall(function() StarterGui:SetCore("DeveloperConsoleVisible", not developerConsoleVisible) end)
			if not success and err then
				print("Error making developer console visible: " ..err)
			end
		end
		return true
	end
	return false
end

return {
	[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
	[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC04C504A9EE34556AB78B440487A94D3">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Util</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: Util.lua
--	// Written by: TheGamer101
--	// Description: Module for shared code between CommandModules.

--[[
Creating a command module:
1) Create a new module inside the CommandModules folder.
2) Create a function that takes a message, the ChatWindow object and the ChatSettings and returns
a bool command processed.
3) Return this function from the module.
--]]

local clientChatModules = script.Parent.Parent
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))

local COMMAND_MODULES_VERSION = 1

local KEY_COMMAND_PROCESSOR_TYPE = "ProcessorType"
local KEY_PROCESSOR_FUNCTION = "ProcessorFunction"

---Command types.
---Process a command as it is being typed. This allows for manipulation of the chat bar.
local IN_PROGRESS_MESSAGE_PROCESSOR = 0
---Simply process a completed message.
local COMPLETED_MESSAGE_PROCESSOR = 1

local module = {}
local methods = {}
methods.__index = methods

function methods:SendSystemMessageToSelf(message, channelObj, extraData)
	local messageData =
	{
		ID = -1,
		FromSpeaker = nil,
		OriginalChannel = channelObj.Name,
		IsFiltered = true,
		MessageLength = string.len(message),
		Message = message,
		MessageType = ChatConstants.MessageTypeSystem,
		Time = os.time(),
		ExtraData = extraData,
	}

	channelObj:AddMessageToChannel(messageData)
end

function module.new()
	local obj = setmetatable({}, methods)

	obj.COMMAND_MODULES_VERSION = COMMAND_MODULES_VERSION

	obj.KEY_COMMAND_PROCESSOR_TYPE = KEY_COMMAND_PROCESSOR_TYPE
	obj.KEY_PROCESSOR_FUNCTION = KEY_PROCESSOR_FUNCTION

	obj.IN_PROGRESS_MESSAGE_PROCESSOR = IN_PROGRESS_MESSAGE_PROCESSOR
	obj.COMPLETED_MESSAGE_PROCESSOR = COMPLETED_MESSAGE_PROCESSOR

	return obj
end

return module.new()
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX03BFFF790BBB48D8A58CE36B3CB1FF96">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Team</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: Team.lua
--	// Written by: Partixel/TheGamer101
--	// Description: Team chat bar manipulation.

local TEAM_COMMANDS = {"/team ", "/t ", "% "}

function IsTeamCommand(message)
	for i = 1, #TEAM_COMMANDS do
		local teamCommand = TEAM_COMMANDS[i]
		if string.sub(message, 1, teamCommand:len()):lower() == teamCommand then
			return true
		end
	end
	return false
end

local teamStateMethods = {}
teamStateMethods.__index = teamStateMethods

local util = require(script.Parent:WaitForChild("Util"))

local TeamCustomState = {}

function teamStateMethods:EnterTeamChat()
	self.TeamChatEntered = true
	self.MessageModeLabel.Size = UDim2.new(0, 1000, 1, 0)
	self.MessageModeLabel.Text = "[Team]"
	local xSize = self.MessageModeLabel.TextBounds.X
	self.MessageModeLabel.Size = UDim2.new(0, xSize, 1, 0)
	self.TextBox.Size = UDim2.new(1, -xSize, 1, 0)
	self.TextBox.Position = UDim2.new(0, xSize, 0, 0)
	self.OriginalTeamText = self.TextBox.Text
	self.TextBox.Text = " "
end

function teamStateMethods:TextUpdated()
	local newText = self.TextBox.Text
	if not self.TeamChatEntered then
		if IsTeamCommand(newText) then
			self:EnterTeamChat()
		end
	else
		if newText == "" then
			self.MessageModeLabel.Text = ""
			self.MessageModeLabel.Size = UDim2.new(0, 0, 0, 0)
			self.TextBox.Size = UDim2.new(1, 0, 1, 0)
			self.TextBox.Position = UDim2.new(0, 0, 0, 0)
			self.TextBox.Text = ""
			---Implement this when setting cursor positon is a thing.
			---self.TextBox.Text = self.OriginalTeamText
			self.TeamChatEntered = false
		end
	end
end

function teamStateMethods:GetMessage()
	return "/t " ..self.TextBox.Text
end

function teamStateMethods:ProcessCompletedMessage()
	return false
end

function teamStateMethods:Destroy()
	self.Destroyed = true
end

function TeamCustomState.new(ChatWindow, ChatBar, ChatSettings)
	local obj = setmetatable({}, teamStateMethods)
	obj.Destroyed = false
	obj.ChatWindow = ChatWindow
	obj.ChatBar = ChatBar
	obj.ChatSettings = ChatSettings
	obj.TextBox = ChatBar:GetTextBox()
	obj.MessageModeLabel = ChatBar:GetMessageModeTextLabel()
	obj.OriginalTeamText = ""
	obj.TeamChatEntered = false

	obj:EnterTeamChat()

	return obj
end

function ProcessMessage(message, ChatWindow, ChatBar, ChatSettings)
	if ChatBar.TargetChannel == "Team" then
		return
	end

	if IsTeamCommand(message) then
		return TeamCustomState.new(ChatWindow, ChatBar, ChatSettings)
	end
	return nil
end

return {
	[util.KEY_COMMAND_PROCESSOR_TYPE] = util.IN_PROGRESS_MESSAGE_PROCESSOR,
	[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB11334CFDDC94C2EA456731882E7F080">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SwitchChannel</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: ClearMessages.lua
--	// Written by: TheGamer101
--	// Description: Command to switch channel.

local util = require(script.Parent:WaitForChild("Util"))

function ProcessMessage(message, ChatWindow, ChatSettings)
	if string.sub(message, 1, 3) ~= "/c " then
		return false
	end

	local channelName = string.sub(message, 4)

	local targetChannel = ChatWindow:GetChannel(channelName)
	if targetChannel then
		ChatWindow:SwitchCurrentChannel(channelName)
		if not ChatSettings.ShowChannelsBar then
			local currentChannel = ChatWindow:GetCurrentChannel()
			if currentChannel then
				util:SendSystemMessageToSelf(string.format("You are now chatting in channel: '%s'", channelName), targetChannel, {})
			end
		end
	else
		local currentChannel = ChatWindow:GetCurrentChannel()
		if currentChannel then
			util:SendSystemMessageToSelf(string.format("You are not in channel: '%s'", channelName), currentChannel, {ChatColor = Color3.fromRGB(245, 50, 50)})
		end
	end

	return true
end

return {
	[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
	[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7471A3A296CB45A8A2B1A66FDF62E6F9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GetVersion</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: GetVersion.lua
--	// Written by: spotco
--	// Description: Command to print the chat version.

local util = require(script.Parent:WaitForChild("Util"))
local ChatConstants = require(script.Parent.Parent:WaitForChild("ChatConstants"))

function ProcessMessage(message, ChatWindow, ChatSettings)
	if string.sub(message, 1,  8):lower() == "/version" or string.sub(message, 1, 9):lower() == "/version " then
		util:SendSystemMessageToSelf(
			string.format("This game is running chat version [%d.%d].", 
				ChatConstants.MajorVersion, 
				ChatConstants.MinorVersion),
			ChatWindow:GetCurrentChannel(),
			{})
		return true
	end
	return false
end

return {
	[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
	[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
}]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE6612A1FE8754C20A35596F5D661134A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ClearMessages</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: ClearMessages.lua
--	// Written by: TheGamer101
--	// Description: Command to clear the message log of the current channel.

local util = require(script.Parent:WaitForChild("Util"))

function ProcessMessage(message, ChatWindow, ChatSettings)
	if string.sub(message, 1, 4) == "/cls" or string.sub(message, 1, 6) == "/clear" then
		local currentChannel = ChatWindow:GetCurrentChannel()
		if (currentChannel) then
			currentChannel:ClearMessageLog()
		end
		return true
	end
	return false
end

return {
	[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
	[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBCD25223B8344E19B738ACAA0931A206">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SwallowGuestChat</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: SwallowGuestChat.lua
--	// Written by: TheGamer101
--	// Description: Stop Guests from chatting and give them a message telling them to sign up.
-- 	// Guests are generally not allowed to chat, so please do not remove this.

local util = require(script.Parent:WaitForChild("Util"))
local RunService = game:GetService("RunService")

function ProcessMessage(message, ChatWindow, ChatSettings)
	local LocalPlayer = game.Players.LocalPlayer
	if LocalPlayer and LocalPlayer.UserId < 0 and not RunService:IsStudio() then

		local channelObj = ChatWindow:GetCurrentChannel()
		if channelObj then
			util:SendSystemMessageToSelf("Create a free account to get access to chat permissions!", channelObj, {})
		end

		return true
	end
	return false
end

return {
	[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
	[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX34C1F2C48B564570B8D3764B6773188B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Whisper</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: Whisper.lua
--	// Written by: TheGamer101
--	// Description: Whisper chat bar manipulation.

local util = require(script.Parent:WaitForChild("Util"))
local playerService = game:GetService("Players")

local whisperStateMethods = {}
whisperStateMethods.__index = whisperStateMethods

local WhisperCustomState = {}

function whisperStateMethods:PlayerExists(possiblePlayerName)
	local players = playerService:GetPlayers()
	for i = 1, #players do
		if players[i].Name:lower() == possiblePlayerName:lower() then
			return true
		end
	end
	return false
end

function whisperStateMethods:TextUpdated()
	local newText = self.TextBox.Text
	if not self.PlayerNameEntered then
		local possiblePlayerName = string.sub(newText, 4)
		local player = nil
		if self:PlayerExists(possiblePlayerName) then
			player = possiblePlayerName
			self.OriginalText = string.sub(newText, 1, 3)
		end
		possiblePlayerName = string.sub(newText, 10)
		if player == nil and self:PlayerExists(possiblePlayerName) then
			player = possiblePlayerName
			self.OriginalText = string.sub(newText, 1, 9)
		end
		if player then
			self.PlayerNameEntered = true
			self.PlayerName = player

			self.MessageModeLabel.Size = UDim2.new(0, 1000, 1, 0)
			self.MessageModeLabel.Text = string.format("[%s]", player)
			local xSize = self.MessageModeLabel.TextBounds.X
			self.MessageModeLabel.Size = UDim2.new(0, xSize, 1, 0)
			self.TextBox.Size = UDim2.new(1, -xSize, 1, 0)
			self.TextBox.Position = UDim2.new(0, xSize, 0, 0)
			self.TextBox.Text = " "
		end
	else
		if newText == "" then
			self.MessageModeLabel.Text = ""
			self.MessageModeLabel.Size = UDim2.new(0, 0, 0, 0)
			self.TextBox.Size = UDim2.new(1, 0, 1, 0)
			self.TextBox.Position = UDim2.new(0, 0, 0, 0)
			self.TextBox.Text = ""
			---Implement this when setting cursor positon is a thing.
			---self.TextBox.Text = self.OriginalText .. " " .. self.PlayerName
			self.PlayerNameEntered = false
		end
	end
end

function whisperStateMethods:GetMessage()
	if self.PlayerNameEntered then
		return "/w " ..self.PlayerName.. " " ..self.TextBox.Text
	end
	return self.TextBox.Text
end

function whisperStateMethods:ProcessCompletedMessage()
	return false
end

function whisperStateMethods:Destroy()
	self.Destroyed = true
end

function WhisperCustomState.new(ChatWindow, ChatBar, ChatSettings)
	local obj = setmetatable({}, whisperStateMethods)
	obj.Destroyed = false
	obj.ChatWindow = ChatWindow
	obj.ChatBar = ChatBar
	obj.ChatSettings = ChatSettings
	obj.TextBox = ChatBar:GetTextBox()
	obj.MessageModeLabel = ChatBar:GetMessageModeTextLabel()
	obj.OriginalWhisperText = ""
	obj.PlayerNameEntered = false

	obj:TextUpdated()

	return obj
end

function ProcessMessage(message, ChatWindow, ChatBar, ChatSettings)
	if string.sub(message, 1, 3):lower() == "/w " or	string.sub(message, 1, 9):lower() == "/whisper " then
		return WhisperCustomState.new(ChatWindow, ChatBar, ChatSettings)
	end
	return nil
end

return {
	[util.KEY_COMMAND_PROCESSOR_TYPE] = util.IN_PROGRESS_MESSAGE_PROCESSOR,
	[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
}
]]></ProtectedString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX9AD70518594A448C98AD2C3C6B4EABD3">
							<Properties>
								<string name="Name">MessageCreatorModules</string>
							</Properties>
							<Item class="ModuleScript" referent="RBXB8065C0E209A40D6A1C3DD49939BEC5A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WelcomeMessge</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: WelcomeMessage.lua
--	// Written by: TheGamer101
--	// Description: Create a message label for a welcome message.

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
local util = require(script.Parent:WaitForChild("Util"))

function CreateWelcomeMessageLabel(messageData, channelName)
	local message = messageData.Message
	local extraData = messageData.ExtraData or {}
	local useFont = extraData.Font or ChatSettings.DefaultFont
	local useFontSize = extraData.FontSize or ChatSettings.ChatWindowTextSize
	local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor

	local BaseFrame, BaseMessage = util:CreateBaseMessage(message, useFont, useFontSize, useChatColor)

	local function GetHeightFunction(xSize)
		return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
	end

	local FadeParmaters = {}
	FadeParmaters[BaseMessage] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)

	return {
		[util.KEY_BASE_FRAME] = BaseFrame,
		[util.KEY_BASE_MESSAGE] = BaseMessage,
		[util.KEY_UPDATE_TEXT_FUNC] = nil,
		[util.KEY_GET_HEIGHT] = GetHeightFunction,
		[util.KEY_FADE_IN] = FadeInFunction,
		[util.KEY_FADE_OUT] = FadeOutFunction,
		[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
	}
end

return {
	[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeWelcome,
	[util.KEY_CREATOR_FUNCTION] = CreateWelcomeMessageLabel
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBE38DD588BCB4D36B1F97042B0CFF5F2">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MeCommandMessage</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: MeCommandMessage.lua
--	// Written by: TheGamer101
--	// Description: Create a message label for a me command message.

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
local util = require(script.Parent:WaitForChild("Util"))

function CreateMeCommandMessageLabel(messageData, channelName)
	local message = messageData.Message
	local extraData = messageData.ExtraData or {}
	local useFont = extraData.Font or Enum.Font.SourceSansItalic
	local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
	local useChatColor = Color3.new(1, 1, 1)
	local useChannelColor = extraData.ChannelColor or ChatSettings.DefaultChannelColor or Color3.new(1, 1, 1)
	local numNeededSpaces = 0

	local BaseFrame, BaseMessage = util:CreateBaseMessage("", useFont, useTextSize, useChatColor)
	local ChannelButton = nil

	if channelName ~= messageData.OriginalChannel then
		local formatChannelName = string.format("{%s}", messageData.OriginalChannel)
		ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, formatChannelName, useChannelColor)
		numNeededSpaces = util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
	end

	local function UpdateTextFunction(messageObject)
		if messageData.IsFiltered then
			BaseMessage.Text = string.rep(" ", numNeededSpaces) .. messageObject.FromSpeaker .. " " .. string.sub(messageObject.Message, 5)
		else
			local messageLength = string.len(messageObject.FromSpeaker) + messageObject.MessageLength - 4
			BaseMessage.Text = string.rep(" ", numNeededSpaces) .. string.rep("_", messageLength)
		end
	end

	UpdateTextFunction(messageData)

	local function GetHeightFunction(xSize)
		return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
	end

	local FadeParmaters = {}
	FadeParmaters[BaseMessage] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	if ChannelButton then
		FadeParmaters[ChannelButton] = {
			TextTransparency = {FadedIn = 0, FadedOut = 1},
			TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
		}
	end

	local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)

	return {
		[util.KEY_BASE_FRAME] = BaseFrame,
		[util.KEY_BASE_MESSAGE] = BaseMessage,
		[util.KEY_UPDATE_TEXT_FUNC] = UpdateTextFunction,
		[util.KEY_GET_HEIGHT] = GetHeightFunction,
		[util.KEY_FADE_IN] = FadeInFunction,
		[util.KEY_FADE_OUT] = FadeOutFunction,
		[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
	}
end

return {
	[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeMeCommand,
	[util.KEY_CREATOR_FUNCTION] = CreateMeCommandMessageLabel
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX243790E90D0449118DD2F813273323E0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SetCoreMessage</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: SetCoreMessage.lua
--	// Written by: TheGamer101
--	// Description: Create a message label for a message created with SetCore(ChatMakeSystemMessage).

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
local util = require(script.Parent:WaitForChild("Util"))

function CreateSetCoreMessageLabel(messageData, channelName)
	local message = messageData.Message
	local extraData = messageData.ExtraData or {}
	local useFont = extraData.Font or ChatSettings.DefaultFont
	local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
	local useColor = extraData.Color or ChatSettings.DefaultMessageColor

	local BaseFrame, BaseMessage = util:CreateBaseMessage(message, useFont, useTextSize, useColor)

	local function GetHeightFunction(xSize)
		return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
	end

	local FadeParmaters = {}
	FadeParmaters[BaseMessage] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)

	return {
		[util.KEY_BASE_FRAME] = BaseFrame,
		[util.KEY_BASE_MESSAGE] = BaseMessage,
		[util.KEY_UPDATE_TEXT_FUNC] = nil,
		[util.KEY_GET_HEIGHT] = GetHeightFunction,
		[util.KEY_FADE_IN] = FadeInFunction,
		[util.KEY_FADE_OUT] = FadeOutFunction,
		[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
	}
end

return {
	[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeSetCore,
	[util.KEY_CREATOR_FUNCTION] = CreateSetCoreMessageLabel
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE4D6F7D85E6E4625874A7F2EA228279C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Util</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: Util.lua
--	// Written by: Xsitsu, TheGamer101
--	// Description: Module for shared code between MessageCreatorModules.

--[[
Creating a message creator module:
1) Create a new module inside the MessageCreatorModules folder.
2) Create a function that takes a messageData object and returns:
{
	KEY_BASE_FRAME = BaseFrame,
	KEY_BASE_MESSAGE = BaseMessage,
	KEY_UPDATE_TEXT_FUNC = function(newMessageObject) ---Function to update the text of the message.
	KEY_GET_HEIGHT = function() ---Function to get the height of the message in absolute pixels,
	KEY_FADE_IN = function(duration, CurveUtil) ---Function to tell the message to start fading in.
	KEY_FADE_OUT = function(duration, CurveUtil) ---Function to tell the message to start fading out.
	KEY_UPDATE_ANIMATION = function(dtScale, CurveUtil) ---Update animation function.
}
3) return the following format from the module:
{
	KEY_MESSAGE_TYPE = "Message type this module creates messages for."
	KEY_CREATOR_FUNCTION = YourFunctionHere
}
--]]

local DEFAULT_MESSAGE_CREATOR = "UnknownMessage"
local MESSAGE_CREATOR_MODULES_VERSION = 1
---Creator Module Object Keys
local KEY_MESSAGE_TYPE = "MessageType"
local KEY_CREATOR_FUNCTION = "MessageCreatorFunc"
---Creator function return object keys
local KEY_BASE_FRAME = "BaseFrame"
local KEY_BASE_MESSAGE = "BaseMessage"
local KEY_UPDATE_TEXT_FUNC = "UpdateTextFunction"
local KEY_GET_HEIGHT = "GetHeightFunction"
local KEY_FADE_IN = "FadeInFunction"
local KEY_FADE_OUT = "FadeOutFunction"
local KEY_UPDATE_ANIMATION = "UpdateAnimFunction"

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
while not LocalPlayer do
	Players.ChildAdded:wait()
	LocalPlayer = Players.LocalPlayer
end

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))

local module = {}
local methods = {}
methods.__index = methods

local testLabel = Instance.new("TextLabel")
testLabel.Selectable = false
testLabel.TextWrapped = true
testLabel.Position = UDim2.new(1, 0, 1, 0)

function WaitUntilParentedCorrectly()
	while not testLabel:IsDescendantOf(LocalPlayer) do
		testLabel.AncestryChanged:wait()
	end
end

local TextSizeCache = {}
function methods:GetStringTextBounds(text, font, textSize, sizeBounds)
	WaitUntilParentedCorrectly()
	sizeBounds = sizeBounds or false
	if not TextSizeCache[text] then
		TextSizeCache[text] = {}
	end
	if not TextSizeCache[text][font] then
		TextSizeCache[text][font] = {}
	end
	if not TextSizeCache[text][font][sizeBounds] then
		TextSizeCache[text][font][sizeBounds] = {}
	end
	if not TextSizeCache[text][font][sizeBounds][textSize] then
		testLabel.Text = text
		testLabel.Font = font
		testLabel.TextSize = textSize
		if sizeBounds then
			testLabel.TextWrapped = true;
			testLabel.Size = sizeBounds
		else
			testLabel.TextWrapped = false;
		end
		TextSizeCache[text][font][sizeBounds][textSize] = testLabel.TextBounds
	end
	return TextSizeCache[text][font][sizeBounds][textSize]
end
--// Above was taken directly from Util.GetStringTextBounds() in the old chat corescripts.

function methods:GetMessageHeight(BaseMessage, BaseFrame, xSize)
	xSize = xSize or BaseFrame.AbsoluteSize.X
	local textBoundsSize = self:GetStringTextBounds(BaseMessage.Text, BaseMessage.Font, BaseMessage.TextSize, UDim2.new(0, xSize, 0, 1000))
	return textBoundsSize.Y
end

function methods:GetNumberOfSpaces(str, font, textSize)
	local strSize = self:GetStringTextBounds(str, font, textSize)
	local singleSpaceSize = self:GetStringTextBounds(" ", font, textSize)
	return math.ceil(strSize.X / singleSpaceSize.X)
end

function methods:CreateBaseMessage(message, font, textSize, chatColor)
	local BaseFrame = self:GetFromObjectPool("Frame")
	BaseFrame.Selectable = false
	BaseFrame.Size = UDim2.new(1, 0, 0, 18)
	BaseFrame.BackgroundTransparency = 1

	local messageBorder = 8

	local BaseMessage = self:GetFromObjectPool("TextLabel")
	BaseMessage.Selectable = false
	BaseMessage.Size = UDim2.new(1, -(messageBorder + 6), 1, 0)
	BaseMessage.Position = UDim2.new(0, messageBorder, 0, 0)
	BaseMessage.BackgroundTransparency = 1
	BaseMessage.Font = font
	BaseMessage.TextSize = textSize
	BaseMessage.TextXAlignment = Enum.TextXAlignment.Left
	BaseMessage.TextYAlignment = Enum.TextYAlignment.Top
	BaseMessage.TextTransparency = 0
	BaseMessage.TextStrokeTransparency = 0.75
	BaseMessage.TextColor3 = chatColor
	BaseMessage.TextWrapped = true
	BaseMessage.Text = message
	BaseMessage.Parent = BaseFrame

	return BaseFrame, BaseMessage
end

function methods:AddNameButtonToBaseMessage(BaseMessage, nameColor, formatName, playerName)
	local speakerNameSize = self:GetStringTextBounds(formatName, BaseMessage.Font, BaseMessage.TextSize)
	local NameButton = self:GetFromObjectPool("TextButton")
	NameButton.Selectable = false
	NameButton.Size = UDim2.new(0, speakerNameSize.X, 0, speakerNameSize.Y)
	NameButton.Position = UDim2.new(0, 0, 0, 0)
	NameButton.BackgroundTransparency = 1
	NameButton.Font = BaseMessage.Font
	NameButton.TextSize = BaseMessage.TextSize
	NameButton.TextXAlignment = BaseMessage.TextXAlignment
	NameButton.TextYAlignment = BaseMessage.TextYAlignment
	NameButton.TextTransparency = BaseMessage.TextTransparency
	NameButton.TextStrokeTransparency = BaseMessage.TextStrokeTransparency
	NameButton.TextColor3 = nameColor
	NameButton.Text = formatName
	NameButton.Parent = BaseMessage

	NameButton.MouseButton1Click:connect(function()
		self:NameButtonClicked(NameButton, playerName)
	end)

	return NameButton
end

function methods:AddChannelButtonToBaseMessage(BaseMessage, formatChannelName)
	local channelNameSize = self:GetStringTextBounds(formatChannelName, BaseMessage.Font, BaseMessage.TextSize)
	local ChannelButton = self:GetFromObjectPool("TextButton")
	ChannelButton.Selectable = false
	ChannelButton.Size = UDim2.new(0, channelNameSize.X, 0, channelNameSize.Y)
	ChannelButton.Position = UDim2.new(0, 0, 0, 0)
	ChannelButton.BackgroundTransparency = 1
	ChannelButton.Font = BaseMessage.Font
	ChannelButton.TextSize = BaseMessage.TextSize
	ChannelButton.TextXAlignment = BaseMessage.TextXAlignment
	ChannelButton.TextYAlignment = BaseMessage.TextYAlignment
	ChannelButton.TextTransparency = BaseMessage.TextTransparency
	ChannelButton.TextStrokeTransparency = BaseMessage.TextStrokeTransparency
	ChannelButton.TextColor3 = BaseMessage.TextColor3
	ChannelButton.Text = formatChannelName
	ChannelButton.Parent = BaseMessage
	return ChannelButton
end

function methods:NameButtonClicked(nameButton, playerName)
	if not self.ChatWindow then
		return
	end

	if ChatSettings.ClickOnPlayerNameToWhisper then
		local player = Players:FindFirstChild(playerName)
		if player and player ~= LocalPlayer then
			local whisperChannel = "To " ..playerName
			if self.ChatWindow:GetChannel(whisperChannel) then
				local targetChannelName = self.ChatWindow:GetTargetMessageChannel()
				if targetChannelName ~= whisperChannel then
					self.ChatWindow:SwitchCurrentChannel(whisperChannel)
				end
				self.ChatBar:ResetText()
				self.ChatBar:CaptureFocus()
			elseif not self.ChatBar:IsInCustomState() then
				local whisperMessage = "/w " ..playerName
				self.ChatBar:CaptureFocus()
				self.ChatBar:SetText(whisperMessage)
			end
		end
	end
end

function methods:RegisterChatWindow(chatWindow)
	self.ChatWindow = chatWindow
	self.ChatBar = chatWindow:GetChatBar()
end

function methods:GetFromObjectPool(className)
	if self.ObjectPool == nil then
		return Instance.new(className)
	end
	return self.ObjectPool:GetInstance(className)
end

function methods:RegisterObjectPool(objectPool)
	self.ObjectPool = objectPool
end

function methods:RegisterGuiRoot(root)
	testLabel.Parent = root
end

-- CreateFadeFunctions usage:
-- fadeObjects is a map of text labels and button to start and end values for a given property.
-- e.g {
--   NameButton = {
--     TextTransparency = {
--       FadedIn = 0.5,
--       FadedOut = 1,
--     }
--   },
--  ImageOne = {
--	  ImageTransparency = {
--       FadedIn = 0,
--       FadedOut = 0.5,
--     }
--   }
-- }
function methods:CreateFadeFunctions(fadeObjects)
	local AnimParams = {}
	for object, properties in pairs(fadeObjects) do
		AnimParams[object] = {}
		for property, values in pairs(properties) do
			AnimParams[object][property] = {
				Target = values.FadedIn,
				Current = object[property],
				NormalizedExptValue = 1,
			}
		end
	end

	local function FadeInFunction(duration, CurveUtil)
		for object, properties in pairs(AnimParams) do
			for property, values in pairs(properties) do
				values.Target = fadeObjects[object][property].FadedIn
				values.NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			end
		end
	end

	local function FadeOutFunction(duration, CurveUtil)
		for object, properties in pairs(AnimParams) do
			for property, values in pairs(properties) do
				values.Target = fadeObjects[object][property].FadedOut
				values.NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			end
		end
	end

	local function AnimGuiObjects()
		for object, properties in pairs(AnimParams) do
			for property, values in pairs(properties) do
				object[property] = values.Current
			end
		end
	end

	local function UpdateAnimFunction(dtScale, CurveUtil)
		for object, properties in pairs(AnimParams) do
			for property, values in pairs(properties) do
				values.Current = CurveUtil:Expt(
					values.Current,
					values.Target,
					values.NormalizedExptValue,
					dtScale
				)
			end
		end

		AnimGuiObjects()
	end

	return FadeInFunction, FadeOutFunction, UpdateAnimFunction
end

function methods:NewBindableEvent(name)
	local bindable = Instance.new("BindableEvent")
	bindable.Name = name
	return bindable
end

function module.new()
	local obj = setmetatable({}, methods)

	obj.ObjectPool = nil
	obj.ChatWindow = nil

	obj.DEFAULT_MESSAGE_CREATOR = DEFAULT_MESSAGE_CREATOR
	obj.MESSAGE_CREATOR_MODULES_VERSION = MESSAGE_CREATOR_MODULES_VERSION

	obj.KEY_MESSAGE_TYPE = KEY_MESSAGE_TYPE
	obj.KEY_CREATOR_FUNCTION = KEY_CREATOR_FUNCTION

	obj.KEY_BASE_FRAME = KEY_BASE_FRAME
	obj.KEY_BASE_MESSAGE = KEY_BASE_MESSAGE
	obj.KEY_UPDATE_TEXT_FUNC = KEY_UPDATE_TEXT_FUNC
	obj.KEY_GET_HEIGHT = KEY_GET_HEIGHT
	obj.KEY_FADE_IN = KEY_FADE_IN
	obj.KEY_FADE_OUT = KEY_FADE_OUT
	obj.KEY_UPDATE_ANIMATION = KEY_UPDATE_ANIMATION

	return obj
end

return module.new()
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF4DCA7B6E41C41FDA83DCD9BA3A51536">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SystemMessage</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: SystemMessage.lua
--	// Written by: TheGamer101
--	// Description: Create a message label for a system message.

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
local util = require(script.Parent:WaitForChild("Util"))

function CreateSystemMessageLabel(messageData, channelName)
	local message = messageData.Message
	local extraData = messageData.ExtraData or {}
	local useFont = extraData.Font or ChatSettings.DefaultFont
	local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
	local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor
	local useChannelColor = extraData.ChannelColor or ChatSettings.DefaultChannelColor or Color3.new(1, 1, 1)

	local BaseFrame, BaseMessage = util:CreateBaseMessage(message, useFont, useTextSize, useChatColor)
	local ChannelButton = nil

	if channelName ~= messageData.OriginalChannel then
			local formatChannelName = string.format("{%s}", messageData.OriginalChannel)
			ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, formatChannelName, useChannelColor)
			local numNeededSpaces = util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
			BaseMessage.Text = string.rep(" ", numNeededSpaces) .. message
	end

	local function GetHeightFunction(xSize)
		return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
	end

	local FadeParmaters = {}
	FadeParmaters[BaseMessage] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	if ChannelButton then
		FadeParmaters[ChannelButton] = {
			TextTransparency = {FadedIn = 0, FadedOut = 1},
			TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
		}
	end

	local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)

	return {
		[util.KEY_BASE_FRAME] = BaseFrame,
		[util.KEY_BASE_MESSAGE] = BaseMessage,
		[util.KEY_UPDATE_TEXT_FUNC] = nil,
		[util.KEY_GET_HEIGHT] = GetHeightFunction,
		[util.KEY_FADE_IN] = FadeInFunction,
		[util.KEY_FADE_OUT] = FadeOutFunction,
		[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
	}
end

return {
	[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeSystem,
	[util.KEY_CREATOR_FUNCTION] = CreateSystemMessageLabel
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAC41D410F5DC4DF7A17766911CEF62B3">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">DefaultChatMessage</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: DefaultChatMessage.lua
--	// Written by: TheGamer101
--	// Description: Create a message label for a standard chat message.

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
local util = require(script.Parent:WaitForChild("Util"))

function CreateMessageLabel(messageData, channelName)

	local fromSpeaker = messageData.FromSpeaker
	local message = messageData.Message

	local extraData = messageData.ExtraData or {}
	local useFont = extraData.Font or ChatSettings.DefaultFont
	local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
	local useNameColor = extraData.NameColor or ChatSettings.DefaultNameColor
	local useChannelColor = extraData.ChannelColor or ChatSettings.DefaultChannelColor or Color3.new(1, 1, 1)
	local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor

	local formatUseName = string.format("[%s]:", fromSpeaker)
	local speakerNameSize = util:GetStringTextBounds(formatUseName, useFont, useTextSize)
	local numNeededSpaces = util:GetNumberOfSpaces(formatUseName, useFont, useTextSize) + 1

	local BaseFrame, BaseMessage = util:CreateBaseMessage("", useFont, useTextSize, useChatColor)
	local NameButton = util:AddNameButtonToBaseMessage(BaseMessage, useNameColor, formatUseName, fromSpeaker)
	local ChannelButton = nil

	if channelName ~= messageData.OriginalChannel then
			local formatChannelName = string.format("{%s}", messageData.OriginalChannel)
			ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, formatChannelName, useChannelColor)
			NameButton.Position = UDim2.new(0, ChannelButton.Size.X.Offset + util:GetStringTextBounds(" ", useFont, useTextSize).X, 0, 0)
			numNeededSpaces = numNeededSpaces + util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
	end

	local function UpdateTextFunction(messageObject)
		if messageData.IsFiltered then
			BaseMessage.Text = string.rep(" ", numNeededSpaces) .. messageObject.Message
		else
			BaseMessage.Text = string.rep(" ", numNeededSpaces) .. string.rep("_", messageObject.MessageLength)
		end
	end

	UpdateTextFunction(messageData)

	local function GetHeightFunction(xSize)
		return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
	end

	local FadeParmaters = {}
	FadeParmaters[NameButton] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	FadeParmaters[BaseMessage] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	if ChannelButton then
		FadeParmaters[ChannelButton] = {
			TextTransparency = {FadedIn = 0, FadedOut = 1},
			TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
		}
	end

	local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)

	return {
		[util.KEY_BASE_FRAME] = BaseFrame,
		[util.KEY_BASE_MESSAGE] = BaseMessage,
		[util.KEY_UPDATE_TEXT_FUNC] = UpdateTextFunction,
		[util.KEY_GET_HEIGHT] = GetHeightFunction,
		[util.KEY_FADE_IN] = FadeInFunction,
		[util.KEY_FADE_OUT] = FadeOutFunction,
		[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
	}
end

return {
	[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeDefault,
	[util.KEY_CREATOR_FUNCTION] = CreateMessageLabel
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFB5B91419A1D4D34A097404769964181">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WhisperMessage</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: WhisperMessage.lua
--	// Written by: TheGamer101
--	// Description: Create a message label for a whisper chat message.

local PlayersService = game:GetService("Players")
local LocalPlayer = PlayersService.LocalPlayer
while not LocalPlayer do
	LocalPlayer = PlayersService.LocalPlayer
end

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
local util = require(script.Parent:WaitForChild("Util"))

function CreateMessageLabel(messageData, channelName)

	local fromSpeaker = messageData.FromSpeaker
	local message = messageData.Message

	local extraData = messageData.ExtraData or {}
	local useFont = extraData.Font or ChatSettings.DefaultFont
	local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
	local useNameColor = extraData.NameColor or ChatSettings.DefaultNameColor
	local useChannelColor = extraData.ChannelColor or ChatSettings.DefaultChannelColor or Color3.new(1, 1, 1)

	local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor

	local formatUseName = string.format("[%s]:", fromSpeaker)
	local speakerNameSize = util:GetStringTextBounds(formatUseName, useFont, useTextSize)
	local numNeededSpaces = util:GetNumberOfSpaces(formatUseName, useFont, useTextSize) + 1

	local BaseFrame, BaseMessage = util:CreateBaseMessage("", useFont, useTextSize, useChatColor)
	local NameButton = util:AddNameButtonToBaseMessage(BaseMessage, useNameColor, formatUseName, fromSpeaker)
	local ChannelButton = nil

	if channelName ~= messageData.OriginalChannel then
			local whisperString = messageData.OriginalChannel
			if messageData.FromSpeaker ~= LocalPlayer.Name then
				whisperString = string.format("From %s", messageData.FromSpeaker)
			end

			local formatChannelName = string.format("{%s}", whisperString)
			ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, formatChannelName, useChannelColor)
			NameButton.Position = UDim2.new(0, ChannelButton.Size.X.Offset + util:GetStringTextBounds(" ", useFont, useTextSize).X, 0, 0)
			numNeededSpaces = numNeededSpaces + util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
	end

	local function UpdateTextFunction(messageObject)
		if messageData.IsFiltered then
			BaseMessage.Text = string.rep(" ", numNeededSpaces) .. messageObject.Message
		else
			BaseMessage.Text = string.rep(" ", numNeededSpaces) .. string.rep("_", messageObject.MessageLength)
		end
	end

	UpdateTextFunction(messageData)

	local function GetHeightFunction(xSize)
		return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
	end

	local FadeParmaters = {}
	FadeParmaters[NameButton] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	FadeParmaters[BaseMessage] = {
		TextTransparency = {FadedIn = 0, FadedOut = 1},
		TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
	}

	if ChannelButton then
		FadeParmaters[ChannelButton] = {
			TextTransparency = {FadedIn = 0, FadedOut = 1},
			TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
		}
	end

	local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)

	return {
		[util.KEY_BASE_FRAME] = BaseFrame,
		[util.KEY_BASE_MESSAGE] = BaseMessage,
		[util.KEY_UPDATE_TEXT_FUNC] = UpdateTextFunction,
		[util.KEY_GET_HEIGHT] = GetHeightFunction,
		[util.KEY_FADE_IN] = FadeInFunction,
		[util.KEY_FADE_OUT] = FadeOutFunction,
		[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
	}
end

return {
	[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeWhisper,
	[util.KEY_CREATOR_FUNCTION] = CreateMessageLabel
}
]]></ProtectedString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4F48E6FF8F2C41EDB5A45E37949C53FC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">UnknownMessage</string>
									<string name="ScriptGuid"></string>
									<ProtectedString name="Source"><![CDATA[--	// FileName: UnknownMessage.lua
--	// Written by: TheGamer101
--	// Description: Default handler for message types with no other creator registered.
--	// Just print that there was a message with no creator for now.

local MESSAGE_TYPE = "UnknownMessage"

local clientChatModules = script.Parent.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local util = require(script.Parent:WaitForChild("Util"))

function CreateUknownMessageLabel(messageData)
	print("No message creator for message: " ..messageData.Message)
end

return {
	[util.KEY_MESSAGE_TYPE] = MESSAGE_TYPE,
	[util.KEY_CREATOR_FUNCTION] = CreateUknownMessageLabel
}
]]></ProtectedString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXF318FDA79F44423DA79605531AF23DDB">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ChatSettings</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: ChatSettings.lua
--	// Written by: Xsitsu
--	// Description: Settings module for configuring different aspects of the chat window.

local module = {}

---[[ Chat Behaviour Settings ]]
module.WindowDraggable = false
module.WindowResizable = false
module.ShowChannelsBar = false
module.GamepadNavigationEnabled = false
module.ShowUserOwnFilteredMessage = false	--Show a user the filtered version of their message rather than the original.
-- Make the chat work when the top bar is off
module.ChatOnWithTopBarOff = false

---[[ Chat Text Size Settings ]]
module.ChatWindowTextSize = 18
module.ChatChannelsTabTextSize = 18
module.ChatBarTextSize = 18
module.ChatWindowTextSizePhone = 14
module.ChatChannelsTabTextSizePhone = 18
module.ChatBarTextSizePhone = 14

---[[ Font Settings ]]
module.DefaultFont = Enum.Font.SourceSansBold
module.ChatBarFont = Enum.Font.SourceSansBold

----[[ Color Settings ]]
module.BackGroundColor = Color3.new(0, 0, 0)
module.DefaultMessageColor = Color3.new(1, 1, 1)
module.DefaultNameColor = Color3.new(1, 1, 1)
module.DefaultChannelColor = Color3.new(1, 1, 1)
module.ChatBarBackGroundColor = Color3.new(0, 0, 0)
module.ChatBarBoxColor = Color3.new(1, 1, 1)
module.ChatBarTextColor = Color3.new(0, 0, 0)
module.ChannelsTabUnselectedColor = Color3.new(0, 0, 0)
module.ChannelsTabSelectedColor = Color3.new(30/255, 30/255, 30/255)

---[[ Window Settings ]]
module.MinimumWindowSize = UDim2.new(0.3, 0, 0.25, 0)
module.MaximumWindowSize = UDim2.new(1, 0, 1, 0) -- if you change this to be greater than full screen size, weird things start to happen with size/position bounds checking.
module.DefaultWindowPosition = UDim2.new(0, 0, 0, 0)
local extraOffset = (7 * 2) + (5 * 2) -- Extra chatbar vertical offset
module.DefaultWindowSizePhone = UDim2.new(0.5, 0, 0.5, extraOffset)
module.DefaultWindowSizeTablet = UDim2.new(0.4, 0, 0.3, extraOffset)
module.DefaultWindowSizeDesktop = UDim2.new(0.3, 0, 0.25, extraOffset)

---[[ Fade Out and In Settings ]]
module.ChatWindowBackgroundFadeOutTime = 0.5 --Chat background will fade out after this many seconds.
module.ChatWindowTextFadeOutTime = 30				--Chat text will fade out after this many seconds.
module.ChatDefaultFadeDuration = 0.8
module.ChatShouldFadeInFromNewInformation = false

---[[ Channel Settings ]]
module.GeneralChannelName = "All" -- You can set to nil to turn off echoing to a general channel.
module.ChannelsBarFullTabSize = 4 -- number of tabs in bar before it starts to scroll
module.MaxChannelNameLength = 12
--// Although this feature is pretty much ready, it needs some UI design still.
module.RightClickToLeaveChannelEnabled = false
module.MessageHistoryLengthPerChannel = 50

---[[ Message Settings ]]
module.MaximumMessageLength = 200
module.DisallowedWhiteSpace = {"\n", "\r", "\t", "\v", "\f"}
module.ClickOnPlayerNameToWhisper = true

local ChangedEvent = Instance.new("BindableEvent")

local proxyTable = setmetatable({},
{
	__index = function(tbl, index)
		return module[index]
	end,
	__newindex = function(tbl, index, value)
		module[index] = value
		ChangedEvent:Fire(index, value)
	end,
})

rawset(proxyTable, "SettingsChanged", ChangedEvent.Event)

return proxyTable
]]></ProtectedString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6664D6CAAAA043CAA01BC96B54CE5423">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ChatConstants</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--	// FileName: ChatConstants.lua
--	// Written by: TheGamer101
--	// Description: Module for creating chat constants shared between server and client.

local module = {}

---[[ Message Types ]]
module.MessageTypeDefault = "Message"
module.MessageTypeSystem = "System"
module.MessageTypeMeCommand = "MeCommand"
module.MessageTypeWelcome = "Welcome"
module.MessageTypeSetCore = "SetCore"
module.MessageTypeWhisper = "Whisper"

module.MajorVersion = 0
module.MinorVersion = 2

return module
]]></ProtectedString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX01EC0855816341D38B17811ABF485603">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MessageSender</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: MessageSender.lua
--	// Written by: Xsitsu
--	// Description: Module to centralize sending message functionality.

local module = {}
--////////////////////////////// Include
--//////////////////////////////////////
local modulesFolder = script.Parent
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function methods:SendMessage(message, toChannel)
	self.SayMessageRequest:FireServer(message, toChannel)
end

function methods:RegisterSayMessageFunction(func)
	rawset(self, "SayMessageRequest", func)
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("MessageSender", methods)

function module.new()
	local obj = {}
	obj.SayMessageRequest = nil

	ClassMaker.MakeClass("MessageSender", obj)

	return obj
end

return module.new()
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB84389C1EC23467E98515EEF2C3013C0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatWindow</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatWindow.lua
--	// Written by: Xsitsu
--	// Description: Main GUI window piece. Manages ChatBar, ChannelsBar, and ChatChannels.

local module = {}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local PHONE_SCREEN_WIDTH = 640
local TABLET_SCREEN_WIDTH = 1024

local DEVICE_PHONE = 1
local DEVICE_TABLET = 2
local DEVICE_DESKTOP = 3

--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local modulesFolder = script.Parent
local moduleChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}


function bubbleChatOnly()
 	return not Players.ClassicChat and Players.BubbleChat
end

function methods:CreateGuiObjects(targetParent)
	local BaseFrame = Instance.new("Frame")
	BaseFrame.BackgroundTransparency = 1
	BaseFrame.Active = true
	BaseFrame.Parent = targetParent

	local ChatBarParentFrame = Instance.new("Frame")
	ChatBarParentFrame.Selectable = false
	ChatBarParentFrame.Name = "ChatBarParentFrame"
	ChatBarParentFrame.BackgroundTransparency = 1
	ChatBarParentFrame.Parent = BaseFrame

	local ChannelsBarParentFrame = Instance.new("Frame")
	ChannelsBarParentFrame.Selectable = false
	ChannelsBarParentFrame.Name = "ChannelsBarParentFrame"
	ChannelsBarParentFrame.BackgroundTransparency = 1
	ChannelsBarParentFrame.Position = UDim2.new(0, 0, 0, 0)
	ChannelsBarParentFrame.Parent = BaseFrame

	local ChatChannelParentFrame = Instance.new("Frame")
	ChatChannelParentFrame.Selectable = false
	ChatChannelParentFrame.Name = "ChatChannelParentFrame"
	ChatChannelParentFrame.BackgroundTransparency = 1
	ChatChannelParentFrame.BackgroundColor3 = ChatSettings.BackGroundColor
	ChatChannelParentFrame.BackgroundTransparency = 0.6
	ChatChannelParentFrame.BorderSizePixel = 0
	ChatChannelParentFrame.Parent = BaseFrame

	local ChatResizerFrame = Instance.new("ImageButton")
	ChatResizerFrame.Selectable = false
	ChatResizerFrame.Image = ""
	ChatResizerFrame.BackgroundTransparency = 0.6
	ChatResizerFrame.BorderSizePixel = 0
	ChatResizerFrame.Visible = false
	ChatResizerFrame.BackgroundColor3 = ChatSettings.BackGroundColor
	ChatResizerFrame.Active = true
	ChatResizerFrame.Parent = BaseFrame

	local ResizeIcon = Instance.new("ImageLabel")
	ResizeIcon.Selectable = false
	ResizeIcon.Size = UDim2.new(0.8, 0, 0.8, 0)
	ResizeIcon.Position = UDim2.new(0.2, 0, 0.2, 0)
	ResizeIcon.BackgroundTransparency = 1
	ResizeIcon.Image = "rbxassetid://261880743"
	ResizeIcon.Parent = ChatResizerFrame

	local function GetScreenGuiParent()
		--// Travel up parent list until you find the ScreenGui that the chat window is parented to
		local screenGuiParent = BaseFrame
		while (screenGuiParent and not screenGuiParent:IsA("ScreenGui")) do
			screenGuiParent = screenGuiParent.Parent
		end

		return screenGuiParent
	end


	local deviceType = DEVICE_DESKTOP

	local screenGuiParent = GetScreenGuiParent()
	if (screenGuiParent.AbsoluteSize.X <= PHONE_SCREEN_WIDTH) then
		deviceType = DEVICE_PHONE

	elseif (screenGuiParent.AbsoluteSize.X <= TABLET_SCREEN_WIDTH) then
		deviceType = DEVICE_TABLET

	end

	local checkSizeLock = false
	local function doCheckSizeBounds()
		if (checkSizeLock) then return end
		checkSizeLock = true

		if (not BaseFrame:IsDescendantOf(PlayerGui)) then return end

		local screenGuiParent = GetScreenGuiParent()

		local minWinSize = ChatSettings.MinimumWindowSize
		local maxWinSize = ChatSettings.MaximumWindowSize

		local forceMinY = ChannelsBarParentFrame.AbsoluteSize.Y + ChatBarParentFrame.AbsoluteSize.Y

		local minSizePixelX = (minWinSize.X.Scale * screenGuiParent.AbsoluteSize.X) + minWinSize.X.Offset
		local minSizePixelY = math.max((minWinSize.Y.Scale * screenGuiParent.AbsoluteSize.Y) + minWinSize.Y.Offset, forceMinY)

		local maxSizePixelX = (maxWinSize.X.Scale * screenGuiParent.AbsoluteSize.X) + maxWinSize.X.Offset
		local maxSizePixelY = (maxWinSize.Y.Scale * screenGuiParent.AbsoluteSize.Y) + maxWinSize.Y.Offset

		local absSizeX = BaseFrame.AbsoluteSize.X
		local absSizeY = BaseFrame.AbsoluteSize.Y

		if (absSizeX < minSizePixelX) then
			local offset = UDim2.new(0, minSizePixelX - absSizeX, 0, 0)
			BaseFrame.Size = BaseFrame.Size + offset

		elseif (absSizeX > maxSizePixelX) then
			local offset = UDim2.new(0, maxSizePixelX - absSizeX, 0, 0)
			BaseFrame.Size = BaseFrame.Size + offset

		end

		if (absSizeY < minSizePixelY) then
			local offset = UDim2.new(0, 0, 0, minSizePixelY - absSizeY)
			BaseFrame.Size = BaseFrame.Size + offset

		elseif (absSizeY > maxSizePixelY) then
			local offset = UDim2.new(0, 0, 0, maxSizePixelY - absSizeY)
			BaseFrame.Size = BaseFrame.Size + offset

		end

		local xScale = BaseFrame.AbsoluteSize.X / screenGuiParent.AbsoluteSize.X
		local yScale = BaseFrame.AbsoluteSize.Y / screenGuiParent.AbsoluteSize.Y
		BaseFrame.Size = UDim2.new(xScale, 0, yScale, 0)

		checkSizeLock = false
	end


	BaseFrame.Changed:connect(function(prop)
		if (prop == "AbsoluteSize") then
			doCheckSizeBounds()
		end
	end)



	ChatResizerFrame.DragBegin:connect(function(startUdim)
		BaseFrame.Draggable = false
	end)

	local function UpdatePositionFromDrag(atPos)
		if ChatSettings.WindowDraggable == false and ChatSettings.WindowResizable == false then
			return
		end
		local newSize = atPos - BaseFrame.AbsolutePosition + ChatResizerFrame.AbsoluteSize
		BaseFrame.Size = UDim2.new(0, newSize.X, 0, newSize.Y)
		if bubbleChatOnly() then
			ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 0, 0)
		else
			ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 1, -ChatResizerFrame.AbsoluteSize.Y)
		end
	end

	ChatResizerFrame.DragStopped:connect(function(endX, endY)
		BaseFrame.Draggable = ChatSettings.WindowDraggable
		--UpdatePositionFromDrag(Vector2.new(endX, endY))
	end)

	local resizeLock = false
	ChatResizerFrame.Changed:connect(function(prop)
		if (prop == "AbsolutePosition" and not BaseFrame.Draggable) then
			if (resizeLock) then return end
			resizeLock = true

			UpdatePositionFromDrag(ChatResizerFrame.AbsolutePosition)

			resizeLock = false
		end
	end)

	local function CalculateChannelsBarPixelSize(textSize)
		if (deviceType == DEVICE_PHONE) then
			textSize = textSize or ChatSettings.ChatChannelsTabTextSizePhone
		else
			textSize = textSize or ChatSettings.ChatChannelsTabTextSize
		end

		local channelsBarTextYSize = textSize
		local chatChannelYSize = math.max(32, channelsBarTextYSize + 8) + 2

		return chatChannelYSize
	end

	local function CalculateChatBarPixelSize(textSize)
		if (deviceType == DEVICE_PHONE) then
			textSize = textSize or ChatSettings.ChatBarTextSizePhone
		else
			textSize = textSize or ChatSettings.ChatBarTextSize
		end

		local chatBarTextSizeY = textSize
		local chatBarYSize = chatBarTextSizeY + (7 * 2) + (5 * 2)

		return chatBarYSize
	end

	if bubbleChatOnly() then
		ChatBarParentFrame.Position = UDim2.new(0, 0, 0, 0)
		ChannelsBarParentFrame.Visible = false
		ChannelsBarParentFrame.Active = false
		ChatChannelParentFrame.Visible = false
		ChatChannelParentFrame.Active = false

		local useXScale = 0
		local useXOffset = 0

		local screenGuiParent = GetScreenGuiParent()

		if (deviceType == DEVICE_PHONE) then
			useXScale = ChatSettings.DefaultWindowSizePhone.X.Scale
			useXOffset = ChatSettings.DefaultWindowSizePhone.X.Offset

		elseif (deviceType == DEVICE_TABLET) then
			useXScale = ChatSettings.DefaultWindowSizeTablet.X.Scale
			useXOffset = ChatSettings.DefaultWindowSizeTablet.X.Offset

		else
			useXScale = ChatSettings.DefaultWindowSizeTablet.X.Scale
			useXOffset = ChatSettings.DefaultWindowSizeTablet.X.Offset

		end

		local chatBarYSize = CalculateChatBarPixelSize()

		BaseFrame.Size = UDim2.new(useXScale, useXOffset, 0, chatBarYSize)
		BaseFrame.Position = ChatSettings.DefaultWindowPosition

	else

		local screenGuiParent = GetScreenGuiParent()

		if (deviceType == DEVICE_PHONE) then
			BaseFrame.Size = ChatSettings.DefaultWindowSizePhone

		elseif (deviceType == DEVICE_TABLET) then
			BaseFrame.Size = ChatSettings.DefaultWindowSizeTablet

		else
			BaseFrame.Size = ChatSettings.DefaultWindowSizeDesktop

		end

		BaseFrame.Position = ChatSettings.DefaultWindowPosition

	end

	if (deviceType == DEVICE_PHONE) then
		ChatSettings.ChatWindowTextSize = ChatSettings.ChatWindowTextSizePhone
		ChatSettings.ChatChannelsTabTextSize = ChatSettings.ChatChannelsTabTextSizePhone
		ChatSettings.ChatBarTextSize = ChatSettings.ChatBarTextSizePhone
	end

	local function UpdateDraggable(enabled)
		BaseFrame.Draggable = enabled
	end

	local function UpdateResizable(enabled)
		ChatResizerFrame.Visible = enabled
		ChatResizerFrame.Draggable = enabled

		local frameSizeY = ChatBarParentFrame.Size.Y.Offset

		if (enabled) then
			ChatBarParentFrame.Size = UDim2.new(1, -frameSizeY - 2, 0, frameSizeY)
			if not bubbleChatOnly() then
				ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -frameSizeY)
			end
		else
			ChatBarParentFrame.Size = UDim2.new(1, 0, 0, frameSizeY)
			if not bubbleChatOnly() then
				ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -frameSizeY)
			end
		end
	end

	local function UpdateChatChannelParentFrameSize()
		local channelsBarSize = CalculateChannelsBarPixelSize()
		local chatBarSize = CalculateChatBarPixelSize()

		if (ChatSettings.ShowChannelsBar) then
			ChatChannelParentFrame.Size = UDim2.new(1, 0, 1, -(channelsBarSize + chatBarSize + 2 + 2))
			ChatChannelParentFrame.Position = UDim2.new(0, 0, 0, channelsBarSize + 2)

		else
			ChatChannelParentFrame.Size = UDim2.new(1, 0, 1, -(chatBarSize + 2 + 2))
			ChatChannelParentFrame.Position = UDim2.new(0, 0, 0, 2)

		end
	end

	local function UpdateChatChannelsTabTextSize(size)
		local channelsBarSize = CalculateChannelsBarPixelSize(size)
		ChannelsBarParentFrame.Size = UDim2.new(1, 0, 0, channelsBarSize)

		UpdateChatChannelParentFrameSize()
	end

	local function UpdateChatBarTextSize(size)
		local chatBarSize = CalculateChatBarPixelSize(size)

		ChatBarParentFrame.Size = UDim2.new(1, 0, 0, chatBarSize)
		if not bubbleChatOnly() then
			ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -chatBarSize)
		end

		ChatResizerFrame.Size = UDim2.new(0, chatBarSize, 0, chatBarSize)
		ChatResizerFrame.Position = UDim2.new(1, -chatBarSize, 1, -chatBarSize)

		UpdateChatChannelParentFrameSize()
		UpdateResizable(ChatSettings.WindowResizable)
	end

	local function UpdateShowChannelsBar(enabled)
		ChannelsBarParentFrame.Visible = enabled
		UpdateChatChannelParentFrameSize()
	end

	UpdateChatChannelsTabTextSize(ChatSettings.ChatChannelsTabTextSize)
	UpdateChatBarTextSize(ChatSettings.ChatBarTextSize)
	UpdateDraggable(ChatSettings.WindowDraggable)
	UpdateResizable(ChatSettings.WindowResizable)
	UpdateShowChannelsBar(ChatSettings.ShowChannelsBar)

	ChatSettings.SettingsChanged:connect(function(setting, value)
		if (setting == "WindowDraggable") then
			UpdateDraggable(value)

		elseif (setting == "WindowResizable") then
			UpdateResizable(value)

		elseif (setting == "ChatChannelsTabTextSize") then
			UpdateChatChannelsTabTextSize(value)

		elseif (setting == "ChatBarTextSize") then
			UpdateChatBarTextSize(value)

		elseif (setting == "ShowChannelsBar") then
			UpdateShowChannelsBar(value)

		end
	end)

	rawset(self, "GuiObject", BaseFrame)

	self.GuiObjects.BaseFrame = BaseFrame
	self.GuiObjects.ChatBarParentFrame = ChatBarParentFrame
	self.GuiObjects.ChannelsBarParentFrame = ChannelsBarParentFrame
	self.GuiObjects.ChatChannelParentFrame = ChatChannelParentFrame
	self.GuiObjects.ChatResizerFrame = ChatResizerFrame
	self.GuiObjects.ResizeIcon = ResizeIcon
	self:AnimGuiObjects()
end

function methods:GetChatBar()
	return rawget(self, "ChatBar")
end

function methods:RegisterChatBar(ChatBar)
	rawset(self, "ChatBar", ChatBar)
	self.ChatBar:CreateGuiObjects(self.GuiObjects.ChatBarParentFrame)
end

function methods:RegisterChannelsBar(ChannelsBar)
	rawset(self, "ChannelsBar", ChannelsBar)
	self.ChannelsBar:CreateGuiObjects(self.GuiObjects.ChannelsBarParentFrame)
end

function methods:RegisterMessageLogDisplay(MessageLogDisplay)
	rawset(self, "MessageLogDisplay", MessageLogDisplay)
	self.MessageLogDisplay.GuiObject.Parent = self.GuiObjects.ChatChannelParentFrame
end

function methods:AddChannel(channelName)
	if (self:GetChannel(channelName)) then
		error("Channel '" .. channelName .. "' already exists!")
		return
	end

	local channel = moduleChatChannel.new(channelName, self.MessageLogDisplay)
	self.Channels[channelName:lower()] = channel

	channel:SetActive(false)

	local tab = self.ChannelsBar:AddChannelTab(channelName)
	tab.NameTag.MouseButton1Click:connect(function()
		self:SwitchCurrentChannel(channelName)
	end)

	channel:RegisterChannelTab(tab)

	return channel
end

function methods:GetFirstChannel()
	--// Channels are not indexed numerically, so this function is necessary.
	--// Grabs and returns the first channel it happens to, or nil if none exist.
	for i, v in pairs(self.Channels) do
		return v
	end
	return nil
end

function methods:RemoveChannel(channelName)
	if (not self:GetChannel(channelName)) then
		error("Channel '" .. channelName .. "' does not exist!")
	end

	local indexName = channelName:lower()

	local needsChannelSwitch = false
	if (self.Channels[indexName] == self:GetCurrentChannel()) then
		needsChannelSwitch = true

		self:SwitchCurrentChannel(nil)
	end

	self.Channels[indexName]:Destroy()
	self.Channels[indexName] = nil

	self.ChannelsBar:RemoveChannelTab(channelName)

	if (needsChannelSwitch) then
		local generalChannelExists = (self:GetChannel(ChatSettings.GeneralChannelName) ~= nil)
		local removingGeneralChannel = (indexName == ChatSettings.GeneralChannelName:lower())

		local targetSwitchChannel = nil

		if (generalChannelExists and not removingGeneralChannel) then
			targetSwitchChannel = ChatSettings.GeneralChannelName
		else
			local firstChannel = self:GetFirstChannel()
			targetSwitchChannel = (firstChannel and firstChannel.Name or nil)
		end

		self:SwitchCurrentChannel(targetSwitchChannel)
	end

	if (not ChatSettings.ShowChannelsBar) then
		if (rawget(self.ChatBar, "TargetChannel") == channelName) then
			self.ChatBar:SetChannelTarget(ChatSettings.GeneralChannelName)
		end
	end
end

function methods:GetChannel(channelName)
	return channelName and self.Channels[channelName:lower()] or nil
end

function methods:GetTargetMessageChannel()
	if (not ChatSettings.ShowChannelsBar) then
		return rawget(self.ChatBar, "TargetChannel")
	else
		local curChannel = self:GetCurrentChannel()
		return curChannel and curChannel.Name
	end
end

function methods:GetCurrentChannel()
	return rawget(self, "CurrentChannel")
end

function methods:SwitchCurrentChannel(channelName)
	if (not ChatSettings.ShowChannelsBar) then
		local targ = self:GetChannel(channelName)
		if (targ) then
			self.ChatBar:SetChannelTarget(targ.Name)
		end

		channelName = ChatSettings.GeneralChannelName
	end

	local cur = self:GetCurrentChannel()
	local new = self:GetChannel(channelName)

	if (new ~= cur) then
		if (cur) then
			cur:SetActive(false)
			local tab = self.ChannelsBar:GetChannelTab(cur.Name)
			tab:SetActive(false)
		end

		if (new) then
			new:SetActive(true)
			local tab = self.ChannelsBar:GetChannelTab(new.Name)
			tab:SetActive(true)
		end

		rawset(self, "CurrentChannel", new)
	end

end

function methods:UpdateFrameVisibility()
	self.GuiObject.Visible = (self.Visible and self.CoreGuiEnabled)
end

function methods:GetVisible()
	return self.Visible
end

function methods:SetVisible(visible)
	self.Visible = visible
	self:UpdateFrameVisibility()
end

function methods:GetCoreGuiEnabled()
	return self.CoreGuiEnabled
end

function methods:SetCoreGuiEnabled(enabled)
	self.CoreGuiEnabled = enabled
	self:UpdateFrameVisibility()
end

function methods:EnableResizable()
	self.GuiObjects.ChatResizerFrame.Active = true
end

function methods:DisableResizable()
	self.GuiObjects.ChatResizerFrame.Active = false
end

function methods:ResetResizerPosition()
	local ChatResizerFrame = self.GuiObjects.ChatResizerFrame
	ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 1, -ChatResizerFrame.AbsoluteSize.Y)
end

function methods:FadeOutBackground(duration)
	self.ChannelsBar:FadeOutBackground(duration)
	self.MessageLogDisplay:FadeOutBackground(duration)
	self.ChatBar:FadeOutBackground(duration)

	self.AnimParams.Background_TargetTransparency = 1
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeInBackground(duration)
	self.ChannelsBar:FadeInBackground(duration)
	self.MessageLogDisplay:FadeInBackground(duration)
	self.ChatBar:FadeInBackground(duration)

	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeOutText(duration)
	self.MessageLogDisplay:FadeOutText(duration)
	self.ChannelsBar:FadeOutText(duration)
end

function methods:FadeInText(duration)
	self.MessageLogDisplay:FadeInText(duration)
	self.ChannelsBar:FadeInText(duration)
end

function methods:AnimGuiObjects()
	self.GuiObjects.ChatChannelParentFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
	self.GuiObjects.ChatResizerFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
	self.GuiObjects.ResizeIcon.ImageTransparency = self.AnimParams.Background_CurrentTransparency
end

function methods:InitializeAnimParams()
	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_CurrentTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
end

function methods:Update(dtScale)
	self.ChatBar:Update(dtScale)
	self.ChannelsBar:Update(dtScale)
	self.MessageLogDisplay:Update(dtScale)

	self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
			self.AnimParams.Background_CurrentTransparency,
			self.AnimParams.Background_TargetTransparency,
			self.AnimParams.Background_NormalizedExptValue,
			dtScale
	)

	self:AnimGuiObjects()
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ChatWindow", methods)

function module.new()
	local obj = {}

	obj.GuiObject = nil
	obj.GuiObjects = {}

	obj.ChatBar = nil
	obj.ChannelsBar = nil
	obj.MessageLogDisplay = nil

	obj.Channels = {}
	obj.CurrentChannel = nil

	obj.Visible = true
	obj.CoreGuiEnabled = true

	obj.AnimParams = {}

	ClassMaker.MakeClass("ChatWindow", obj)

	obj:InitializeAnimParams()

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3C2FC9ED63A14ED1A10E5594CF91D521">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MessageLogDisplay</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: MessageLogDisplay.lua
--	// Written by: Xsitsu, TheGamer101
--	// Description: ChatChannel window for displaying messages.

local module = {}
module.ScrollBarThickness = 4

--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local modulesFolder = script.Parent
local moduleMessageLabelCreator = require(modulesFolder:WaitForChild("MessageLabelCreator"))
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))

local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))

local MessageLabelCreator = moduleMessageLabelCreator.new()

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

local function CreateGuiObjects()
	local BaseFrame = Instance.new("Frame")
	BaseFrame.Selectable = false
	BaseFrame.Size = UDim2.new(1, 0, 1, 0)
	BaseFrame.BackgroundTransparency = 1

	local Scroller = Instance.new("ScrollingFrame")
	Scroller.Selectable = ChatSettings.GamepadNavigationEnabled
	Scroller.Name = "Scroller"
	Scroller.BackgroundTransparency = 1
	Scroller.BorderSizePixel = 0
	Scroller.Position = UDim2.new(0, 0, 0, 3)
	Scroller.Size = UDim2.new(1, -4, 1, -6)
	Scroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	Scroller.ScrollBarThickness = module.ScrollBarThickness
	Scroller.Active = false
	Scroller.Parent = BaseFrame

	return BaseFrame, Scroller
end

function methods:Destroy()
	self.GuiObject:Destroy()
	self.Destroyed = true
end

function methods:SetActive(active)
	self.GuiObject.Visible = active
end

function methods:UpdateMessageFiltered(messageData)
	local messageObject = nil
	local searchIndex = 1
	local searchTable = self.MessageObjectLog

	while (#searchTable >= searchIndex) do
		local obj = searchTable[searchIndex]

		if (obj.ID == messageData.ID) then
			messageObject = obj
			break
		end

		searchIndex = searchIndex + 1
	end

	if (messageObject) then
		messageObject.UpdateTextFunction(messageData)
		self:ReorderAllMessages()
	end
end

function methods:AddMessage(messageData)
	self:WaitUntilParentedCorrectly()

	local messageObject = MessageLabelCreator:CreateMessageLabel(messageData, self.CurrentChannelName)
	if messageObject == nil then
		return
	end

	table.insert(self.MessageObjectLog, messageObject)
	self:PositionMessageLabelInWindow(messageObject)
end

function methods:RemoveLastMessage()
	self:WaitUntilParentedCorrectly()

	local lastMessage = self.MessageObjectLog[1]
	local posOffset = UDim2.new(0, 0, 0, lastMessage.BaseFrame.AbsoluteSize.Y)

	lastMessage:Destroy()
	table.remove(self.MessageObjectLog, 1)

	for i, messageObject in pairs(self.MessageObjectLog) do
		messageObject.BaseFrame.Position = messageObject.BaseFrame.Position - posOffset
	end

	self.Scroller.CanvasSize = self.Scroller.CanvasSize - posOffset
end

function methods:IsScrolledDown()
	local yCanvasSize = self.Scroller.CanvasSize.Y.Offset
	local yContainerSize = self.Scroller.AbsoluteWindowSize.Y
	local yScrolledPosition = self.Scroller.CanvasPosition.Y

	return (yCanvasSize < yContainerSize or
					yCanvasSize - yScrolledPosition <= yContainerSize + 5)
end

function methods:PositionMessageLabelInWindow(messageObject)
	self:WaitUntilParentedCorrectly()

	local baseFrame = messageObject.BaseFrame

	baseFrame.Parent = self.Scroller
	baseFrame.Position = UDim2.new(0, 0, 0, self.Scroller.CanvasSize.Y.Offset)

	baseFrame.Size = UDim2.new(1, 0, 0, messageObject.GetHeightFunction(self.Scroller.AbsoluteSize.X))

	if messageObject.BaseMessage then
		local trySize = self.Scroller.AbsoluteSize.X
		while not messageObject.BaseMessage.TextFits do
			trySize = trySize - 1
			baseFrame.Size = UDim2.new(1, 0, 0, messageObject.GetHeightFunction(trySize))
		end
	end

	local isScrolledDown = self:IsScrolledDown()

	local add = UDim2.new(0, 0, 0, baseFrame.Size.Y.Offset)
	self.Scroller.CanvasSize = self.Scroller.CanvasSize + add

	if isScrolledDown then
		self.Scroller.CanvasPosition = Vector2.new(0, math.max(0, self.Scroller.CanvasSize.Y.Offset - self.Scroller.AbsoluteSize.Y))
	end
end

function methods:ReorderAllMessages()
	self:WaitUntilParentedCorrectly()

	--// Reordering / reparenting with a size less than 1 causes weird glitches to happen with scrolling as repositioning happens.
	if (self.GuiObject.AbsoluteSize.Y < 1) then return end

	local oldCanvasPositon = self.Scroller.CanvasPosition
	local wasScrolledDown = self:IsScrolledDown()

	self.Scroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	for i, messageObject in pairs(self.MessageObjectLog) do
		self:PositionMessageLabelInWindow(messageObject)
	end

	if not wasScrolledDown then
		self.Scroller.CanvasPosition = oldCanvasPositon
	end
end

function methods:Clear()
	for i, v in pairs(self.MessageObjectLog) do
		v:Destroy()
	end
	rawset(self, "MessageObjectLog", {})

	self.Scroller.CanvasSize = UDim2.new(0, 0, 0, 0)
end

function methods:SetCurrentChannelName(name)
	self.CurrentChannelName = name
end

function methods:FadeOutBackground(duration)
	--// Do nothing
end

function methods:FadeInBackground(duration)
	--// Do nothing
end

function methods:FadeOutText(duration)
	for i = 1, #self.MessageObjectLog do
		if self.MessageObjectLog[i].FadeOutFunction then
			self.MessageObjectLog[i].FadeOutFunction(duration, CurveUtil)
		end
	end
end

function methods:FadeInText(duration)
	for i = 1, #self.MessageObjectLog do
		if self.MessageObjectLog[i].FadeInFunction then
			self.MessageObjectLog[i].FadeInFunction(duration, CurveUtil)
		end
	end
end

function methods:Update(dtScale)
	for i = 1, #self.MessageObjectLog do
		if self.MessageObjectLog[i].UpdateAnimFunction then
			self.MessageObjectLog[i].UpdateAnimFunction(dtScale, CurveUtil)
		end
	end
end

--// ToDo: Move to common modules
function methods:WaitUntilParentedCorrectly()
	while (not self.GuiObject:IsDescendantOf(game:GetService("Players").LocalPlayer)) do
		self.GuiObject.AncestryChanged:wait()
	end
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("MessageLogDisplay", methods)

function module.new()
	local obj = {}
	obj.Destroyed = false

	local BaseFrame, Scroller = CreateGuiObjects()
	obj.GuiObject = BaseFrame
	obj.Scroller = Scroller

	obj.MessageObjectLog = {}

	obj.Name = "MessageLogDisplay"
	obj.GuiObject.Name = "Frame_" .. obj.Name

	obj.CurrentChannelName = ""

	ClassMaker.MakeClass("MessageLogDisplay", obj)

	obj.GuiObject.Changed:connect(function(prop)
		if (prop == "AbsoluteSize") then
			spawn(function() obj:ReorderAllMessages() end)
		end
	end)

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX73BA45B88681488AA67CA895AF19D0CF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatChannel</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatChannel.lua
--	// Written by: Xsitsu
--	// Description: ChatChannel class for handling messages being added and removed from the chat channel.

local module = {}
--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local modulesFolder = script.Parent
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))

local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function methods:Destroy()
	self.Destroyed = true
end

function methods:SetActive(active)
	if active == self.Active then
		return
	end
	if active == false then
		self.MessageLogDisplay:Clear()
	else
		self.MessageLogDisplay:SetCurrentChannelName(self.Name)
		for i = 1, #self.MessageLog do
			self.MessageLogDisplay:AddMessage(self.MessageLog[i])
		end
	end
	self.Active = active
end

function methods:UpdateMessageFiltered(messageData)
	local searchIndex = 1
	local searchTable = self.MessageLog
	local messageObj = nil
	while (#searchTable >= searchIndex) do
		local obj = searchTable[searchIndex]

		if (obj.ID == messageData.ID) then
			messageObj = obj
			break
		end

		searchIndex = searchIndex + 1
	end

	if messageObj then
		messageObj.Message = messageData.Message
		messageObj.IsFiltered = true
		if self.Active then
			self.MessageLogDisplay:UpdateMessageFiltered(messageObj)
		end
	end
end

function methods:AddMessageToChannel(messageData)
	table.insert(self.MessageLog, messageData)
	if self.Active then
		self.MessageLogDisplay:AddMessage(messageData)
	end
	if #self.MessageLog > ChatSettings.MessageHistoryLengthPerChannel then
		self:RemoveLastMessageFromChannel()
	end
end

function methods:RemoveLastMessageFromChannel()
	table.remove(self.MessageLog, 1)

	if self.Active then
		self.MessageLogDisplay:RemoveLastMessage()
	end
end

function methods:ClearMessageLog()
	rawset(self, "MessageLog", {})

	if self.Active then
		self.MessageLogDisplay:Clear()
	end
end

function methods:RegisterChannelTab(tab)
	rawset(self, "ChannelTab", tab)
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ChatChannel", methods)

function module.new(channelName, messageLogDisplay)
	local obj = {}
	obj.Destroyed = false
	obj.Active = false

	obj.MessageLog = {}
	obj.MessageLogDisplay = messageLogDisplay
	obj.ChannelTab = nil
	obj.Name = channelName

	ClassMaker.MakeClass("ChatChannel", obj)

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5A883C77E7494D96894C7A9AA71B06FB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MessageLabelCreator</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: MessageLabelCreator.lua
--	// Written by: Xsitsu
--	// Description: Module to handle taking text and creating stylized GUI objects for display in ChatWindow.

local OBJECT_POOL_SIZE = 50

local module = {}
--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local messageCreatorModules = clientChatModules:WaitForChild("MessageCreatorModules")
local messageCreatorUtil = require(messageCreatorModules:WaitForChild("Util"))
local modulesFolder = script.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local moduleObjectPool = require(modulesFolder:WaitForChild("ObjectPool"))
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function ReturnToObjectPoolRecursive(instance, objectPool)
	local children = instance:GetChildren()
	for i = 1, #children do
		ReturnToObjectPoolRecursive(children[i], objectPool)
	end
	instance.Parent = nil
	objectPool:ReturnInstance(instance)
end

function GetMessageCreators()
	local typeToFunction = {}
	local creators = messageCreatorModules:GetChildren()
	for i = 1, #creators do
		if creators[i].Name ~= "Util" then
			local creator = require(creators[i])
			typeToFunction[creator[messageCreatorUtil.KEY_MESSAGE_TYPE]] = creator[messageCreatorUtil.KEY_CREATOR_FUNCTION]
		end
	end
	return typeToFunction
end

function methods:WrapIntoMessageObject(messageData, createdMessageObject)
	local BaseFrame = createdMessageObject[messageCreatorUtil.KEY_BASE_FRAME]
	local BaseMessage = nil
	if messageCreatorUtil.KEY_BASE_MESSAGE then
		BaseMessage = createdMessageObject[messageCreatorUtil.KEY_BASE_MESSAGE]
	end
	local UpdateTextFunction = createdMessageObject[messageCreatorUtil.KEY_UPDATE_TEXT_FUNC]
	local GetHeightFunction = createdMessageObject[messageCreatorUtil.KEY_GET_HEIGHT]
	local FadeInFunction = createdMessageObject[messageCreatorUtil.KEY_FADE_IN]
	local FadeOutFunction = createdMessageObject[messageCreatorUtil.KEY_FADE_OUT]
	local UpdateAnimFunction = createdMessageObject[messageCreatorUtil.KEY_UPDATE_ANIMATION]

	local obj = {}

	obj.ID = messageData.ID
	obj.BaseFrame = BaseFrame
	obj.BaseMessage = BaseMessage
	obj.UpdateTextFunction = UpdateTextFunction or function() warn("NO MESSAGE RESIZE FUNCTION") end
	obj.GetHeightFunction = GetHeightFunction
	obj.FadeInFunction = FadeInFunction
	obj.FadeOutFunction = FadeOutFunction
	obj.UpdateAnimFunction = UpdateAnimFunction
	obj.ObjectPool = self.ObjectPool
	obj.Destroyed = false

	function obj:Destroy()
		ReturnToObjectPoolRecursive(self.BaseFrame, self.ObjectPool)
		self.Destroyed = true
	end

	return obj
end

function methods:CreateMessageLabel(messageData, currentChannelName)
	local messageType = messageData.MessageType
	if self.MessageCreators[messageType] then
		local createdMessageObject = self.MessageCreators[messageType](messageData, currentChannelName)
		if createdMessageObject then
			return self:WrapIntoMessageObject(messageData, createdMessageObject)
		end
	elseif self.DefaultCreatorType then
		local createdMessageObject = self.MessageCreators[self.DefaultCreatorType](messageData, currentChannelName)
		if createdMessageObject then
			return self:WrapIntoMessageObject(messageData, createdMessageObject)
		end
	else
		error("No message creator available for message type: " ..messageType)
	end
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("MessageLabelCreator", methods)

function module.new()
	local obj = {}

	obj.ObjectPool = moduleObjectPool.new(OBJECT_POOL_SIZE)
	obj.MessageCreators = GetMessageCreators()
	obj.DefaultCreatorType = messageCreatorUtil.DEFAULT_MESSAGE_CREATOR

	ClassMaker.MakeClass("MessageLabelCreator", obj)

	messageCreatorUtil:RegisterObjectPool(obj.ObjectPool)

	return obj
end

function module:RegisterGuiRoot(root)
	messageCreatorUtil:RegisterGuiRoot(root)
end

function module:GetStringTextBounds(text, font, textSize, sizeBounds)
	return messageCreatorUtil:GetStringTextBounds(text, font, textSize, sizeBounds)
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC02A468513994C88896CC21593FFEEA9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatWindowInstaller</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local runnerScriptName = "ChatScript"
local installDirectory = game:GetService("Chat")
local StarterPlayerScripts = game:GetService("StarterPlayer"):WaitForChild("StarterPlayerScripts")

local function LoadLocalScript(name, parent)
	local originalModule = script.Parent:WaitForChild(name)
	local script = Instance.new("LocalScript")
	script.Name = name
	script.Source = originalModule.Source
	script.Parent = parent
	return script
end

local function LoadModule(location, name, parent)
	local originalModule = location:WaitForChild(name)
	local module = Instance.new("ModuleScript")
	module.Name = name
	module.Source = originalModule.Source
	module.Parent = parent
	return module
end

local function Install()
	local chatScriptArchivable = true
	local ChatScript = installDirectory:FindFirstChild(runnerScriptName)
	if not ChatScript then
		chatScriptArchivable = false
		ChatScript = LoadLocalScript(runnerScriptName, installDirectory)
		local ChatMain = LoadModule(script.Parent, "ChatMain", ChatScript)

		LoadModule(script.Parent, "ChannelsBar", ChatMain)
		LoadModule(script.Parent, "ChatBar", ChatMain)
		LoadModule(script.Parent, "ChatChannel", ChatMain)
		LoadModule(script.Parent, "MessageLogDisplay", ChatMain)
		LoadModule(script.Parent, "ChatWindow", ChatMain)
		LoadModule(script.Parent, "MessageLabelCreator", ChatMain)
		LoadModule(script.Parent, "CommandProcessor", ChatMain)
		LoadModule(script.Parent, "ChannelsTab", ChatMain)
		LoadModule(script.Parent.Parent.Parent.Common, "ClassMaker", ChatMain)
		LoadModule(script.Parent.Parent.Parent.Common, "ObjectPool", ChatMain)
		LoadModule(script.Parent, "MessageSender", ChatMain)
		LoadModule(script.Parent, "CurveUtil", ChatMain)
	end

	local clientChatModules = installDirectory:FindFirstChild("ClientChatModules")
	if not clientChatModules then
		clientChatModules = Instance.new("Folder")
		clientChatModules.Name = "ClientChatModules"
		clientChatModules.Archivable = false

		clientChatModules.Parent = installDirectory
	end

	local chatSettings = clientChatModules:FindFirstChild("ChatSettings")
	if not chatSettings then
		LoadModule(script.Parent.DefaultClientChatModules, "ChatSettings", clientChatModules)
	end

	local chatConstants = clientChatModules:FindFirstChild("ChatConstants")
	if not chatConstants then
		LoadModule(script.Parent.DefaultClientChatModules, "ChatConstants", clientChatModules)
	end

	local MessageCreatorModules = clientChatModules:FindFirstChild("MessageCreatorModules")
	if not MessageCreatorModules then
		MessageCreatorModules = Instance.new("Folder")
		MessageCreatorModules.Name = "MessageCreatorModules"
		MessageCreatorModules.Archivable = false

		local creatorModules = script.Parent.DefaultClientChatModules.MessageCreatorModules:GetChildren()

		for i = 1, #creatorModules do
			LoadModule(script.Parent.DefaultClientChatModules.MessageCreatorModules, creatorModules[i].Name, MessageCreatorModules)
		end

		MessageCreatorModules.Parent = clientChatModules
	end

	local CommandModules = clientChatModules:FindFirstChild("CommandModules")
	if not CommandModules then
		CommandModules = Instance.new("Folder")
		CommandModules.Name = "CommandModules"
		CommandModules.Archivable = false

		local commandModules = script.Parent.DefaultClientChatModules.CommandModules:GetChildren()

		for i = 1, #commandModules do
			LoadModule(script.Parent.DefaultClientChatModules.CommandModules, commandModules[i].Name, CommandModules)
		end

		CommandModules.Parent = clientChatModules
	end

	if not StarterPlayerScripts:FindFirstChild(runnerScriptName) then
		local ChatScriptCopy = ChatScript:Clone()
		ChatScriptCopy.Parent = StarterPlayerScripts
		ChatScriptCopy.Archivable = false

		local currentPlayers = game:GetService("Players"):GetChildren()
		for i, player in pairs(currentPlayers) do
			if (player:IsA("Player") and player:FindFirstChild("PlayerScripts") and not player.PlayerScripts:FindFirstChild(runnerScriptName)) then
				ChatScript:Clone().Parent = player.PlayerScripts
				ChatScript.Archivable = false
			end
		end
	end

	ChatScript.Archivable = chatScriptArchivable
end

return Install
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC9513CBBC72E4F299C3119336E0F5461">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CommandProcessor</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ProcessCommands.lua
--	// Written by: TheGamer101
--	// Description: Module for processing commands using the client CommandModules

local module = {}
local methods = {}

--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local commandModules = clientChatModules:WaitForChild("CommandModules")
local commandUtil = require(commandModules:WaitForChild("Util"))
local modulesFolder = script.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))

function methods:SetupCommandProcessors()
	local commands = commandModules:GetChildren()
	for i = 1, #commands do
		if commands[i].Name ~= "Util" then
			local commandProcessor = require(commands[i])
			local processorType = commandProcessor[commandUtil.KEY_COMMAND_PROCESSOR_TYPE]
			local processorFunction = commandProcessor[commandUtil.KEY_PROCESSOR_FUNCTION]
			if processorType == commandUtil.IN_PROGRESS_MESSAGE_PROCESSOR then
				table.insert(self.InProgressMessageProcessors, processorFunction)
			elseif processorType == commandUtil.COMPLETED_MESSAGE_PROCESSOR then
				table.insert(self.CompletedMessageProcessors, processorFunction)
			end
		end
	end
end

function methods:ProcessCompletedChatMessage(message, ChatWindow)
	for i = 1, #self.CompletedMessageProcessors do
		local processedCommand = self.CompletedMessageProcessors[i](message, ChatWindow, ChatSettings)
		if processedCommand then
			return true
		end
	end
	return false
end

function methods:ProcessInProgressChatMessage(message, ChatWindow, ChatBar)
	for i = 1, #self.InProgressMessageProcessors do
		local customState = self.InProgressMessageProcessors[i](message, ChatWindow, ChatBar, ChatSettings)
		if customState then
			return customState
		end
	end
	return nil
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("CommandProcessor", methods)

function module.new()
	local obj = {}

	obj.CompletedMessageProcessors = {}
	obj.InProgressMessageProcessors = {}

	ClassMaker.MakeClass("CommandProcessor", obj)

	obj:SetupCommandProcessors()

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX65957ACAC3F8458AA2FF8F0149FFFA3B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatScript</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatScript.lua
--	// Written by: Xsitsu
--	// Description: Hooks main chat module up to Topbar in corescripts.

local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local MAX_COREGUI_CONNECTION_ATTEMPTS = 10

local function DoEverything()
	local Chat = require(script:WaitForChild("ChatMain"))

	local containerTable = {}
	containerTable.ChatWindow = {}
	containerTable.SetCore = {}
	containerTable.GetCore = {}


	--// Connection functions
	local function ConnectEvent(name)
		local event = Instance.new("BindableEvent")
		event.Name = name
		containerTable.ChatWindow[name] = event

		event.Event:connect(function(...) Chat[name](Chat, ...) end)
	end

	local function ConnectFunction(name)
		local func = Instance.new("BindableFunction")
		func.Name = name
		containerTable.ChatWindow[name] = func

		func.OnInvoke = function(...) return Chat[name](Chat, ...) end
	end

	local function ReverseConnectEvent(name)
		local event = Instance.new("BindableEvent")
		event.Name = name
		containerTable.ChatWindow[name] = event

		Chat[name]:connect(function(...) event:Fire(...) end)
	end

	local function ConnectSignal(name)
		local event = Instance.new("BindableEvent")
		event.Name = name
		containerTable.ChatWindow[name] = event

		event.Event:connect(function(...) Chat[name]:fire(...) end)
	end

	local function ConnectSetCore(name)
		local event = Instance.new("BindableEvent")
		event.Name = name
		containerTable.SetCore[name] = event

		event.Event:connect(function(...) Chat[name.."Event"]:fire(...) end)
	end

	local function ConnectGetCore(name)
		local func = Instance.new("BindableFunction")
		func.Name = name
		containerTable.GetCore[name] = func

		func.OnInvoke = function(...) return Chat["f"..name](...) end
	end

	--// Do connections
	ConnectEvent("ToggleVisibility")
	ConnectEvent("SetVisible")
	ConnectEvent("FocusChatBar")
	ConnectFunction("GetVisibility")
	ConnectFunction("GetMessageCount")
	ConnectEvent("TopbarEnabledChanged")
	ConnectFunction("IsFocused")

	ReverseConnectEvent("ChatBarFocusChanged")
	ReverseConnectEvent("VisibilityStateChanged")
	ReverseConnectEvent("MessagesChanged")
	ReverseConnectEvent("MessagePosted")

	ConnectSignal("CoreGuiEnabled")

	ConnectSetCore("ChatMakeSystemMessage")
	ConnectSetCore("ChatWindowPosition")
	ConnectSetCore("ChatWindowSize")
	ConnectGetCore("ChatWindowPosition")
	ConnectGetCore("ChatWindowSize")
	ConnectSetCore("ChatBarDisabled")
	ConnectGetCore("ChatBarDisabled")

	ConnectEvent("SpecialKeyPressed")

	local tries = 0
	while tries < MAX_COREGUI_CONNECTION_ATTEMPTS do
		tries = tries + 1
		local success, ret = pcall(function() StarterGui:SetCore("CoreGuiChatConnections", containerTable) end)
		if success then
			break
		end
		if not success and tries == MAX_COREGUI_CONNECTION_ATTEMPTS then
			error("Error calling SetCore CoreGuiChatConnections: " .. ret)
		end
		wait()
	end
end

if not GuiService:IsTenFootInterface() then
	DoEverything()
end
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD402AB836DD548A09C8DFDB14CBB2C1D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatMain</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatMain.lua
--	// Written by: Xsitsu
--	// Description: Main module to handle initializing chat window UI and hooking up events to individual UI pieces.

local moduleApiTable = {}

--// This section of code waits until all of the necessary RemoteEvents are found in EventFolder.
--// I have to do some weird stuff since people could potentially already have pre-existing
--// things in a folder with the same name, and they may have different class types.
--// I do the useEvents thing and set EventFolder to useEvents so I can have a pseudo folder that
--// the rest of the code can interface with and have the guarantee that the RemoteEvents they want
--// exist with their desired names.

local FILTER_MESSAGE_TIMEOUT = 60

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Chat = game:GetService("Chat")

local EventFolder = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
local messageCreatorModules = clientChatModules:WaitForChild("MessageCreatorModules")
local MessageCreatorUtil = require(messageCreatorModules:WaitForChild("Util"))

local numChildrenRemaining = 10 -- #waitChildren returns 0 because it's a dictionary
local waitChildren =
{
	OnNewMessage = "RemoteEvent",
	OnMessageDoneFiltering = "RemoteEvent",
	OnNewSystemMessage = "RemoteEvent",
	OnChannelJoined = "RemoteEvent",
	OnChannelLeft = "RemoteEvent",
	OnMuted = "RemoteEvent",
	OnUnmuted = "RemoteEvent",
	OnMainChannelSet = "RemoteEvent",

	SayMessageRequest = "RemoteEvent",
	GetInitDataRequest = "RemoteFunction",
}

local useEvents = {}

local FoundAllEventsEvent = Instance.new("BindableEvent")

function TryRemoveChildWithVerifyingIsCorrectType(child)
	if (waitChildren[child.Name] and child:IsA(waitChildren[child.Name])) then
		waitChildren[child.Name] = nil
		useEvents[child.Name] = child
		numChildrenRemaining = numChildrenRemaining - 1
	end
end

for i, child in pairs(EventFolder:GetChildren()) do
	TryRemoveChildWithVerifyingIsCorrectType(child)
end

if (numChildrenRemaining > 0) then
	local con = EventFolder.ChildAdded:connect(function(child)
		TryRemoveChildWithVerifyingIsCorrectType(child)
		if (numChildrenRemaining < 1) then
			FoundAllEventsEvent:Fire()
		end
	end)

	FoundAllEventsEvent.Event:wait()
	con:disconnect()

	FoundAllEventsEvent:Destroy()
end

EventFolder = useEvents



--// Rest of code after waiting for correct events.

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

while not LocalPlayer do
	Players.ChildAdded:wait()
	LocalPlayer = Players.LocalPlayer
end

local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local GuiParent = Instance.new("ScreenGui", PlayerGui)
GuiParent.Name = "Chat"

local DidFirstChannelsLoads = false

local modulesFolder = script

local moduleChatWindow = require(modulesFolder:WaitForChild("ChatWindow"))
local moduleChatBar = require(modulesFolder:WaitForChild("ChatBar"))
local moduleChannelsBar = require(modulesFolder:WaitForChild("ChannelsBar"))
local moduleMessageLabelCreator = require(modulesFolder:WaitForChild("MessageLabelCreator"))
local moduleMessageLogDisplay = require(modulesFolder:WaitForChild("MessageLogDisplay"))
local moduleChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
local moduleCommandProcessor = require(modulesFolder:WaitForChild("CommandProcessor"))

moduleMessageLabelCreator:RegisterGuiRoot(GuiParent)

local ChatWindow = moduleChatWindow.new()
local ChannelsBar = moduleChannelsBar.new()
local MessageLogDisplay = moduleMessageLogDisplay.new()
local CommandProcessor = moduleCommandProcessor.new()
local ChatBar = moduleChatBar.new(CommandProcessor, ChatWindow)

ChatWindow:CreateGuiObjects(GuiParent)

ChatWindow:RegisterChatBar(ChatBar)
ChatWindow:RegisterChannelsBar(ChannelsBar)
ChatWindow:RegisterMessageLogDisplay(MessageLogDisplay)

MessageCreatorUtil:RegisterChatWindow(ChatWindow)

local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))

local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
MessageSender:RegisterSayMessageFunction(EventFolder.SayMessageRequest)



if (UserInputService.TouchEnabled) then
	ChatBar:SetTextLabelText('Tap here to chat')
else
	ChatBar:SetTextLabelText('To chat click here or press "/" key')
end

spawn(function()
	local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
	local ANIMATION_FPS = 20.0

	local updateWaitTime = 1.0 / ANIMATION_FPS
	local lastTick = tick()
	while true do
		local currentTick = tick()
		local tickDelta = currentTick - lastTick
		local dtScale = CurveUtil:DeltaTimeToTimescale(tickDelta)

		ChatWindow:Update(dtScale)

		lastTick = currentTick
		wait(updateWaitTime)
	end
end)




--////////////////////////////////////////////////////////////////////////////////////////////
--////////////////////////////////////////////////////////////// Code to do chat window fading
--////////////////////////////////////////////////////////////////////////////////////////////
function CheckIfPointIsInSquare(checkPos, topLeft, bottomRight)
	return (topLeft.X <= checkPos.X and checkPos.X <= bottomRight.X and
		topLeft.Y <= checkPos.Y and checkPos.Y <= bottomRight.Y)
end

local backgroundIsFaded = false
local textIsFaded = false
local lastTextFadeTime = 0
local lastBackgroundFadeTime = 0

local fadedChanged = Instance.new("BindableEvent")
local mouseStateChanged = Instance.new("BindableEvent")
local chatBarFocusChanged = Instance.new("BindableEvent")

function DoBackgroundFadeIn(setFadingTime)
	lastBackgroundFadeTime = tick()
	backgroundIsFaded = false
	fadedChanged:Fire()
	ChatWindow:EnableResizable()
	ChatWindow:FadeInBackground((setFadingTime or ChatSettings.ChatDefaultFadeDuration))

	local currentChannelObject = ChatWindow:GetCurrentChannel()
	if (currentChannelObject) then
		ChatWindow.GuiObject.Active = true

		local Scroller = MessageLogDisplay.Scroller
		Scroller.ScrollingEnabled = true
		Scroller.ScrollBarThickness = moduleMessageLogDisplay.ScrollBarThickness
	end
end

function DoBackgroundFadeOut(setFadingTime)
	lastBackgroundFadeTime = tick()
	backgroundIsFaded = true
	fadedChanged:Fire()
	ChatWindow:DisableResizable()
	ChatWindow:FadeOutBackground((setFadingTime or ChatSettings.ChatDefaultFadeDuration))

	local currentChannelObject = ChatWindow:GetCurrentChannel()
	if (currentChannelObject) then
		ChatWindow.GuiObject.Active = false
		--ChatWindow:ResetResizerPosition()

		local Scroller = MessageLogDisplay.Scroller
		Scroller.ScrollingEnabled = false
		Scroller.ScrollBarThickness = 0
	end
end

function DoTextFadeIn(setFadingTime)
	lastTextFadeTime = tick()
	textIsFaded = false
	fadedChanged:Fire()
	ChatWindow:FadeInText((setFadingTime or ChatSettings.ChatDefaultFadeDuration) * 0)
end

function DoTextFadeOut(setFadingTime)
	lastTextFadeTime = tick()
	textIsFaded = true
	fadedChanged:Fire()
	ChatWindow:FadeOutText((setFadingTime or ChatSettings.ChatDefaultFadeDuration))
end

function DoFadeInFromNewInformation()
	DoTextFadeIn()
	if ChatSettings.ChatShouldFadeInFromNewInformation then
		DoBackgroundFadeIn()
	end
end

function InstantFadeIn()
	DoBackgroundFadeIn(0)
	DoTextFadeIn(0)
end

function InstantFadeOut()
	DoBackgroundFadeOut(0)
	DoTextFadeOut(0)
end

function DealWithCoreGuiEnabledChanged(enabled)
	if (moduleApiTable.Visible) then
		if (enabled) then
			InstantFadeIn()
		else
			InstantFadeOut()
		end
	end
end

local mouseIsInWindow = nil
function UpdateFadingForMouseState(mouseState)
	mouseIsInWindow = mouseState

	mouseStateChanged:Fire()

	if (ChatBar:IsFocused()) then return end

	if (mouseState) then
		DoBackgroundFadeIn()
		DoTextFadeIn()
	else
		DoBackgroundFadeIn()
	end
end


spawn(function()
	while true do
		RunService.RenderStepped:wait()

		while (mouseIsInWindow or ChatBar:IsFocused()) do
			if (mouseIsInWindow) then
				mouseStateChanged.Event:wait()
			end
			if (ChatBar:IsFocused()) then
				chatBarFocusChanged.Event:wait()
			end
		end

		if (not backgroundIsFaded) then
			local timeDiff = tick() - lastBackgroundFadeTime
			if (timeDiff > ChatSettings.ChatWindowBackgroundFadeOutTime) then
				DoBackgroundFadeOut()
			end

		elseif (not textIsFaded) then
			local timeDiff = tick() - lastTextFadeTime
			if (timeDiff > ChatSettings.ChatWindowTextFadeOutTime) then
				DoTextFadeOut()
			end

		else
			fadedChanged.Event:wait()

		end

	end
end)

function bubbleChatOnly()
 	return not Players.ClassicChat and Players.BubbleChat
end

function UpdateMousePosition(mousePos)
	if not (moduleApiTable.Visible and moduleApiTable.IsCoreGuiEnabled and (moduleApiTable.TopbarEnabled or ChatSettings.ChatOnWithTopBarOff)) then return end

	if bubbleChatOnly() then
		return
	end

	local windowPos = ChatWindow.GuiObject.AbsolutePosition
	local windowSize = ChatWindow.GuiObject.AbsoluteSize

	local newMouseState = CheckIfPointIsInSquare(mousePos, windowPos, windowPos + windowSize)
	if (newMouseState ~= mouseIsInWindow) then
		UpdateFadingForMouseState(newMouseState)
	end
end

UserInputService.InputChanged:connect(function(inputObject)
	if (inputObject.UserInputType == Enum.UserInputType.MouseMovement) then
		local mousePos = Vector2.new(inputObject.Position.X, inputObject.Position.Y)
		UpdateMousePosition(mousePos)
	end
end)

UserInputService.TouchTap:connect(function(tapPos, gameProcessedEvent)
	local last = mouseIsInWindow

	UpdateMousePosition(tapPos[1])
	if (not mouseIsInWindow and last ~= mouseIsInWindow) then
		DoBackgroundFadeOut()
	end
end)

--// Start and stop fading sequences / timers
UpdateFadingForMouseState(true)
UpdateFadingForMouseState(false)


--////////////////////////////////////////////////////////////////////////////////////////////
--///////////// Code to talk to topbar and maintain set/get core backwards compatibility stuff
--////////////////////////////////////////////////////////////////////////////////////////////
local Util = {}
do
	function Util.Signal()
		local sig = {}

		local mSignaler = Instance.new('BindableEvent')

		local mArgData = nil
		local mArgDataCount = nil

		function sig:fire(...)
			mArgData = {...}
			mArgDataCount = select('#', ...)
			mSignaler:Fire()
		end

		function sig:connect(f)
			if not f then error("connect(nil)", 2) end
			return mSignaler.Event:connect(function()
				f(unpack(mArgData, 1, mArgDataCount))
			end)
		end

		function sig:wait()
			mSignaler.Event:wait()
			assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
			return unpack(mArgData, 1, mArgDataCount)
		end

		return sig
	end
end


function SetVisibility(val)
	ChatWindow:SetVisible(val)
	moduleApiTable.VisibilityStateChanged:fire(val)
	moduleApiTable.Visible = val

	if (moduleApiTable.IsCoreGuiEnabled) then
		if (val) then
			InstantFadeIn()
		else
			InstantFadeOut()
		end
	end
end

do
	moduleApiTable.TopbarEnabled = true
	moduleApiTable.MessageCount = 0
	moduleApiTable.Visible = true
	moduleApiTable.IsCoreGuiEnabled = true

	function moduleApiTable:ToggleVisibility()
		SetVisibility(not ChatWindow:GetVisible())
	end

	function moduleApiTable:SetVisible(visible)
		if (ChatWindow:GetVisible() ~= visible) then
			SetVisibility(visible)
		end
	end

	function moduleApiTable:FocusChatBar()
		ChatBar:CaptureFocus()
	end

	function moduleApiTable:GetVisibility()
		return ChatWindow:GetVisible()
	end

	function moduleApiTable:GetMessageCount()
		return self.MessageCount
	end

	function moduleApiTable:TopbarEnabledChanged(enabled)
		self.TopbarEnabled = enabled
		self.CoreGuiEnabled:fire(game:GetService("StarterGui"):GetCoreGuiEnabled(Enum.CoreGuiType.Chat))
	end

	function moduleApiTable:IsFocused(useWasFocused)
		return ChatBar:IsFocused()
	end

	moduleApiTable.ChatBarFocusChanged = Util.Signal()
	moduleApiTable.VisibilityStateChanged = Util.Signal()
	moduleApiTable.MessagesChanged = Util.Signal()


	moduleApiTable.MessagePosted = Util.Signal()
	moduleApiTable.CoreGuiEnabled = Util.Signal()

	moduleApiTable.ChatMakeSystemMessageEvent = Util.Signal()
	moduleApiTable.ChatWindowPositionEvent = Util.Signal()
	moduleApiTable.ChatWindowSizeEvent = Util.Signal()
	moduleApiTable.ChatBarDisabledEvent = Util.Signal()


	function moduleApiTable:fChatWindowPosition()
		return ChatWindow.GuiObject.Position
	end

	function moduleApiTable:fChatWindowSize()
		return ChatWindow.GuiObject.Size
	end

	function moduleApiTable:fChatBarDisabled()
		return not ChatBar:GetEnabled()
	end



	function moduleApiTable:SpecialKeyPressed(key, modifiers)
		if (key == Enum.SpecialKey.ChatHotkey) then
			DoChatBarFocus()
		end
	end
end

spawn(function() moduleApiTable:SetVisible(false) moduleApiTable:SetVisible(true) end)

moduleApiTable.CoreGuiEnabled:connect(function(enabled)
	moduleApiTable.IsCoreGuiEnabled = enabled
	DealWithCoreGuiEnabledChanged(moduleApiTable.IsCoreGuiEnabled)

	enabled = enabled and (moduleApiTable.TopbarEnabled or ChatSettings.ChatOnWithTopBarOff)

	ChatWindow:SetCoreGuiEnabled(enabled)

	if (not enabled) then
		ChatBar:ReleaseFocus()
		InstantFadeOut()
	else
		InstantFadeIn()
	end
end)

moduleApiTable.ChatMakeSystemMessageEvent:connect(function(valueTable)
	if (valueTable["Text"] and type(valueTable["Text"]) == "string") then
		while (not DidFirstChannelsLoads) do wait() end

		local channel = ChatSettings.GeneralChannelName
		local channelObj = ChatWindow:GetChannel(channel)

		if (channelObj) then
			local messageObject = {
				ID = -1,
				FromSpeaker = nil,
				OriginalChannel = channel,
				IsFiltered = true,
				MessageLength = string.len(valueTable.Text),
				Message = valueTable.Text,
				MessageType = ChatConstants.MessageTypeSetCore,
				Time = os.time(),
				ExtraData = valueTable,
			}
			channelObj:AddMessageToChannel(messageObject)
			ChannelsBar:UpdateMessagePostedInChannel(channel)

			moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
			moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)
		end
	end
end)

moduleApiTable.ChatBarDisabledEvent:connect(function(disabled)
	ChatBar:SetEnabled(not disabled)
	if (disabled) then
		ChatBar:ReleaseFocus()
	end
end)


--////////////////////////////////////////////////////////////////////////////////////////////
--///////////////////////////////////////////////// Code to hook client UI up to server events
--////////////////////////////////////////////////////////////////////////////////////////////

function DoChatBarFocus()
	if (not ChatWindow:GetCoreGuiEnabled()) then return end
	if (not ChatBar:GetEnabled()) then return end

	if (not ChatBar:IsFocused() and ChatBar:GetVisible()) then
		moduleApiTable:SetVisible(true)
		ChatBar:CaptureFocus()
		moduleApiTable.ChatBarFocusChanged:fire(true)
	end
end

chatBarFocusChanged.Event:connect(function(focused)
	moduleApiTable.ChatBarFocusChanged:fire(focused)
end)

function DoSwitchCurrentChannel(targetChannel)
	if (ChatWindow:GetChannel(targetChannel)) then
		ChatWindow:SwitchCurrentChannel(targetChannel)
	end
end

function SendMessageToSelfInTargetChannel(message, channelName, extraData)
	local channelObj = ChatWindow:GetChannel(channelName)
	if (channelObj) then
		local messageData =
		{
			ID = -1,
			FromSpeaker = nil,
			OriginalChannel = channelName,
			IsFiltered = true,
			MessageLength = string.len(message),
			Message = message,
			MessageType = ChatConstants.MessageTypeSystem,
			Time = os.time(),
			ExtraData = extraData,
		}

		channelObj:AddMessageToChannel(messageData)
	end
end

function chatBarFocused()
	if (not mouseIsInWindow) then
		DoBackgroundFadeIn()
		if (textIsFaded) then
			DoTextFadeIn()
		end
	end

	chatBarFocusChanged:Fire(true)
end

--// Event for making player say chat message.
function chatBarFocusLost(enterPressed, inputObject)
	DoBackgroundFadeIn()
	chatBarFocusChanged:Fire(false)

	if (enterPressed) then
		local message = ChatBar:GetTextBox().Text

		if ChatBar:IsInCustomState() then
			local customMessage = ChatBar:GetCustomMessage()
			if customMessage then
				message = customMessage
			end
			local messageSunk = ChatBar:CustomStateProcessCompletedMessage(message)
			ChatBar:ResetCustomState()
			if messageSunk then
				return
			end
		end

		message = string.sub(message, 1, ChatSettings.MaximumMessageLength)

		ChatBar:GetTextBox().Text = ""

		if message ~= "" then
			--// Sends signal to eventually call Player:Chat() to handle C++ side legacy stuff.
			moduleApiTable.MessagePosted:fire(message)

			if not CommandProcessor:ProcessCompletedChatMessage(message, ChatWindow) then
				if ChatSettings.DisallowedWhiteSpace then
					for i = 1, #ChatSettings.DisallowedWhiteSpace do
						message = string.gsub(message, ChatSettings.DisallowedWhiteSpace[i], "")
					end
				end
				message = string.gsub(message, "\n", "")
				message = string.gsub(message, "[ ]+", " ")

				local targetChannel = ChatWindow:GetTargetMessageChannel()
				if targetChannel then
					MessageSender:SendMessage(message, targetChannel)
				else
					MessageSender:SendMessage(message, nil)
				end
			end
		end

	end
end

local ChatBarConnections = {}
function setupChatBarConnections()
	for i = 1, #ChatBarConnections do
		ChatBarConnections[i]:Disconnect()
	end
	ChatBarConnections = {}

	local focusLostConnection = ChatBar:GetTextBox().FocusLost:connect(chatBarFocusLost)
	table.insert(ChatBarConnections, focusLostConnection)

	local focusGainedConnection = ChatBar:GetTextBox().Focused:connect(chatBarFocused)
	table.insert(ChatBarConnections, focusGainedConnection)
end

setupChatBarConnections()
ChatBar.GuiObjectsChanged:connect(setupChatBarConnections)

-- Wrap the OnMessageDoneFiltering event so that we do not back up the remote event invocation queue.
-- This is in cases where we are sent OnMessageDoneFiltering events but we have stopped listening/timed out.
-- BindableEvents do not queue, while RemoteEvents do.
local FilteredMessageReceived = Instance.new("BindableEvent")
EventFolder.OnMessageDoneFiltering.OnClientEvent:connect(function(messageData)
	FilteredMessageReceived:Fire(messageData)
end)

EventFolder.OnNewMessage.OnClientEvent:connect(function(messageData, channelName)
	local channelObj = ChatWindow:GetChannel(channelName)
	if (channelObj) then
		channelObj:AddMessageToChannel(messageData)

		if (messageData.FromSpeaker ~= LocalPlayer.Name) then
			ChannelsBar:UpdateMessagePostedInChannel(channelName)
		end

		local generalChannel = nil
		if (ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName) then
			generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
			if (generalChannel) then
				generalChannel:AddMessageToChannel(messageData)
			end
		end

		moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
		moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)

		DoFadeInFromNewInformation()

		if messageData.IsFiltered and not (messageData.FromSpeaker == LocalPlayer.Name) then
			return
		end

		if not ChatSettings.ShowUserOwnFilteredMessage then
			if (messageData.FromSpeaker == LocalPlayer.Name) then
				return
			end
		end

		local filterData = {}
		local filterWaitStartTime = tick()
		while (filterData.ID ~= messageData.ID) do
			if tick() - filterWaitStartTime > FILTER_MESSAGE_TIMEOUT then
				return
			end
			filterData = FilteredMessageReceived.Event:wait()
		end

		--// Speaker may leave these channels during the time it takes to filter.
		if (not channelObj.Destroyed) then
			channelObj:UpdateMessageFiltered(filterData)
		end

		if (generalChannel and not generalChannel.Destroyed) then
			generalChannel:UpdateMessageFiltered(filterData)
		end
	else
		warn(string.format("Just received chat message for channel I'm not in [%s]", channelName))
	end
end)

EventFolder.OnNewSystemMessage.OnClientEvent:connect(function(messageData, channelName)
	channelName = channelName or "System"

	local channelObj = ChatWindow:GetChannel(channelName)
	if (channelObj) then
		channelObj:AddMessageToChannel(messageData)

		ChannelsBar:UpdateMessagePostedInChannel(channelName)

		moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
		moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)

		DoFadeInFromNewInformation()

		if (ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName) then
			local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
			if (generalChannel) then
				generalChannel:AddMessageToChannel(messageData)
			end
		end
	else
		warn(string.format("Just received system message for channel I'm not in [%s]", channelName))
	end
end)


function HandleChannelJoined(channel, welcomeMessage, messageLog)
	if (channel == ChatSettings.GeneralChannelName) then
		DidFirstChannelsLoads = true
	end

	local channelObj = ChatWindow:AddChannel(channel)

	if (channelObj) then
		if (channel == "All") then
			DoSwitchCurrentChannel(channel)
		end

		if (messageLog) then
			local startIndex = 1
			if #messageLog > ChatSettings.MessageHistoryLengthPerChannel then
				startIndex = #messageLog - ChatSettings.MessageHistoryLengthPerChannel
			end
			for i = startIndex, #messageLog do
				channelObj:AddMessageToChannel(messageLog[i])
			end
		end

		if (welcomeMessage ~= "") then
			local welcomeMessageObject = {
				ID = -1,
				FromSpeaker = nil,
				OriginalChannel = channel,
				IsFiltered = true,
				MessageLength = string.len(welcomeMessage),
				Message = welcomeMessage,
				MessageType = ChatConstants.MessageTypeWelcome,
				Time = os.time(),
				ExtraData = nil,
			}
			channelObj:AddMessageToChannel(welcomeMessageObject)
		end

		DoFadeInFromNewInformation()
	end

end

EventFolder.OnChannelJoined.OnClientEvent:connect(HandleChannelJoined)

EventFolder.OnChannelLeft.OnClientEvent:connect(function(channel)
	ChatWindow:RemoveChannel(channel)

	DoFadeInFromNewInformation()
end)

EventFolder.OnMuted.OnClientEvent:connect(function(channel)
	--// Do something eventually maybe?
	--// This used to take away the chat bar in channels the player was muted in.
	--// We found out this behavior was inconvenient for doing chat commands though.
end)

EventFolder.OnUnmuted.OnClientEvent:connect(function(channel)
	--// Same as above.
end)

EventFolder.OnMainChannelSet.OnClientEvent:connect(function(channel)
	DoSwitchCurrentChannel(channel)
end)



local reparentingLock = false
function connectGuiParent(GuiParent)
	local DestroyGuardFrame = Instance.new("Frame")
	DestroyGuardFrame.Name = "DestroyGuardFrame"
	DestroyGuardFrame.BackgroundTransparency = 1
	DestroyGuardFrame.Size = UDim2.new(1, 0, 1, 0)
	DestroyGuardFrame.Parent = GuiParent

	for i, v in pairs(GuiParent:GetChildren()) do
		if (v ~= DestroyGuardFrame) then
			v.Parent = DestroyGuardFrame
		end
	end

end

connectGuiParent(GuiParent)

GuiParent.Changed:connect(function(prop)
	if (prop == "Parent" and not reparentingLock) then
		reparentingLock = true

		local children = GuiParent.DestroyGuardFrame:GetChildren()
		for i, v in pairs(children) do
			v.Parent = nil
		end

		LocalPlayer.CharacterAdded:wait()
		GuiParent.Parent = PlayerGui

		for i, v in pairs(children) do
			v.Parent = GuiParent
		end

		connectGuiParent(GuiParent)

		reparentingLock = false
	end
end)

local ChatBarFocusedState = nil

--// Always on top behavior that relies on parenting order of ScreenGuis
--// This would end up really bad if something else tried to do the exact same thing however.
PlayerGui.ChildAdded:connect(function(child)
	if (child ~= GuiParent and not reparentingLock) then
		reparentingLock = true

		GuiParent.Parent = nil
		RunService.RenderStepped:wait()
		GuiParent.Parent = PlayerGui

		reparentingLock = false
	elseif child == GuiParent then
		if ChatBarFocusedState then
			RunService.RenderStepped:wait()
			ChatBar:RestoreFocusedState(ChatBarFocusedState)
		end
	end
end)

PlayerGui.DescendantRemoving:connect(function(descendant)
	if descendant == GuiParent then
		ChatBarFocusedState = ChatBar:GetFocusedState()
	end
end)


local initData = EventFolder.GetInitDataRequest:InvokeServer()

for i, channelData in pairs(initData.Channels) do
	HandleChannelJoined(unpack(channelData))
end

return moduleApiTable
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8514EC7E996F40159AAD4C802E64D3D8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChannelsTab</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChannelsTab.lua
--	// Written by: Xsitsu
--	// Description: Channel tab button for selecting current channel and also displaying if currently selected.

local module = {}
--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local modulesFolder = script.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

local function CreateGuiObjects()
	local BaseFrame = Instance.new("Frame")
	BaseFrame.Selectable = false
	BaseFrame.Size = UDim2.new(1, 0, 1, 0)
	BaseFrame.BackgroundTransparency = 1

	local gapOffsetX = 1
	local gapOffsetY = 1

	local BackgroundFrame = Instance.new("Frame")
	BackgroundFrame.Selectable = false
	BackgroundFrame.Name = "BackgroundFrame"
	BackgroundFrame.Size = UDim2.new(1, -gapOffsetX * 2, 1, -gapOffsetY * 2)
	BackgroundFrame.Position = UDim2.new(0, gapOffsetX, 0, gapOffsetY)
	BackgroundFrame.BackgroundTransparency = 1
	BackgroundFrame.Parent = BaseFrame

	local UnselectedFrame = Instance.new("Frame")
	UnselectedFrame.Selectable = false
	UnselectedFrame.Name = "UnselectedFrame"
	UnselectedFrame.Size = UDim2.new(1, 0, 1, 0)
	UnselectedFrame.Position = UDim2.new(0, 0, 0, 0)
	UnselectedFrame.BorderSizePixel = 0
	UnselectedFrame.BackgroundColor3 = ChatSettings.ChannelsTabUnselectedColor
	UnselectedFrame.BackgroundTransparency = 0.6
	UnselectedFrame.Parent = BackgroundFrame

	local SelectedFrame = Instance.new("Frame")
	SelectedFrame.Selectable = false
	SelectedFrame.Name = "SelectedFrame"
	SelectedFrame.Size = UDim2.new(1, 0, 1, 0)
	SelectedFrame.Position = UDim2.new(0, 0, 0, 0)
	SelectedFrame.BorderSizePixel = 0
	SelectedFrame.BackgroundColor3 = ChatSettings.ChannelsTabSelectedColor
	SelectedFrame.BackgroundTransparency = 1
	SelectedFrame.Parent = BackgroundFrame

	local SelectedFrameBackgroundImage = Instance.new("ImageLabel")
	SelectedFrameBackgroundImage.Selectable = false
	SelectedFrameBackgroundImage.Name = "BackgroundImage"
	SelectedFrameBackgroundImage.BackgroundTransparency = 1
	SelectedFrameBackgroundImage.BorderSizePixel = 0
	SelectedFrameBackgroundImage.Size = UDim2.new(1, 0, 1, 0)
	SelectedFrameBackgroundImage.Position = UDim2.new(0, 0, 0, 0)
	SelectedFrameBackgroundImage.ScaleType = Enum.ScaleType.Slice
	SelectedFrameBackgroundImage.Parent = SelectedFrame

	SelectedFrameBackgroundImage.BackgroundTransparency = 0.6 - 1
	local rate = 1.2 * 1
	SelectedFrameBackgroundImage.BackgroundColor3 = Color3.fromRGB(78 * rate, 84 * rate, 96 * rate)

	local borderXOffset = 2
	local blueBarYSize = 4
	local BlueBarLeft = Instance.new("ImageLabel")
	BlueBarLeft.Selectable = false
	BlueBarLeft.Size = UDim2.new(0.5, -borderXOffset, 0, blueBarYSize)
	BlueBarLeft.BackgroundTransparency = 1
	BlueBarLeft.ScaleType = Enum.ScaleType.Slice
	BlueBarLeft.SliceCenter = Rect.new(3,3,32,21)
	BlueBarLeft.Parent = SelectedFrame

	local BlueBarRight = BlueBarLeft:Clone()
	BlueBarRight.Parent = SelectedFrame

	BlueBarLeft.Position = UDim2.new(0, borderXOffset, 1, -blueBarYSize)
	BlueBarRight.Position = UDim2.new(0.5, 0, 1, -blueBarYSize)
	BlueBarLeft.Image = "rbxasset://textures/ui/Settings/Slider/SelectedBarLeft.png"
	BlueBarRight.Image = "rbxasset://textures/ui/Settings/Slider/SelectedBarRight.png"

	BlueBarLeft.Name = "BlueBarLeft"
	BlueBarRight.Name = "BlueBarRight"

	local NameTag = Instance.new("TextButton")
	NameTag.Selectable = ChatSettings.GamepadNavigationEnabled
	NameTag.Size = UDim2.new(1, 0, 1, 0)
	NameTag.Position = UDim2.new(0, 0, 0, 0)
	NameTag.BackgroundTransparency = 1
	NameTag.Font = ChatSettings.DefaultFont
	NameTag.TextSize = ChatSettings.ChatChannelsTabTextSize
	NameTag.TextColor3 = Color3.new(1, 1, 1)
	NameTag.TextStrokeTransparency = 0.75
	NameTag.Parent = BackgroundFrame

	local NameTagNonSelect = NameTag:Clone()
	local NameTagSelect = NameTag:Clone()
	NameTagNonSelect.Parent = UnselectedFrame
	NameTagSelect.Parent = SelectedFrame
	NameTagNonSelect.Font = Enum.Font.SourceSans
	NameTagNonSelect.Active = false
	NameTagSelect.Active = false

	local NewMessageIconFrame = Instance.new("Frame")
	NewMessageIconFrame.Selectable = false
	NewMessageIconFrame.Size = UDim2.new(0, 18, 0, 18)
	NewMessageIconFrame.Position = UDim2.new(0.8, -9, 0.5, -9)
	NewMessageIconFrame.BackgroundTransparency = 1
	NewMessageIconFrame.Parent = BackgroundFrame

	local NewMessageIcon = Instance.new("ImageLabel")
	NewMessageIcon.Selectable = false
	NewMessageIcon.Size = UDim2.new(1, 0, 1, 0)
	NewMessageIcon.BackgroundTransparency = 1
	NewMessageIcon.Image = "rbxasset://textures/ui/Chat/MessageCounter.png"
	NewMessageIcon.Visible = false
	NewMessageIcon.Parent = NewMessageIconFrame

	local NewMessageIconText = Instance.new("TextLabel")
	NewMessageIconText.Selectable = false
	NewMessageIconText.BackgroundTransparency = 1
	NewMessageIconText.Size = UDim2.new(0, 13, 0, 9)
	NewMessageIconText.Position = UDim2.new(0.5, -7, 0.5, -7)
	NewMessageIconText.Font = ChatSettings.DefaultFont
	NewMessageIconText.TextSize = 14
	NewMessageIconText.TextColor3 = Color3.new(1, 1, 1)
	NewMessageIconText.Text = ""
	NewMessageIconText.Parent = NewMessageIcon

	return BaseFrame, NameTag, NameTagNonSelect, NameTagSelect, NewMessageIcon, UnselectedFrame, SelectedFrame
end

function methods:Destroy()
	self.GuiObject:Destroy()
end

function methods:UpdateMessagePostedInChannel(ignoreActive)
	if (self.Active and (ignoreActive ~= true)) then return end

	local count = self.UnreadMessageCount + 1
	self.UnreadMessageCount = count

	local label = self.NewMessageIcon
	label.Visible = true
	label.TextLabel.Text = (count < 100) and tostring(count) or "!"

	local tweenTime = 0.15
	local tweenPosOffset = UDim2.new(0, 0, -0.1, 0)

	local curPos = label.Position
	local outPos = curPos + tweenPosOffset
	local easingDirection = Enum.EasingDirection.Out
	local easingStyle = Enum.EasingStyle.Quad

	label.Position = UDim2.new(0, 0, -0.15, 0)
	label:TweenPosition(UDim2.new(0, 0, 0, 0), easingDirection, easingStyle, tweenTime, true)

end

function methods:SetActive(active)
	self.Active = active
	self.UnselectedFrame.Visible = not active
	self.SelectedFrame.Visible = active

	if (active) then
		self.UnreadMessageCount = 0
		self.NewMessageIcon.Visible = false

		self.NameTag.Font = Enum.Font.SourceSansBold
	else
		self.NameTag.Font = Enum.Font.SourceSans

	end
end

function methods:SetTextSize(textSize)
	self.NameTag.TextSize = textSize
end

function methods:FadeOutBackground(duration)
	self.AnimParams.Background_TargetTransparency = 1
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeInBackground(duration)
	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeOutText(duration)
	self.AnimParams.Text_TargetTransparency = 1
	self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
	self.AnimParams.TextStroke_TargetTransparency = 1
	self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeInText(duration)
	self.AnimParams.Text_TargetTransparency = 0
	self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
	self.AnimParams.TextStroke_TargetTransparency = 0.75
	self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:AnimGuiObjects()
	self.UnselectedFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
	self.SelectedFrame.BackgroundImage.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
	self.SelectedFrame.BlueBarLeft.ImageTransparency = self.AnimParams.Background_CurrentTransparency
	self.SelectedFrame.BlueBarRight.ImageTransparency = self.AnimParams.Background_CurrentTransparency
	self.NameTagNonSelect.TextTransparency = self.AnimParams.Background_CurrentTransparency
	self.NameTagNonSelect.TextStrokeTransparency = self.AnimParams.Background_CurrentTransparency

	self.NameTag.TextTransparency = self.AnimParams.Text_CurrentTransparency
	self.NewMessageIcon.ImageTransparency = self.AnimParams.Text_CurrentTransparency
	self.WhiteTextNewMessageNotification.TextTransparency = self.AnimParams.Text_CurrentTransparency
	self.NameTagSelect.TextTransparency = self.AnimParams.Text_CurrentTransparency

	self.NameTag.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
	self.WhiteTextNewMessageNotification.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
	self.NameTagSelect.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
end

function methods:InitializeAnimParams()
	self.AnimParams.Text_TargetTransparency = 0
	self.AnimParams.Text_CurrentTransparency = 0
	self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)

	self.AnimParams.TextStroke_TargetTransparency = 0.75
	self.AnimParams.TextStroke_CurrentTransparency = 0.75
	self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)

	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_CurrentTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
end

function methods:Update(dtScale)
	self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
			self.AnimParams.Background_CurrentTransparency,
			self.AnimParams.Background_TargetTransparency,
			self.AnimParams.Background_NormalizedExptValue,
			dtScale
	)
	self.AnimParams.Text_CurrentTransparency = CurveUtil:Expt(
			self.AnimParams.Text_CurrentTransparency,
			self.AnimParams.Text_TargetTransparency,
			self.AnimParams.Text_NormalizedExptValue,
			dtScale
	)
	self.AnimParams.TextStroke_CurrentTransparency = CurveUtil:Expt(
			self.AnimParams.TextStroke_CurrentTransparency,
			self.AnimParams.TextStroke_TargetTransparency,
			self.AnimParams.TextStroke_NormalizedExptValue,
			dtScale
	)

	self:AnimGuiObjects()
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ChannelsTab", methods)

function module.new(channelName)
	local obj = {}

	local BaseFrame, NameTag, NameTagNonSelect, NameTagSelect, NewMessageIcon, UnselectedFrame, SelectedFrame = CreateGuiObjects()
	obj.GuiObject = BaseFrame
	obj.NameTag = NameTag
	obj.NameTagNonSelect = NameTagNonSelect
	obj.NameTagSelect = NameTagSelect
	obj.NewMessageIcon = NewMessageIcon
	obj.UnselectedFrame = UnselectedFrame
	obj.SelectedFrame = SelectedFrame

	obj.BlueBarLeft = SelectedFrame.BlueBarLeft
	obj.BlueBarRight = SelectedFrame.BlueBarRight
	obj.BackgroundImage = SelectedFrame.BackgroundImage
	obj.WhiteTextNewMessageNotification = obj.NewMessageIcon.TextLabel

	obj.ChannelName = channelName
	obj.UnreadMessageCount = 0
	obj.Active = false

	obj.GuiObject.Name = "Frame_" .. obj.ChannelName

	if (string.len(channelName) > ChatSettings.MaxChannelNameLength) then
		channelName = string.sub(channelName, 1, ChatSettings.MaxChannelNameLength - 3) .. "..."
	end

	--obj.NameTag.Text = channelName

	obj.NameTag.Text = ""
	obj.NameTagNonSelect.Text = channelName
	obj.NameTagSelect.Text = channelName

	obj.AnimParams = {}

	ClassMaker.MakeClass("ChannelsTab", obj)

	obj:InitializeAnimParams()
	obj:AnimGuiObjects()
	obj:SetActive(false)

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBFC7EBA691324AFCABBDF61867801BB4">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChatBar</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChatBar.lua
--	// Written by: Xsitsu
--	// Description: Manages text typing and typing state.

local module = {}

local UserInputService = game:GetService("UserInputService")

--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local modulesFolder = script.Parent
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))

local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function methods:CreateGuiObjects(targetParent)
	rawset(self, "ChatBarParentFrame", targetParent)

	local backgroundImagePixelOffset = 7
	local textBoxPixelOffset = 5

	local BaseFrame = Instance.new("Frame")
	BaseFrame.Selectable = false
	BaseFrame.Size = UDim2.new(1, 0, 1, 0)
	BaseFrame.BackgroundTransparency = 0.6
	BaseFrame.BorderSizePixel = 0
	BaseFrame.BackgroundColor3 = ChatSettings.ChatBarBackGroundColor
	BaseFrame.Parent = targetParent

	local BoxFrame = Instance.new("Frame")
	BoxFrame.Selectable = false
	BoxFrame.Name = "BoxFrame"
	BoxFrame.BackgroundTransparency = 0.6
	BoxFrame.BorderSizePixel = 0
	BoxFrame.BackgroundColor3 = ChatSettings.ChatBarBoxColor
	BoxFrame.Size = UDim2.new(1, -backgroundImagePixelOffset * 2, 1, -backgroundImagePixelOffset * 2)
	BoxFrame.Position = UDim2.new(0, backgroundImagePixelOffset, 0, backgroundImagePixelOffset)
	BoxFrame.Parent = BaseFrame

	local TextBoxHolderFrame = Instance.new("Frame")
	TextBoxHolderFrame.BackgroundTransparency = 1
	TextBoxHolderFrame.Size = UDim2.new(1, -textBoxPixelOffset * 2, 1, -textBoxPixelOffset * 2)
	TextBoxHolderFrame.Position = UDim2.new(0, textBoxPixelOffset, 0, textBoxPixelOffset)
	TextBoxHolderFrame.Parent = BoxFrame

	local TextBox = Instance.new("TextBox")
	TextBox.Selectable = ChatSettings.GamepadNavigationEnabled
	TextBox.Name = "ChatBar"
	TextBox.BackgroundTransparency = 1
	TextBox.Size = UDim2.new(1, 0, 1, 0)
	TextBox.Position = UDim2.new(0, 0, 0, 0)
	TextBox.TextSize = ChatSettings.ChatBarTextSize
	TextBox.Font = ChatSettings.ChatBarFont
	TextBox.TextColor3 = ChatSettings.ChatBarTextColor
	TextBox.TextTransparency = 0.4
	TextBox.TextStrokeTransparency = 1
	TextBox.ClearTextOnFocus = false
	TextBox.TextXAlignment = Enum.TextXAlignment.Left
	TextBox.TextYAlignment = Enum.TextYAlignment.Top
	TextBox.TextWrapped = true
	TextBox.Text = ""
	TextBox.Parent = TextBoxHolderFrame

	local MessageModeTextLabel = Instance.new("TextLabel")
	MessageModeTextLabel.Name = "MessageMode"
	MessageModeTextLabel.BackgroundTransparency = 1
	MessageModeTextLabel.Position = UDim2.new(0, 0, 0, 0)
	MessageModeTextLabel.TextSize = ChatSettings.ChatBarTextSize
	MessageModeTextLabel.Font = ChatSettings.ChatBarFont
	MessageModeTextLabel.TextXAlignment = Enum.TextXAlignment.Left
	MessageModeTextLabel.TextWrapped = true
	MessageModeTextLabel.Text = ""
	MessageModeTextLabel.Size = UDim2.new(0.3, 0, 1, 0)
	MessageModeTextLabel.TextYAlignment = Enum.TextYAlignment.Center
	MessageModeTextLabel.TextColor3 = Color3.fromRGB(77, 139, 255)
	MessageModeTextLabel.Visible = false
	MessageModeTextLabel.Parent = TextBoxHolderFrame

	local TextLabel = Instance.new("TextLabel")
	TextLabel.Selectable = false
	TextLabel.TextWrapped = true
	TextLabel.BackgroundTransparency = 1
	TextLabel.Size = TextBox.Size
	TextLabel.Position = TextBox.Position
	TextLabel.TextSize = TextBox.TextSize
	TextLabel.Font = TextBox.Font
	TextLabel.TextColor3 = TextBox.TextColor3
	TextLabel.TextTransparency = TextBox.TextTransparency
	TextLabel.TextStrokeTransparency = TextBox.TextStrokeTransparency
	TextLabel.TextXAlignment = TextBox.TextXAlignment
	TextLabel.TextYAlignment = TextBox.TextYAlignment
	TextLabel.Text = "This value needs to be set with :SetTextLabelText()"
	TextLabel.Parent = TextBoxHolderFrame

	rawset(self, "GuiObject", BaseFrame)
	rawset(self, "TextBox", TextBox)
	rawset(self, "TextLabel", TextLabel)

	self.GuiObjects.BaseFrame = BaseFrame
	self.GuiObjects.TextBoxFrame = BoxFrame
	self.GuiObjects.TextBox = TextBox
	self.GuiObjects.TextLabel = TextLabel
	self.GuiObjects.MessageModeTextLabel = MessageModeTextLabel

	self:AnimGuiObjects()
	self:SetUpTextBoxEvents(TextBox, TextLabel, MessageModeTextLabel)
	self.eGuiObjectsChanged:Fire()
end

function methods:DisconnectConnections()
	for i = 1, #self.Connections do
		self.Connections[i]:Disconnect()
	end
	self.Connections = {}
end

function methods:SetUpTextBoxEvents(TextBox, TextLabel, MessageModeTextLabel)
	self:DisconnectConnections()

	--// Code for getting back into general channel from other target channel when pressing backspace.
	local inputBeganConnection = UserInputService.InputBegan:connect(function(inputObj, gpe)
		if (inputObj.KeyCode == Enum.KeyCode.Backspace) then
			if (TextBox:IsFocused() and TextBox.Text == "") then
				self:SetChannelTarget(ChatSettings.GeneralChannelName)
			end
		end
	end)
	table.insert(self.Connections, inputBeganConnection)

	local textboxChangedConnection = TextBox.Changed:connect(function(prop)
		if prop ~= "Text" then
			return
		end

		self:CalculateSize()

		if (string.len(TextBox.Text) > ChatSettings.MaximumMessageLength) then
			TextBox.Text = string.sub(TextBox.Text, 1, ChatSettings.MaximumMessageLength)
			return
		end

		if not self.InCustomState then
			local customState = self.CommandProcessor:ProcessInProgressChatMessage(TextBox.Text, self.ChatWindow, self)
			if customState then
				self.InCustomState = true
				rawset(self, "CustomState", customState)
			end
		else
			self.CustomState:TextUpdated()
		end
	end)
	table.insert(self.Connections, textboxChangedConnection)

	local function UpdateOnFocusStatusChanged(isFocused)
		if (isFocused) then
			TextLabel.Visible = false
			MessageModeTextLabel.Visible = true
		else
			local setVis = (TextBox.Text == "")
			TextLabel.Visible = setVis
			MessageModeTextLabel.Visible = not setVis
		end
	end

	local textboxfocusedConnection = TextBox.Focused:connect(function()
		self:CalculateSize()
		UpdateOnFocusStatusChanged(true)
	end)
	table.insert(self.Connections, textboxfocusedConnection)

	local textboxFocusLostConnection = TextBox.FocusLost:connect(function(enterPressed, inputObject)
		self:ResetSize()
		if (inputObject and inputObject.KeyCode == Enum.KeyCode.Escape) then
			TextBox.Text = ""
		end
		UpdateOnFocusStatusChanged(false)
	end)
	table.insert(self.Connections, textboxFocusLostConnection)
end

function methods:GetTextBox()
	return self.TextBox
end

function methods:GetMessageModeTextLabel()
	return self.GuiObjects.MessageModeTextLabel
end

function methods:IsFocused()
	-- Temporary hack while reparenting is necessary.
	if not self.GuiObject:IsDescendantOf(game) then
		if rawget(self, "LastFocusedState") then
			return self.LastFocusedState.Focused
		end
	end
	return self:GetTextBox():IsFocused()
end

function methods:GetVisible()
	return self.GuiObject.Visible
end

function methods:CaptureFocus()
	self:GetTextBox():CaptureFocus()
end

function methods:ReleaseFocus(didRelease)
	self:GetTextBox():ReleaseFocus(didRelease)
end

function methods:ResetText()
	self:GetTextBox().Text = ""
end

function methods:SetText(text)
	self:GetTextBox().Text = text
end

function methods:GetEnabled()
	return self.GuiObject.Visible
end

function methods:SetEnabled(enabled)
	self.GuiObject.Visible = enabled
end

function methods:SetTextLabelText(text)
	self.TextLabel.Text = text
end

function methods:SetTextBoxText(text)
	self.TextBox.Text = text
end

function methods:GetTextBoxText()
	return self.TextBox.Text
end

function methods:ResetSize()
	self.TargetYSize = 0
	self:TweenToTargetYSize()
end

function methods:CalculateSize()
	local lastPos = self.GuiObject.Size
	self.GuiObject.Size = UDim2.new(1, 0, 0, 1000)

	local textSize = self.TextBox.TextSize
	local bounds = self.TextBox.TextBounds.Y

	self.GuiObject.Size = lastPos

	local newTargetYSize = bounds - textSize
	if (self.TargetYSize ~= newTargetYSize) then
		self.TargetYSize = newTargetYSize
		self:TweenToTargetYSize()
	end

end

function methods:TweenToTargetYSize()
	local endSize = UDim2.new(1, 0, 1, self.TargetYSize)
	local curSize = self.GuiObject.Size

	local curAbsoluteSizeY = self.GuiObject.AbsoluteSize.Y
	self.GuiObject.Size = endSize
	local endAbsoluteSizeY = self.GuiObject.AbsoluteSize.Y
	self.GuiObject.Size = curSize

	local pixelDistance = math.abs(endAbsoluteSizeY - curAbsoluteSizeY)
	local tweeningTime = math.min(1, (pixelDistance * (1 / self.TweenPixelsPerSecond))) -- pixelDistance * (seconds per pixels)

	local success = pcall(function() self.GuiObject:TweenSize(endSize, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, tweeningTime, true) end)
	if (not success) then
		self.GuiObject.Size = endSize
	end
end

function methods:SetTextSize(textSize)
	if not self:IsInCustomState() then
		if rawget(self, "TextBox") then
			self.TextBox.TextSize = textSize
		end
		if rawget(self, "TextLabel") then
			self.TextLabel.TextSize = textSize
		end
	end
end

function methods:SetChannelTarget(targetChannel)
	local messageModeTextLabel = self.GuiObjects.MessageModeTextLabel
	local textBox = self.TextBox

	rawset(self, "TargetChannel", targetChannel)

	if not self:IsInCustomState() then
		if (targetChannel ~= ChatSettings.GeneralChannelName) then
			messageModeTextLabel.Size = UDim2.new(0, 1000, 1, 0)
			messageModeTextLabel.Text = string.format("[%s] ", targetChannel)

			local xSize = messageModeTextLabel.TextBounds.X
			messageModeTextLabel.Size = UDim2.new(0, xSize, 1, 0)
			textBox.Size = UDim2.new(1, -xSize, 1, 0)
			textBox.Position = UDim2.new(0, xSize, 0, 0)

		else
			messageModeTextLabel.Text = ""
			textBox.Size = UDim2.new(1, 0, 1, 0)
			textBox.Position = UDim2.new(0, 0, 0, 0)

		end
	end
end

function methods:IsInCustomState()
	return self.InCustomState
end

function methods:ResetCustomState()
	if self.InCustomState then
		self.CustomState:Destroy()
		self.CustomState = nil
		self.InCustomState = false

		self.ChatBarParentFrame:ClearAllChildren()
		self:CreateGuiObjects(self.ChatBarParentFrame)
		self:SetTextLabelText('To chat click here or press "/" key')
	end
end

function methods:GetCustomMessage()
	if self.InCustomState then
		return self.CustomState:GetMessage()
	end
	return nil
end

function methods:CustomStateProcessCompletedMessage(message)
	if self.InCustomState then
		return self.CustomState:ProcessCompletedMessage()
	end
	return false
end

-- Temporary hack until ScreenGui.DisplayOrder is released.
function methods:GetFocusedState()
	local focusedState = {
		Focused = self.TextBox:IsFocused(),
		Text = self.TextBox.Text
	}
	rawset(self, "LastFocusedState", focusedState)
	return focusedState
end

function methods:RestoreFocusedState(focusedState)
	self.TextBox.Text = focusedState.Text
	if focusedState.Focused then
		self.TextBox:CaptureFocus()
	end
end

function methods:FadeOutBackground(duration)
	self.AnimParams.Background_TargetTransparency = 1
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
	self:FadeOutText(duration)
end

function methods:FadeInBackground(duration)
	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
	self:FadeInText(duration)
end

function methods:FadeOutText(duration)
	self.AnimParams.Text_TargetTransparency = 1
	self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeInText(duration)
	self.AnimParams.Text_TargetTransparency = 0.4
	self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:AnimGuiObjects()
	self.GuiObject.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
	self.GuiObjects.TextBoxFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency

	self.GuiObjects.TextLabel.TextTransparency = self.AnimParams.Text_CurrentTransparency
	self.GuiObjects.TextBox.TextTransparency = self.AnimParams.Text_CurrentTransparency
	self.GuiObjects.MessageModeTextLabel.TextTransparency = self.AnimParams.Text_CurrentTransparency
end

function methods:InitializeAnimParams()
	self.AnimParams.Text_TargetTransparency = 0.4
	self.AnimParams.Text_CurrentTransparency = 0.4
	self.AnimParams.Text_NormalizedExptValue = 1

	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_CurrentTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = 1
end

function methods:Update(dtScale)
	self.AnimParams.Text_CurrentTransparency = CurveUtil:Expt(
			self.AnimParams.Text_CurrentTransparency,
			self.AnimParams.Text_TargetTransparency,
			self.AnimParams.Text_NormalizedExptValue,
			dtScale
	)
	self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
			self.AnimParams.Background_CurrentTransparency,
			self.AnimParams.Background_TargetTransparency,
			self.AnimParams.Background_NormalizedExptValue,
			dtScale
	)

	self:AnimGuiObjects()
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ChatBar", methods)

function module.new(CommandProcessor, ChatWindow)
	local obj = {}

	obj.GuiObject = nil
	obj.ChatBarParentFrame = nil
	obj.TextBox = nil
	obj.TextLabel = nil
	obj.GuiObjects = {}
	obj.eGuiObjectsChanged = Instance.new("BindableEvent")
	obj.GuiObjectsChanged = obj.eGuiObjectsChanged.Event

	obj.Connections = {}
	obj.InCustomState = false
	obj.CustomState = nil

	obj.TargetChannel = nil
	obj.CommandProcessor = CommandProcessor
	obj.ChatWindow = ChatWindow

	obj.TweenPixelsPerSecond = 500
	obj.TargetYSize = 0

	obj.AnimParams = {}
	obj.LastFocusedState = nil

	ClassMaker.MakeClass("ChatBar", obj)

	obj:InitializeAnimParams()

	ChatSettings.SettingsChanged:connect(function(setting, value)
		if (setting == "ChatBarTextSize") then
			obj:SetTextSize(value)
		end
	end)


	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5A5FD7375EC84E4D94CD59F0A6A0E7A5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChannelsBar</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--	// FileName: ChannelsBar.lua
--	// Written by: Xsitsu
--	// Description: Manages creating, destroying, and displaying ChannelTabs.

local module = {}

local PlayerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

--////////////////////////////// Include
--//////////////////////////////////////
local Chat = game:GetService("Chat")
local clientChatModules = Chat:WaitForChild("ClientChatModules")
local modulesFolder = script.Parent
local moduleChannelsTab = require(modulesFolder:WaitForChild("ChannelsTab"))
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))
local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function methods:CreateGuiObjects(targetParent)
	local BaseFrame = Instance.new("Frame")
	BaseFrame.Selectable = false
	BaseFrame.Size = UDim2.new(1, 0, 1, 0)
	BaseFrame.BackgroundTransparency = 1
	BaseFrame.Parent = targetParent

	local ScrollingBase = Instance.new("Frame")
	ScrollingBase.Selectable = false
	ScrollingBase.Name = "ScrollingBase"
	ScrollingBase.BackgroundTransparency = 1
	ScrollingBase.ClipsDescendants = true
	ScrollingBase.Size = UDim2.new(1, 0, 1, 0)
	ScrollingBase.Position = UDim2.new(0, 0, 0, 0)
	ScrollingBase.Parent = BaseFrame

	local ScrollerSizer = Instance.new("Frame")
	ScrollerSizer.Selectable = false
	ScrollerSizer.Name = "ScrollerSizer"
	ScrollerSizer.BackgroundTransparency = 1
	ScrollerSizer.Size = UDim2.new(1, 0, 1, 0)
	ScrollerSizer.Position = UDim2.new(0, 0, 0, 0)
	ScrollerSizer.Parent = ScrollingBase

	local ScrollerFrame = Instance.new("Frame")
	ScrollerFrame.Selectable = false
	ScrollerFrame.Name = "ScrollerFrame"
	ScrollerFrame.BackgroundTransparency = 1
	ScrollerFrame.Size = UDim2.new(1, 0, 1, 0)
	ScrollerFrame.Position = UDim2.new(0, 0, 0, 0)
	ScrollerFrame.Parent = ScrollerSizer

	local LeaveConfirmationFrameBase = Instance.new("Frame")
	LeaveConfirmationFrameBase.Selectable = false
	LeaveConfirmationFrameBase.Size = UDim2.new(1, 0, 1, 0)
	LeaveConfirmationFrameBase.Position = UDim2.new(0, 0, 0, 0)
	LeaveConfirmationFrameBase.ClipsDescendants = true
	LeaveConfirmationFrameBase.BackgroundTransparency = 1
	LeaveConfirmationFrameBase.Parent = BaseFrame

	local LeaveConfirmationFrame = Instance.new("Frame")
	LeaveConfirmationFrame.Selectable = false
	LeaveConfirmationFrame.Name = "LeaveConfirmationFrame"
	LeaveConfirmationFrame.Size = UDim2.new(1, 0, 1, 0)
	LeaveConfirmationFrame.Position = UDim2.new(0, 0, 1, 0)
	LeaveConfirmationFrame.BackgroundTransparency = 0.6
	LeaveConfirmationFrame.BorderSizePixel = 0
	LeaveConfirmationFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	LeaveConfirmationFrame.Parent = LeaveConfirmationFrameBase

	local InputBlocker = Instance.new("TextButton")
	InputBlocker.Selectable = false
	InputBlocker.Size = UDim2.new(1, 0, 1, 0)
	InputBlocker.BackgroundTransparency = 1
	InputBlocker.Text = ""
	InputBlocker.Parent = LeaveConfirmationFrame

	local LeaveConfirmationButtonYes = Instance.new("TextButton")
	LeaveConfirmationButtonYes.Selectable = false
	LeaveConfirmationButtonYes.Size = UDim2.new(0.25, 0, 1, 0)
	LeaveConfirmationButtonYes.BackgroundTransparency = 1
	LeaveConfirmationButtonYes.Font = ChatSettings.DefaultFont
	LeaveConfirmationButtonYes.TextSize = 18
	LeaveConfirmationButtonYes.TextStrokeTransparency = 0.75
	LeaveConfirmationButtonYes.Position = UDim2.new(0, 0, 0, 0)
	LeaveConfirmationButtonYes.TextColor3 = Color3.new(0, 1, 0)
	LeaveConfirmationButtonYes.Text = "Confirm"
	LeaveConfirmationButtonYes.Parent = LeaveConfirmationFrame

	local LeaveConfirmationButtonNo = LeaveConfirmationButtonYes:Clone()
	LeaveConfirmationButtonNo.Parent = LeaveConfirmationFrame
	LeaveConfirmationButtonNo.Position = UDim2.new(0.75, 0, 0, 0)
	LeaveConfirmationButtonNo.TextColor3 = Color3.new(1, 0, 0)
	LeaveConfirmationButtonNo.Text = "Cancel"

	local LeaveConfirmationNotice = Instance.new("TextLabel")
	LeaveConfirmationNotice.Selectable = false
	LeaveConfirmationNotice.Size = UDim2.new(0.5, 0, 1, 0)
	LeaveConfirmationNotice.Position = UDim2.new(0.25, 0, 0, 0)
	LeaveConfirmationNotice.BackgroundTransparency = 1
	LeaveConfirmationNotice.TextColor3 = Color3.new(1, 1, 1)
	LeaveConfirmationNotice.TextStrokeTransparency = 0.75
	LeaveConfirmationNotice.Text = "Leave channel <XX>?"
	LeaveConfirmationNotice.Font = ChatSettings.DefaultFont
	LeaveConfirmationNotice.TextSize = 18
	LeaveConfirmationNotice.Parent = LeaveConfirmationFrame

	local LeaveTarget = Instance.new("StringValue")
	LeaveTarget.Name = "LeaveTarget"
	LeaveTarget.Parent = LeaveConfirmationFrame

	local outPos = LeaveConfirmationFrame.Position
	LeaveConfirmationButtonYes.MouseButton1Click:connect(function()
		MessageSender:SendMessage(string.format("/leave %s", LeaveTarget.Value), nil)
		LeaveConfirmationFrame:TweenPosition(outPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2, true)
	end)
	LeaveConfirmationButtonNo.MouseButton1Click:connect(function()
		LeaveConfirmationFrame:TweenPosition(outPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2, true)
	end)



	local scale = 0.7
	local scaleOther = (1 - scale) / 2
	local pageButtonImage = "rbxasset://textures/ui/Chat/TabArrowBackground.png"
	local pageButtonArrowImage = "rbxasset://textures/ui/Chat/TabArrow.png"

	--// ToDo: Remove these lines when the assets are put into trunk.
	--// These grab unchanging versions hosted on the site, and not from the content folder.
	pageButtonImage = "rbxassetid://471630199"
	pageButtonArrowImage = "rbxassetid://471630112"


	local PageLeftButton = Instance.new("ImageButton", BaseFrame)
	PageLeftButton.Selectable = ChatSettings.GamepadNavigationEnabled
	PageLeftButton.Name = "PageLeftButton"
	PageLeftButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
	PageLeftButton.Size = UDim2.new(scale, 0, scale, 0)
	PageLeftButton.BackgroundTransparency = 1
	PageLeftButton.Position = UDim2.new(0, 4, scaleOther, 0)
	PageLeftButton.Visible = false
	PageLeftButton.Image = pageButtonImage
	local ArrowLabel = Instance.new("ImageLabel", PageLeftButton)
	ArrowLabel.Name = "ArrowLabel"
	ArrowLabel.BackgroundTransparency = 1
	ArrowLabel.Size = UDim2.new(0.4, 0, 0.4, 0)
	ArrowLabel.Image = pageButtonArrowImage

	local PageRightButtonPositionalHelper = Instance.new("Frame", BaseFrame)
	PageRightButtonPositionalHelper.Selectable = false
	PageRightButtonPositionalHelper.BackgroundTransparency = 1
	PageRightButtonPositionalHelper.Name = "PositionalHelper"
	PageRightButtonPositionalHelper.Size = PageLeftButton.Size
	PageRightButtonPositionalHelper.SizeConstraint = PageLeftButton.SizeConstraint
	PageRightButtonPositionalHelper.Position = UDim2.new(1, 0, scaleOther, 0)

	local PageRightButton = PageLeftButton:Clone()
	PageRightButton.Parent = PageRightButtonPositionalHelper
	PageRightButton.Name = "PageRightButton"
	PageRightButton.Size = UDim2.new(1, 0, 1, 0)
	PageRightButton.SizeConstraint = Enum.SizeConstraint.RelativeXY
	PageRightButton.Position = UDim2.new(-1, -4, 0, 0)

	local positionOffset = UDim2.new(0.05, 0, 0, 0)

	PageRightButton.ArrowLabel.Position = UDim2.new(0.3, 0, 0.3, 0) + positionOffset
	PageLeftButton.ArrowLabel.Position = UDim2.new(0.3, 0, 0.3, 0) - positionOffset
	PageLeftButton.ArrowLabel.Rotation = 180


	rawset(self, "GuiObject", BaseFrame)

	self.GuiObjects.BaseFrame = BaseFrame
	self.GuiObjects.ScrollerSizer = ScrollerSizer
	self.GuiObjects.ScrollerFrame = ScrollerFrame
	self.GuiObjects.PageLeftButton = PageLeftButton
	self.GuiObjects.PageRightButton = PageRightButton
	self.GuiObjects.LeaveConfirmationFrame = LeaveConfirmationFrame
	self.GuiObjects.LeaveConfirmationNotice = LeaveConfirmationNotice

	self.GuiObjects.PageLeftButtonArrow = PageLeftButton.ArrowLabel
	self.GuiObjects.PageRightButtonArrow = PageRightButton.ArrowLabel
	self:AnimGuiObjects()

	PageLeftButton.MouseButton1Click:connect(function() self:ScrollChannelsFrame(-1) end)
	PageRightButton.MouseButton1Click:connect(function() self:ScrollChannelsFrame(1) end)

	self:ScrollChannelsFrame(0)
end


function methods:UpdateMessagePostedInChannel(channelName)
	local tab = self:GetChannelTab(channelName)
	if (tab) then
		tab:UpdateMessagePostedInChannel()
	else
		warn("ChannelsTab '" .. channelName .. "' does not exist!")
	end
end

function methods:AddChannelTab(channelName)
	if (self:GetChannelTab(channelName)) then
		error("Channel tab '" .. channelName .. "'already exists!")
	end

	local tab = moduleChannelsTab.new(channelName)
	tab.GuiObject.Parent = self.GuiObjects.ScrollerFrame
	self.ChannelTabs[channelName:lower()] = tab

	self.NumTabs = self.NumTabs + 1
	self:OrganizeChannelTabs()

	if (ChatSettings.RightClickToLeaveChannelEnabled) then
		tab.NameTag.MouseButton2Click:connect(function()
			self.LeaveConfirmationNotice.Text = string.format("Leave channel %s?", tab.ChannelName)
			self.LeaveConfirmationFrame.LeaveTarget.Value = tab.ChannelName
			self.LeaveConfirmationFrame:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.2, true)
		end)
	end

	return tab
end

function methods:RemoveChannelTab(channelName)
	if (not self:GetChannelTab(channelName)) then
		error("Channel tab '" .. channelName .. "'does not exist!")
	end

	local indexName = channelName:lower()
	self.ChannelTabs[indexName]:Destroy()
	self.ChannelTabs[indexName] = nil

	self.NumTabs = self.NumTabs - 1
	self:OrganizeChannelTabs()
end

function methods:GetChannelTab(channelName)
	return self.ChannelTabs[channelName:lower()]
end

function methods:OrganizeChannelTabs()
	local order = {}

	table.insert(order, self:GetChannelTab(ChatSettings.GeneralChannelName))
	table.insert(order, self:GetChannelTab("System"))

	for tabIndexName, tab in pairs(self.ChannelTabs) do
		if (tab.ChannelName ~= ChatSettings.GeneralChannelName and tab.ChannelName ~= "System") then
			table.insert(order, tab)
		end
	end

	for index, tab in pairs(order) do
		tab.GuiObject.Position = UDim2.new(index - 1, 0, 0, 0)
	end

	--// Dynamic tab resizing
	self.GuiObjects.ScrollerSizer.Size = UDim2.new(1 / math.max(1, math.min(ChatSettings.ChannelsBarFullTabSize, self.NumTabs)), 0, 1, 0)

	self:ScrollChannelsFrame(0)
end

function methods:ResizeChannelTabText(textSize)
	for i, tab in pairs(self.ChannelTabs) do
		tab:SetTextSize(textSize)
	end
end

function methods:ScrollChannelsFrame(dir)
	if (self.ScrollChannelsFrameLock) then return end
	self.ScrollChannelsFrameLock = true

	local tabNumber = ChatSettings.ChannelsBarFullTabSize

	local newPageNum = self.CurPageNum + dir
	if (newPageNum < 0) then
		newPageNum = 0
	elseif (newPageNum > 0 and newPageNum + tabNumber > self.NumTabs) then
		newPageNum = self.NumTabs - tabNumber
	end

	self.CurPageNum = newPageNum

	local tweenTime = 0.15
	local endPos = UDim2.new(-self.CurPageNum, 0, 0, 0)

	self.GuiObjects.PageLeftButton.Visible = (self.CurPageNum > 0)
	self.GuiObjects.PageRightButton.Visible = (self.CurPageNum + tabNumber < self.NumTabs)

	if dir == 0 then
		self.ScrollChannelsFrameLock = false
		return
	end

	local function UnlockFunc()
		self.ScrollChannelsFrameLock = false
	end

	self:WaitUntilParentedCorrectly()

	self.GuiObjects.ScrollerFrame:TweenPosition(endPos, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, tweenTime, true, UnlockFunc)
end

function methods:FadeOutBackground(duration)
	for channelName, channelObj in pairs(self.ChannelTabs) do
		channelObj:FadeOutBackground(duration)
	end

	self.AnimParams.Background_TargetTransparency = 1
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeInBackground(duration)
	for channelName, channelObj in pairs(self.ChannelTabs) do
		channelObj:FadeInBackground(duration)
	end

	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
end

function methods:FadeOutText(duration)
	for channelName, channelObj in pairs(self.ChannelTabs) do
		channelObj:FadeOutText(duration)
	end
end

function methods:FadeInText(duration)
	for channelName, channelObj in pairs(self.ChannelTabs) do
		channelObj:FadeInText(duration)
	end
end

function methods:AnimGuiObjects()
	self.GuiObjects.PageLeftButton.ImageTransparency = self.AnimParams.Background_CurrentTransparency
	self.GuiObjects.PageRightButton.ImageTransparency = self.AnimParams.Background_CurrentTransparency
	self.GuiObjects.PageLeftButtonArrow.ImageTransparency = self.AnimParams.Background_CurrentTransparency
	self.GuiObjects.PageRightButtonArrow.ImageTransparency = self.AnimParams.Background_CurrentTransparency
end

function methods:InitializeAnimParams()
	self.AnimParams.Background_TargetTransparency = 0.6
	self.AnimParams.Background_CurrentTransparency = 0.6
	self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
end

function methods:Update(dtScale)
	for channelName, channelObj in pairs(self.ChannelTabs) do
		channelObj:Update(dtScale)
	end

	self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
			self.AnimParams.Background_CurrentTransparency,
			self.AnimParams.Background_TargetTransparency,
			self.AnimParams.Background_NormalizedExptValue,
			dtScale
	)

	self:AnimGuiObjects()
end

--// ToDo: Move to common modules
function methods:WaitUntilParentedCorrectly()
	while (not self.GuiObject:IsDescendantOf(game:GetService("Players").LocalPlayer)) do
		self.GuiObject.AncestryChanged:wait()
	end
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ChannelsBar", methods)

function module.new()
	local obj = {}

	obj.GuiObject = nil
	obj.GuiObjects = {}

	obj.ChannelTabs = {}
	obj.NumTabs = 0
	obj.CurPageNum = 0

	obj.ScrollChannelsFrameLock = false

	obj.AnimParams = {}

	ClassMaker.MakeClass("ChannelsBar", obj)

	obj:InitializeAnimParams()

	ChatSettings.SettingsChanged:connect(function(setting, value)
		if (setting == "ChatChannelsTabTextSize") then
			obj:ResizeChannelTabText(value)
		end
	end)

	return obj
end

return module
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD07907ABC41A4351953E31EB5D579BA2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CurveUtil</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local CurveUtil = {	}
local DEFAULT_THRESHOLD = 0.01

function CurveUtil:Expt(start, to, pct, dt_scale)
	if math.abs(to - start) < DEFAULT_THRESHOLD then
		return to
	end

	local y = CurveUtil:Expty(start,to,pct,dt_scale)

	--rtv = start + (to - start) * timescaled_friction--
	local delta = (to - start) * y
	return start + delta
end

function CurveUtil:Expty(start, to, pct, dt_scale)
	--y = e ^ (-a * timescale)--
	local friction = 1 - pct
	local a = -math.log(friction)
	return 1 - math.exp(-a * dt_scale)
end

function CurveUtil:Sign(val)
	if val > 0 then
		return 1
	elseif val < 0 then
		return -1
	else
		return 0
	end
end

function CurveUtil:BezierValForT(p0, p1, p2, p3, t)
	local cp0 = (1 - t) * (1 - t) * (1 - t)
	local cp1 = 3 * t * (1-t)*(1-t)
	local cp2 = 3 * t * t * (1 - t)
	local cp3 = t * t * t
	return cp0 * p0 + cp1 * p1 + cp2 * p2 + cp3 * p3
end

CurveUtil._BezierPt2ForT = { x = 0; y = 0 }
function CurveUtil:BezierPt2ForT(
	p0x, p0y,
	p1x, p1y,
	p2x, p2y,
	p3x, p3y,
	t)

	CurveUtil._BezierPt2ForT.x = CurveUtil:BezierValForT(p0x,p1x,p2x,p3x,t)
	CurveUtil._BezierPt2ForT.y = CurveUtil:BezierValForT(p0y,p1y,p2y,p3y,t)
	return CurveUtil._BezierPt2ForT
end

function CurveUtil:YForPointOf2PtLine(pt1, pt2, x)
	--(y - y1)/(x - x1) = m--
	local m = (pt1.y - pt2.y) / (pt1.x - pt2.x)
	--y - mx = b--
	local b = pt1.y - m * pt1.x
	return m * x + b
end

function CurveUtil:DeltaTimeToTimescale(s_frame_delta_time)
	return s_frame_delta_time / (1.0 / 60.0)
end

function CurveUtil:SecondsToTick(sec)
	return (1 / 60.0) / sec
end

function CurveUtil:ExptValueInSeconds(threshold, start, seconds)
		return 1 - math.pow((threshold / start), 1 / (60.0 * seconds))
end

function CurveUtil:NormalizedDefaultExptValueInSeconds(seconds)
		return self:ExptValueInSeconds(DEFAULT_THRESHOLD, 1, seconds)
end

return CurveUtil
]]></ProtectedString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX4B8B58ADC1BB422F83F888285624A2E6">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DeveloperConsoleModule</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[-- Made by Tomarty (talk to me if you have questions)

-- Quick optimizations
local Instance_new = Instance.new
local UDim2_new = UDim2.new
local Color3_new = Color3.new
local math_max = math.max
local tick = tick
local pairs = pairs
local os_time = os.time

local DEBUG = false

local CoreGui = game:GetService('CoreGui')
local RobloxGui = CoreGui:FindFirstChild('RobloxGui')
local Modules = RobloxGui:FindFirstChild('Modules')

local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService('GuiService')
local isTenFootInterface = GuiService:IsTenFootInterface()

-- Eye candy uses RenderStepped
local EYECANDY_ENABLED = true

local ZINDEX = 6

local Style; do
	local function c3(r, g, b)
		return Color3_new(r / 255, g / 255, b / 255)
	end
	local frameColor = Color3_new(0.1, 0.1, 0.1)
	local textColor = Color3_new(1, 1, 1)
	local optionsFrameColor = Color3_new(1, 1, 1)
	
	pcall(function() -- Fun window colors for cool people
		local Players = game:GetService("Players")
		if not Players or not Players.LocalPlayer then
			return
		end
		local FunColors = {
			[56449]   = {c3(255, 63,  127)}; -- ReeseMcBlox
			[6949935] = {c3(255, 63,  127)}; -- NobleDragon
		}
		local funColor = FunColors[Players.LocalPlayer.userId]
		if funColor then
			frameColor = funColor[1] or frameColor
			textColor = funColor[2] or textColor
		end
	end)
	
	Style = {
		Font = Enum.Font.SourceSans;
		FontBold = Enum.Font.SourceSansBold;
		
		HandleHeight = 24; -- How tall the top window handle is, as well as the width of the scroll bar
		TabHeight = 28;
		GearSize = 24;
		BorderSize = 2;
		CommandLineHeight = 22;
		
		OptionAreaHeight = 56;
		
		FrameColor = frameColor; -- Applies to pretty much everything, including buttons
		FrameTransparency = 0.5;
		OptionsFrameColor = optionsFrameColor;
		
		TextColor = textColor;
		
		MessageColors = {
			[0] = Color3_new(1, 1, 1); -- Enum.MessageType.MessageOutput
			[1] = Color3_new(0.4, 0.5, 1); -- Enum.MessageType.MessageInfo
			[2] = Color3_new(1, 0.6, 0.4); -- Enum.MessageType.MessageWarning
			[3] = Color3_new(1, 0, 0); -- Enum.MessageType.MessageError
		};
		
		ScrollbarFrameColor = frameColor;
		ScrollbarBarColor = frameColor;
		
		ScriptButtonHeight = 32;
		ScriptButtonColor = Color3_new(0, 1/3, 2/3);
		ScriptButtonTransparency = 0.5;
		
		CheckboxSize = 24;
		
		ChartTitleHeight = 20;
		ChartGraphHeight = 64;
		ChartDataHeight = 24;
		ChartHeight = 0; -- This gets added up at end and set at end of block
		ChartWidth = 620;
		
		-- (-1) means right to left
		-- (1) means left to right
		ChartGraphDirection = 1; -- the direction the bars move
		
		
		GetButtonDownColor = function(normalColor)
			local r, g, b = normalColor.r, normalColor.g, normalColor.b
			return Color3_new(1 - 0.75 * (1 - r), 1 - 0.75 * (1 - g), 1 - 0.75 * (1 - b))
		end;
		GetButtonHoverColor = function(normalColor)
			local r, g, b = normalColor.r, normalColor.g, normalColor.b
			return Color3_new(1 - 0.875 * (1 - r), 1 - 0.875 * (1 - g), 1 - 0.875 * (1 - b))
		end;

	}
	
	Style.ChartHeight = Style.ChartTitleHeight + Style.ChartGraphHeight + Style.ChartDataHeight + Style.BorderSize

end

-- This provides an easy way to create GUI objects without writing insanely redundant code
local Primitives = {}; do
	local function new(className, parent, name)
		local n = Instance_new(className, parent)
		n.ZIndex = ZINDEX
		if name then
			n.Name = name
		end
		return n
	end
	local unitSize = UDim2_new(1, 0, 1, 0)
	
	local function setupFrame(n)
		n.BackgroundColor3 = Style.FrameColor
		n.BackgroundTransparency = Style.FrameTransparency
		n.BorderSizePixel = 0
	end
	local function setupText(n, text)
		n.Font = Style.Font
		n.TextColor3 = Style.TextColor
		n.Text = text or n.Text
	end
	
	function Primitives.Frame(parent, name)
		local n = new('Frame', parent, name)
		setupFrame(n)
		return n
	end
	function Primitives.TextLabel(parent, name, text)
		local n = new('TextLabel', parent, name)
		setupFrame(n)
		setupText(n, text)
		return n
	end
	function Primitives.TextBox(parent, name, text)
		local n = new('TextBox', parent, name)
		setupFrame(n)
		setupText(n, text)
		return n
	end
	function Primitives.TextButton(parent, name, text)
		local n = new('TextButton', parent, name)
		setupFrame(n)
		setupText(n, text)
		return n
	end
	function Primitives.Button(parent, name)
		local n = new('TextButton', parent, name)
		setupFrame(n)
		n.Text = ""
		return n
	end
	function Primitives.ImageButton(parent, name, image)
		local n = new('ImageButton', parent, name)
		setupFrame(n)
		n.Image = image or ""
		n.Size = unitSize
		return n
	end
	
	-- An invisible frame of size (1, 0, 1, 0)
	function Primitives.FolderFrame(parent, name) -- Should this be called InvisibleFrame? lol
		local n = new('Frame', parent, name)
		n.BackgroundTransparency = 1
		n.Size = unitSize
		return n
	end
	function Primitives.InvisibleTextLabel(parent, name, text)
		local n = new('TextLabel', parent, name)
		setupText(n, text)
		n.BackgroundTransparency = 1
		return n
	end
	function Primitives.InvisibleButton(parent, name, text)
		local n = new('TextButton', parent, name)
		n.BackgroundTransparency = 1
		n.Text = ""
		return n
	end
	function Primitives.InvisibleImageLabel(parent, name, image)
		local n = new('ImageLabel', parent, name)
		n.BackgroundTransparency = 1
		n.Image = image or ""
		n.Size = unitSize
		return n
	end
end

local CreateSignal = assert(LoadLibrary('RbxUtility')).CreateSignal

-- This is a Signal that only calls once, then forgets about the function. It also accepts event listeners as functions
local CreateDisconnectSignal; do
	local Methods = {}
	local Metatable = {__index = Methods}
	function Methods.fire(this, ...)
		return this.Signal:fire(...)
	end
	function Methods.wait(this, ...)
		return this.Signal:wait(...)
	end
	function Methods.connect(this, func)
		local t = type(func)
		if t == 'table' or t == 'userdata' then
			-- Got event listener
			local listener = func
			function func()
				listener:disconnect()
			end
		elseif t ~= 'function' then
			error('Invalid disconnect method type: ' .. t, 2)
		end

		local listener;
		listener = this.Signal:connect(function(...)
			if listener then
				listener:disconnect()
				listener = nil
				func(...)
			end
		end)
		return listener
	end
	function CreateDisconnectSignal()
		return setmetatable({
			Signal = CreateSignal();
		}, Metatable)
	end
end

-- Services
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local TouchEnabled = UserInputService.TouchEnabled

local DeveloperConsole = {}

local Methods = {}
local Metatable = {__index = Methods}

-------------------------
-- Listener management --
-------------------------
function Methods.ConnectSetVisible(devConsole, func)
	-- This is used mainly for pausing rendering and stuff when the console isn't visible
	func(devConsole.Visible)
	return devConsole.VisibleChanged:connect(function(visible)
		func(visible)
	end)
end
function Methods.ConnectObjectSetVisible(devConsole, object, func)
	-- Same as above, but used for calling methods like object:SetVisible()
	func(object, devConsole.Visible)
	return devConsole.VisibleChanged:connect(function(visible)
		func(object, visible)
	end)
end

-----------------------------
-- Frame/Window Dimensions --
-----------------------------

local function connectPropertyChanged(object, property, callback)
	return object.Changed:connect(function(propertyChanged)
		if propertyChanged == property then
			callback(object[property])
		end
	end)
end

function Methods.ResetFrameDimensions(devConsole)
	devConsole.Frame.Size = UDim2_new(0.5, 20, 0.5, 20);
	
	local abSize = devConsole.Frame.AbsoluteSize
	devConsole:SetFrameSize(abSize.x, abSize.y)
	local newSize = devConsole.Frame.Size
	devConsole.Frame.Position = UDim2_new(0.5, -newSize.X.Offset/2, 0.5, -newSize.Y.Offset/2)
end
function Methods.BoundFrameSize(devConsole, x, y)
	-- Minimum frame size
	return math_max(x, 400), math_max(y, 200)
end
function Methods.SetFrameSize(devConsole, x, y)
	x, y = devConsole:BoundFrameSize(x, y)
	devConsole.Frame.Size = UDim2_new(0, x, 0, y)
end
function Methods.BoundFramePosition(devConsole, x, y)
	-- Make sure the frame doesn't go somewhere where the bar can't be clicked
	return x, math_max(y, 0)
end
function Methods.SetFramePosition(devConsole, x, y)
	x, y = devConsole:BoundFramePosition(x, y)
	devConsole.Frame.Position = UDim2_new(0, x, 0, y)
end

-- Open/Close the console
function Methods.SetVisible(devConsole, visible, animate)
	if devConsole.Visible == visible then
		return
	end
	devConsole.Visible = visible
	devConsole.VisibleChanged:fire(visible)
	if devConsole.Frame then
		devConsole.Frame.Visible = visible
	end	
	if visible then -- Open the console
		devConsole:ResetFrameDimensions()
	end
end

-----------------
-- Constructor --
-----------------
function DeveloperConsole.new(screenGui, permissions, messagesAndStats)

	local visibleChanged = CreateSignal()
	
	local devConsole = {
		ScreenGui = screenGui;
		Permissions = permissions;
		MessagesAndStats = messagesAndStats;
		Initialized = false;
		Visible = false;
		Tabs = {};
		CurrentOpenedTab = nil;	-- save last tab opened to set SelectedCoreObject for TenFootInterfaces
		VisibleChanged = visibleChanged; -- Created by :Initialize(); It's used to stop and disconnect things when the window is hidden
	}
	
	setmetatable(devConsole, Metatable)

	devConsole:EnableGUIMouse()
	
	-- It's a button so it catches mouse events
	local frame = Primitives.Button(screenGui, 'DeveloperConsole')
	frame.AutoButtonColor = false
	--frame.ClipsDescendants = true
	frame.Visible = devConsole.Visible
	frame.Selectable = not isTenFootInterface
	devConsole.Frame = frame
	devConsole:ResetFrameDimensions()
	
	-- The bar at the top that you can drag around
	local handle = Primitives.Button(frame, 'Handle')
	handle.Size = UDim2_new(1, -(Style.HandleHeight + Style.BorderSize), 0, Style.HandleHeight)
	handle.Selectable = not isTenFootInterface
	handle.Modal = true -- Unlocks mouse
	handle.AutoButtonColor = false
	
	
	do -- Title
		local title = Primitives.InvisibleTextLabel(handle, 'Title', "ROBLOX Developer Console")
		title.Size = UDim2_new(1, -5, 1, 0)
		title.Position = UDim2_new(0, 5, 0, 0)	
		title.FontSize = Enum.FontSize.Size18
		title.TextXAlignment = Enum.TextXAlignment.Left
	end
	
	local function setCornerButtonImageSize(buttonImage, buttonImageSize)
		buttonImage.Size = UDim2_new(buttonImageSize, 0, buttonImageSize, 0)
		buttonImage.Position = UDim2_new((1 - buttonImageSize) / 2, 0, (1 - buttonImageSize) / 2, 0)		
	end
	-- This is used for creating the square exit button and the square window resize button
	local function createCornerButton(name, x, y, image, buttonImageSize)
		-- Corners (x, y):
		-- (0, 0) (1, 0)
		-- (0, 1) (1, 1)
		
		local button = Primitives.Button(frame, name)
		button.Size = UDim2_new(0, Style.HandleHeight, 0, Style.HandleHeight)
		button.Position = UDim2_new(x, -x * Style.HandleHeight, y, -y * Style.HandleHeight)
		
		local buttonImage = Primitives.InvisibleImageLabel(button, 'Image', image)
		setCornerButtonImageSize(buttonImage, buttonImageSize)
		
		return button, buttonImage
	end
	
	do -- Create top right exit button
		local exitButton, exitButtonImage = createCornerButton('Exit', 1, 0, 'https://www.roblox.com/asset/?id=261878266', 2/3)
		exitButton.AutoButtonColor = false
		exitButton.Visible = not isTenFootInterface
		exitButton.Selectable = not isTenFootInterface
		
		local buttonEffectFunction = devConsole:CreateButtonEffectFunction(exitButton)
		
		devConsole:ConnectButtonHover(exitButton, function(clicking, hovering)
			if hovering and not clicking then
				setCornerButtonImageSize(exitButtonImage, 3/4)
			else
				setCornerButtonImageSize(exitButtonImage, 2/3)
			end
			buttonEffectFunction(clicking, hovering)
		end)
		
		exitButton.MouseButton1Click:connect(function()
			devConsole:SetVisible(false, true)
		end)
	end
	
	do -- Repositioning and Resizing
		
		do -- Create bottom right window resize button and activate resize dragging
			local resizeButton, resizeButtonImage = createCornerButton('Resize', 1, 1, 'https://www.roblox.com/asset/?id=261880743', 1)
			resizeButtonImage.Position = UDim2_new(0, 0, 0, 0)
			resizeButtonImage.Size = UDim2_new(1, 0, 1, 0)
			resizeButton.Selectable = not isTenFootInterface

			local dragging = false
			
			local buttonEffectFunction = devConsole:CreateButtonEffectFunction(resizeButton)
			
			devConsole:ConnectButtonDragging(resizeButton, function()
				local x0, y0 = frame.AbsoluteSize.X, frame.AbsoluteSize.Y
				return function(dx, dy)
					devConsole:SetFrameSize(x0 + dx, y0 + dy)
				end
			end, function(clicking, hovering)
				dragging = clicking
				buttonEffectFunction(clicking, hovering)
			end)
			
		end
		
		do -- Activate top handle dragging
			local frame = devConsole.Frame
			local handle = frame.Handle
			
			local buttonEffectFunction = devConsole:CreateButtonEffectFunction(handle)
			
			devConsole:ConnectButtonDragging(handle, function()
				local x, y = frame.AbsolutePosition.X, frame.AbsolutePosition.Y
				return function(dx, dy)
					devConsole:SetFramePosition(x + dx, y + dy)
				end
				--deltaCallback_Resize(-dx, -dy) -- Used if they are grabbing both at the same time
			end, buttonEffectFunction)
		end
	end
	
	-- interiorFrame contains tabContainer and window
	local interiorFrame = Primitives.FolderFrame(frame, 'Interior')
	interiorFrame.Position = UDim2_new(0, 0, 0, Style.HandleHeight)
	interiorFrame.Size = UDim2_new(1, -(Style.HandleHeight + Style.BorderSize * 2), 1, -(Style.HandleHeight + Style.BorderSize))
	
	local windowContainer = Primitives.FolderFrame(interiorFrame, 'WindowContainer')
	windowContainer.Size = UDim2_new(1, 0, 1, -(Style.TabHeight))
	windowContainer.Position = UDim2_new(0, Style.BorderSize, 0, Style.TabHeight)
	
	-- This is what applies ClipsDescendants to tab contents
	local window = Primitives.Frame(windowContainer, 'Window')
	window.Size = UDim2_new(1, 0, 1, 0) -- The tab open/close methods, and the consoles also set this
	window.Position = UDim2_new(0, 0, 0, 0)
	window.ClipsDescendants = true
	
	-- This is the frame that moves around with the scroll bar
	local body = Primitives.FolderFrame(window, 'Body')
	
	do -- Scrollbars
		local scrollbar = devConsole:CreateScrollbar()
		devConsole.WindowScrollbar = scrollbar
		local scrollbarFrame = scrollbar.Frame
		scrollbarFrame.Parent = frame
		scrollbarFrame.Size = UDim2_new(0, Style.HandleHeight, 1, -(Style.HandleHeight + Style.BorderSize) * 2)
		scrollbarFrame.Position = UDim2_new(1, -Style.HandleHeight, 0, Style.HandleHeight + Style.BorderSize)
		
		devConsole:ApplyScrollbarToFrame(scrollbar, window, body, frame)
	end
	
	local tabContainer = Primitives.FolderFrame(interiorFrame, 'Tabs') -- Shouldn't this be named 'tabFrame'?
	tabContainer.Size = UDim2_new(1, -(Style.GearSize + Style.BorderSize), 0, Style.TabHeight)
	tabContainer.Position = UDim2_new(0, 0, 0, 0)
	tabContainer.ClipsDescendants = true
	
	-- Options button
	local optionsButton = Primitives.InvisibleButton(frame, 'OptionsButton')
	
	local optionsClippingFrame = Primitives.FolderFrame(interiorFrame, 'OptionsClippingFrame')
	optionsClippingFrame.ClipsDescendants = true
	optionsClippingFrame.Position = UDim2_new(0, 0, 0, 0)
	optionsClippingFrame.Size = UDim2_new(1, 0, 0, 0)
	local optionsFrame = Primitives.FolderFrame(optionsClippingFrame, 'OptionsFrame')
	optionsFrame.Size = UDim2_new(1, 0, 0, Style.OptionAreaHeight)
	optionsFrame.Position = UDim2_new(0, 0, 0, Style.OptionAreaHeight)
	--optionsFrame.BackgroundColor3 = Style.OptionsFrameColor
	do -- Options animation
		
		local gearSize = Style.GearSize
		local tabHeight = Style.TabHeight
		local offset = (tabHeight - gearSize) / 2
		optionsButton.Size = UDim2_new(0, Style.GearSize, 0, Style.GearSize)
		optionsButton.Position = UDim2_new(1, -(Style.GearSize + offset + Style.HandleHeight), 0, Style.HandleHeight + offset)
		local gear = Primitives.InvisibleImageLabel(optionsButton, 'Image', 'https://www.roblox.com/asset/?id=261882463')
		--gear.ZIndex = ZINDEX + 1
		local animationToggle = devConsole:GenerateOptionButtonAnimationToggle(interiorFrame, optionsButton, gear, tabContainer, optionsClippingFrame, optionsFrame)
		local open = false
		optionsButton.MouseButton1Click:connect(function()
			open = not open
			animationToggle(open)
		end)
		
	end
	
	-- Console/Log and Stats options
	local setShownOptionTypes; -- Toggles what options to show: setOptionType({Log = true})
	
	local textFilter, scriptStatFilter;
	local textFilterChanged, scriptStatFilterChanged;
	
	local messageFilter;
	local messageFilterChanged, messageTextWrappedChanged;
	do -- Options contents/filters
		
		local function createCheckbox(color, callback)
			local this = {
				Value = true;
			}
			
			local frame = Primitives.FolderFrame(nil, 'Checkbox')
			this.Frame = frame
			frame.Size = UDim2_new(0, Style.CheckboxSize, 0, Style.CheckboxSize)
			frame.BackgroundColor3 = color
			
			local padding = 2
			
			local function f(xs, xp, yp) -- quick way to get an opaque border around a transparent center
				local ys = 1 - xs
				local f = Primitives.Frame(frame, 'Border')
				f.BackgroundColor3 = color
				f.BackgroundTransparency = 0
				f.Size = UDim2_new(xs, ys * padding, ys, xs * padding)
				f.Position = UDim2_new(xp, -xp * padding, yp, -yp * padding)
			end
			f(1, 0, 0)
			f(1, 0, 1)
			f(0, 0, 0)
			f(0, 1, 0)
			
			local button = Primitives.Button(frame, 'Button')
			button.Size = UDim2_new(1, -padding * 2, 1, -padding * 2)
			button.Position = UDim2_new(0, padding, 0, padding)
			
			local buttonEffectFunction = devConsole:CreateButtonEffectFunction(button)
			
			local check = Primitives.Frame(button, 'Check')
			
			local padding = 4
			check.Size = UDim2_new(1, -padding * 2, 1, -padding * 2)
			check.Position = UDim2_new(0, padding, 0, padding)
			check.BackgroundColor3 = color
			check.BackgroundTransparency = 0
			
			devConsole:ConnectButtonHover(button, buttonEffectFunction)
			
			function this.SetValue(this, value)
				if value == this.Value then
					return
				end
				this.Value = value
				check.Visible = value
				this.Value = value
				callback(value)
			end
			
			button.MouseButton1Click:connect(function()
				this:SetValue(not this.Value)
			end)
			
			return this
		end
		
		local string_find = string.find
		local containsString; -- the text typed into the search textBox, nil if equal to ""
		
		function textFilter(text)
			return not containsString or string_find(text:lower(), containsString)
		end
		
		local filterLookup = {} -- filterLookup[Enum.MessageType.x.Value] = true or false
		function messageFilter(message)
			return filterLookup[message.Type] and (not containsString or string_find(message.Message:lower(), containsString))
		end
		
		-- Events
		textFilterChanged = CreateSignal()
		scriptStatFilterChanged = CreateSignal()
		
		messageFilterChanged = CreateSignal()
		messageTextWrappedChanged = CreateSignal()
		
		local optionTypeContainers = {
			--[OptionType] = Frame
			--Log = Frame;
			--Scripts = Frame;
		}
		function setShownOptionTypes(shownOptionTypes)
			-- Example showOptionTypes:
			-- {Log = true}
			for optionType, container in pairs(optionTypeContainers) do
				container.Visible = shownOptionTypes[optionType] or false
			end
		end
		
		do -- Log options
			local container = Primitives.FolderFrame(optionsFrame, 'Log')
			container.Visible = false
			optionTypeContainers.Log = container

			local label = Primitives.InvisibleTextLabel(container, 'FilterLabel', "Filters")
			label.FontSize = 'Size18'
			label.TextXAlignment = 'Left'
			label.Size = UDim2_new(0, 54, 0, Style.CheckboxSize)
			label.Position = UDim2_new(0, 4, 0, 2)
	
			do
				local x = label.Size.X.Offset
				local messageColors = Style.MessageColors
				for i = 0, #messageColors do -- 0, 3 initially
					local checkbox = createCheckbox(messageColors[i], function(value)
						filterLookup[i] = value
						messageFilterChanged:fire()
					end)
					filterLookup[i] = checkbox.Value
					checkbox.Frame.Parent = container
					checkbox.Frame.Position = UDim2_new(0, x, 0, 4)
					x = x + Style.CheckboxSize + 4
				end
				
				do -- Word wrap
					x = x + 8
					
					local label = Primitives.InvisibleTextLabel(container, 'WrapLabel', "Word Wrap")
					label.FontSize = 'Size18'
					label.TextXAlignment = 'Left'
					label.Size = UDim2_new(0, 54 + Style.CheckboxSize, 0, Style.CheckboxSize)
					label.Position = UDim2_new(0, x + 4, 0, 2)
					
					local checkbox = createCheckbox(Color3.new(0.65, 0.65, 0.65), function(value)
						messageTextWrappedChanged:fire(value) -- an event isn't ideal here
					end)
					checkbox:SetValue(false)
					checkbox.Frame.Parent = container
					checkbox.Frame.Position = UDim2_new(0, x + label.Size.X.Offset, 0, 4)
				end
			end
		end
		
		do -- Scripts options
			local container = Primitives.FolderFrame(optionsFrame, 'Stats')
			container.Visible = false
			optionTypeContainers.Scripts = container

			do
				local x = 0
				
				do -- Show inactive
					x = x + 4
					local label = Primitives.InvisibleTextLabel(container, 'FilterLabel', "Show inactive")
					label.FontSize = 'Size18'
					label.TextXAlignment = 'Left'
					label.Size = UDim2_new(0, label.TextBounds.X + 6, 0, Style.CheckboxSize)
					label.Position = UDim2_new(0, x, 0, 2)
					x = x + label.Size.X.Offset
					
					local showInactive;
					local function getScriptCurrentlyActive(chartStat)
						local stats = chartStat.Stats
						if stats then
							local stat = stats[#stats]
							if stat then
								return stat[1] > 0.000001 or stat[2] > 0.000001
							end
						end
						return false
					end
					function scriptStatFilter(chartStat)
						return (showInactive or getScriptCurrentlyActive(chartStat))
							and (not containsString or string_find(chartStat.Name:lower(), containsString))
					end
						
					local checkbox = createCheckbox(Color3_new(1, 1, 1), function(value)
						showInactive = value
						scriptStatFilterChanged:fire()
					end)
					showInactive = checkbox.Value
					checkbox.Frame.Parent = container
					checkbox.Frame.Position = UDim2_new(0, x, 0, 4)
					x = x + Style.CheckboxSize + 4
				
				end

				x = x + 8
				
				--[[
				local label = Primitives.InvisibleTextLabel(container, 'WrapLabel', "Word Wrap")
				label.FontSize = 'Size18'
				label.TextXAlignment = 'Left'
				label.Size = UDim2_new(0, 54 + Style.CheckboxSize, 0, Style.CheckboxSize)
				label.Position = UDim2_new(0, x + 4, 0, 2)
				
				local checkbox = createCheckbox(Color3.new(0.65, 0.65, 0.65), function(value)
					messageTextWrappedChanged:fire(value)
				end)
				checkbox:SetValue(false)
				checkbox.Frame.Parent = container
				checkbox.Frame.Position = UDim2_new(0, x + label.Size.X.Offset, 0, 4)
				--]]
			end
		end
		
		do -- Search/filter/contains textbox
			
			local label = Primitives.InvisibleTextLabel(optionsFrame, 'FilterLabel', "Contains:")
			label.FontSize = 'Size18'
			label.TextXAlignment = 'Left'
			label.Size = UDim2_new(0, 60, 0, Style.CheckboxSize)
			label.Position = UDim2_new(0, 4, 0, 4 + Style.CheckboxSize + 4)
			
			local textBox = Primitives.TextBox(optionsFrame, 'ContainsFilter')
			textBox.ClearTextOnFocus = true
			textBox.FontSize = 'Size18'
			textBox.TextXAlignment = 'Left'
			textBox.Size = UDim2_new(0, 150, 0, Style.CheckboxSize)
			textBox.Position = UDim2_new(0, label.Position.X.Offset + label.Size.X.Offset + 4, 0, 4 + Style.CheckboxSize + 4)
			textBox.Text = ""
		
			local runningColor = Color3.new(0, 0.5, 0)
			local normalColor = textBox.BackgroundColor3
			
			connectPropertyChanged(textBox, 'Text', function(text)
				text = text:lower()
				if text == "" then
					text = nil
				end
				if text == containsString then
					return
				end
				textBox.BackgroundColor3 = text and runningColor or normalColor
				containsString = text
				messageFilterChanged:fire()
				textFilterChanged:fire()
			end)
			
			connectPropertyChanged(textBox, 'TextBounds', function(textBounds)
				textBox.Size = UDim2_new(0, math.max(textBounds.X, 150), 0, Style.CheckboxSize)
			end)
		end
	end
	
	----------
	-- Tabs --
	----------
	do -- Console/Log tabs
		
		-- Wrapper for :AddTab
		local function createConsoleTab(name, text, width, outputMessageSync, commandLineVisible, commandInputtedCallback, openCallback)
			local tabBody = Primitives.FolderFrame(body, name)
			local output, commandLine;
			local disconnector = CreateDisconnectSignal()
			
			local tab = devConsole:AddTab(text, width, tabBody, function(open)
				if commandLine then
					commandLine.Frame.Visible = open
				end
				
				if open then
					
					setShownOptionTypes({
						Log = true;
					})
					
					if not output then
						output = devConsole:CreateOutput(outputMessageSync:GetMessages(), messageFilter)
						output.Frame.Parent = tabBody
					end
					
					output:SetVisible(true)
					
					if commandLineVisible then
						if open and not commandLine then
							commandLine = devConsole:CreateCommandLine()
							commandLine.Frame.Parent = frame
							commandLine.Frame.Size = UDim2_new(1, -(Style.HandleHeight + Style.BorderSize * 2), 0, Style.CommandLineHeight)
							commandLine.Frame.Position = UDim2_new(0, Style.BorderSize, 1, -(Style.CommandLineHeight + Style.BorderSize))
							commandLine.CommandInputted:connect(commandInputtedCallback)
						end
					end

					window.Size = commandLineVisible
						and UDim2_new(1, 0, 1, -(Style.HandleHeight))
						or  UDim2_new(1, 0, 1, 0)

					
					local messages = outputMessageSync:GetMessages()
					
					local height = output:RefreshMessages()
					body.Size = UDim2_new(1, 0, 0, height)
					
					disconnector:connect(output.HeightChanged:connect(function(height)
						body.Size = UDim2_new(1, 0, 0, height)
					end))
					body.Size = UDim2_new(1, 0, 0, output.Height)
					
					disconnector:connect(outputMessageSync.MessageAdded:connect(function(message)
						output:RefreshMessages(#messages)
					end))
					
					disconnector:connect(messageFilterChanged:connect(function()
						output:RefreshMessages()
					end))
					disconnector:connect(messageTextWrappedChanged:connect(function(enabled)
						output:SetTextWrappedEnabled(enabled)
					end))
				else
					if output then
						output:SetVisible(false)
					end
					window.Size = UDim2_new(1, 0, 1, 0)
					disconnector:fire()
				end
				if openCallback then
					openCallback(open)
				end
			end)

			return tab
		end
		
		-- Local Log tab --
		if permissions.MayViewClientLog then
			local tab = createConsoleTab(
				'LocalLog', "Local Log", 60,
				devConsole.MessagesAndStats.OutputMessageSyncLocal,
				permissions.ClientCodeExecutionEnabled
			)
			tab:SetVisible(true)
			tab:SetOpen(true)
		end
		
		-- Server Log tab --
		if permissions.MayViewServerLog then
			local LogService = game:GetService('LogService')
			local tab = createConsoleTab(
				'ServerLog', "Server Log", 70,
				devConsole.MessagesAndStats.OutputMessageSyncServer,
				permissions.ServerCodeExecutionEnabled,
				function(text)
					if #text <= 1 then
						return
					end
					if permissions.ServerCodeExecutionEnabled then
						-- print("Server Loadstring:", text)
						LogService:ExecuteScript(text)
					end
				end
			)
			tab:SetVisible(true)
		end
	end
	
	do -- Stats tabs
		
		local function generateGreenYellowRedColor(unit) -- 0 <= unit <= 1
			--[[
				0   -> 0,   223, 0
				0.5 -> 223, 233, 0
				1   -> 233, 0,   0
			--]]
			local brightness = 0.9
			if not unit then
				return Color3.new(0, 0, 0)
			elseif unit <= 0 then
				return Color3.new(1, 1, 1)
			elseif unit <= 0.5 then
				unit = unit * 2
				return Color3.new(unit * brightness, brightness, 0)
			elseif unit <= 1 then
				unit = unit * 2 - 1
				return Color3.new(brightness, (1 - unit) * brightness, 0)
			else
				return Color3.new(1, 0, 0)
			end
		end
		
		-- Wrapper for :AddTab
		local function createStatsTab(name, text, width, config, openCallback, filterStats, shownOptionTypes)
			local statsSyncServer = devConsole.MessagesAndStats.StatsSyncServer
			
			local open = false
			
			local statList = devConsole:CreateChartList(config)
			
			local tabBody = statList.Frame
			tabBody.Parent = body
			tabBody.Name = name
			tabBody.BackgroundTransparency = 1
			tabBody.Size = UDim2_new(1, 0, 1, 0)
			statList.SideMenu.Parent = windowContainer -- so the left side menu doesn't resize with the contents on right
			
			statsSyncServer:GetStats()
			statsSyncServer.StatsReceived:connect(function(stats)
				local statsFiltered = filterStats(stats)
				if statsFiltered then
					statList:UpdateStats(statsFiltered)
				end
			end)
			
			local tab = devConsole:AddTab(text, width, tabBody, function(openNew)
				open = openNew
				if open then
					devConsole.WindowScrollbar:SetValue(0)
					setShownOptionTypes(shownOptionTypes)
				end
				statList:SetVisible(open)
				if openCallback then
					openCallback(open)
				end
			end)
			tab:SetVisible(true)
			
			return tab, statList
		end
		
		-- Server Scripts --
		if permissions.MayViewServerScripts then
			
			local open = false
			
			local config = {
				GetNotifyColor = function(chartButton)
					local chartStat = chartButton.ChartStat
					local point;
					local stat = chartStat.Stats[#chartStat.Stats]
					if stat then
						point = stat[1]
						local freq = stat[2]
						if point and freq then
							point = (point < 0 and 0) or (point > 1 and 1) or point -- clamp between 0 and 1
							point = math.max(freq > 0 and 0.000001 or 0, point ^ (1/4))
						end
					end
					return generateGreenYellowRedColor(point)
				end;
				CreateChartPage = function(chartButton, statsBody)
					local chartStat = chartButton.ChartStat
					local chart1 = devConsole:CreateChart(chartStat.Stats, "Script Activity", 1, function(point)
						return point and math.ceil(point * 100000 * 100) / 100000 .. "%" or ""
					end)
					local chart2 = devConsole:CreateChart(chartStat.Stats, "Script Rate", 2, function(point)
						return point and (math.floor(point * 100000) / 100000) .. "/s" or ""
					end)
					
					local y = 16
					chart1.Frame.Parent = statsBody
					chart1.Frame.Position = UDim2_new(0, 16, 0, y)
					y = y + 16 + chart1.Frame.Size.Y.Offset
					
					chart2.Frame.Parent = statsBody
					chart2.Frame.Position = UDim2_new(0, 16, 0, y)
					y = y + 16 + chart2.Frame.Size.Y.Offset
					
					local this = {}
					function this.OnPointAdded(this)
						chart1:OnPointAdded()
						chart2:OnPointAdded()
					end
					function this.SetVisible(this, visible)
						chart1:SetVisible(visible)
						chart2:SetVisible(visible)
						body.Size = open and UDim2_new(1, 0, 0, y) or UDim2_new(1, 0, 1, 0)
					end
					function this.Dispose(this)
						this:SetVisible(false)
					end
					return this
				end;
				FilterButton = function(chartButton)
					return scriptStatFilter(chartButton.ChartStat)
				end;
			}

			local function filterStats(stats)
				-- return stats.Scripts
				if stats.Scripts then
					local statsFiltered = {}
					for k, v in pairs(stats.Scripts) do
						statsFiltered[k] = {v[1]/100, v[2]}
					end
					return statsFiltered
				end
			end

			local function openCallback(openNew)
				open = openNew
			end
			
			local tab, statList = createStatsTab('ServerScripts', "Server Scripts", 80, config, openCallback, filterStats, {Scripts = true})

			textFilterChanged:connect(function()
				statList:Refresh()
			end)
			scriptStatFilterChanged:connect(function()
				statList:Refresh()
			end)

			tab:SetVisible(true)
		end
		
		-- Server Stats --
		if permissions.MayViewServerStats then

			local open = false
			
			local config = {
				GetNotifyColor = function(chartButton)
					return Color3.new(0.5, 0.5, 0.5)
				end;
				CreateChartPage = function(chartButton, statsBody)
					local chartStat = chartButton.ChartStat
					local chart1 = devConsole:CreateChart(chartStat.Stats, chartStat.Name, 1)
					
					local y = 16
					chart1.Frame.Parent = statsBody
					chart1.Frame.Position = UDim2_new(0, 16, 0, y)
					y = y + 16 + chart1.Frame.Size.Y.Offset

					local this = {}
					function this.OnPointAdded(this)
						chart1:OnPointAdded()
					end
					function this.SetVisible(this, visible)
						chart1:SetVisible(visible)
						body.Size = open and UDim2_new(1, 0, 0, y) or UDim2_new(1, 0, 1, 0)
					end
					function this.Dispose(this)
						this:SetVisible(false)
					end
					return this
				end;
				FilterButton = function(chartButton)
					return textFilter(chartButton.ChartStat.Name)
				end;
			}
			
			local function filterStats(stats)
				local statsFiltered = {}
				for k, v in pairs(stats) do
					if type(v) == 'number' then
						statsFiltered[k] = {v}
					end
				end
				return statsFiltered
			end
			
			local function openCallback(openNew)
				open = openNew
			end

			local tab, statList = createStatsTab('ServerStats', "Server Stats", 70, config, openCallback, filterStats, {Stats = true})
			
			textFilterChanged:connect(function()
				statList:Refresh()
			end)
						
			tab:SetVisible(true)
		end	

		-- Server Jobs --
		if permissions.MayViewServerJobs then

			local open = false
			
			local config = {
				GetNotifyColor = function(chartButton)
					return Color3.new(0.5, 0.5, 0.5)
				end;
				CreateChartPage = function(chartButton, statsBody)
					local chartStat = chartButton.ChartStat
					local chart1 = devConsole:CreateChart(chartStat.Stats, "Duty Cycle", 1, function(point)
						return point and math.floor(point * 10000000 + 0.5) / 100000 .. "%" or ""
					end)
					local chart2 = devConsole:CreateChart(chartStat.Stats, "Steps Per Sec", 2, function(point)
						return point and (math.floor(point * 10000 + 0.5) / 10000) .. "/s" or ""
					end)
					local chart3 = devConsole:CreateChart(chartStat.Stats, "Step Time", 3, function(point)
						return point and (math.floor(point * 10000000 + 0.5) / 10000) .. "ms" or ""
					end)
					
					local y = 16
					chart1.Frame.Parent = statsBody
					chart1.Frame.Position = UDim2_new(0, 16, 0, y)
					y = y + 16 + chart1.Frame.Size.Y.Offset
					
					chart2.Frame.Parent = statsBody
					chart2.Frame.Position = UDim2_new(0, 16, 0, y)
					y = y + 16 + chart2.Frame.Size.Y.Offset
					
					chart3.Frame.Parent = statsBody
					chart3.Frame.Position = UDim2_new(0, 16, 0, y)
					y = y + 16 + chart3.Frame.Size.Y.Offset
					
					local this = {}
					function this.OnPointAdded(this)
						chart1:OnPointAdded()
						chart2:OnPointAdded()
						chart3:OnPointAdded()
					end
					function this.SetVisible(this, visible)
						chart1:SetVisible(visible)
						chart2:SetVisible(visible)
						chart3:SetVisible(visible)
						body.Size = open and UDim2_new(1, 0, 0, y) or UDim2_new(1, 0, 1, 0)
					end
					function this.Dispose(this)
						this:SetVisible(false)
					end
					return this
				end;
				FilterButton = function(chartButton)
					return textFilter(chartButton.ChartStat.Name)
				end;
			}		
			
			local function filterStats(stats)
				return stats.Jobs
			end

			local function openCallback(openNew)
				open = openNew
			end
			
			local tab, statList = createStatsTab('ServerJobs', "Server Jobs", 70, config, openCallback, filterStats, {Stats = true})
			
			textFilterChanged:connect(function()
				statList:Refresh()
			end)
			
			tab:SetVisible(true)
		end
	end
	
	--[[
	do -- Sample tab
		local tabBody = Primitives.FolderFrame(body, 'TabName')
		
		-- 80 is the tab width
		local tab = devConsole:AddTab("Tab Name", 80, tabBody)
		tab:SetVisible(true)
		--tab:SetOpen(true)
	end
	--]]
	
	return devConsole
	
end

----------------------
-- Backup GUI Mouse --
----------------------
do -- This doesn't support multiple windows very well
	function Methods.EnableGUIMouse(devConsole)
		local label = Instance.new("ImageLabel")
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Size = UDim2.new(0, 64, 0, 64)
		label.Image = "rbxasset://Textures/ArrowFarCursor.png"
		label.Name = "BackupMouse"
		label.ZIndex = ZINDEX + 2
		
		local disconnector = CreateDisconnectSignal()
		
		local enabled = false
		
		local mouse = game:GetService("Players").LocalPlayer:GetMouse()
		
		local function Refresh()
			local enabledNew = devConsole.Visible and not UserInputService.MouseIconEnabled
			if enabledNew == enabled then
				return
			end
			enabled = enabledNew
			label.Visible = enabled
			label.Parent = enabled and devConsole.ScreenGui or nil
			disconnector:fire()
			if enabled then
				label.Position = UDim2.new(0, mouse.X - 32, 0, mouse.Y - 32)
				disconnector:connect(UserInputService.InputChanged:connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						--local p = input.Position
						--if p then
						label.Position = UDim2.new(0, mouse.X - 32, 0, mouse.Y - 32)
						--end
					end
				end))
			end
		end
		
		Refresh()
		local userInputServiceListener;
		devConsole.VisibleChanged:connect(function(visible)
			if userInputServiceListener then
				userInputServiceListener:disconnect()
				userInputServiceListener = nil
			end
			
			userInputServiceListener = UserInputService.Changed:connect(Refresh)
			
			Refresh()
		end)
		
	end
end


----------------------
-- Charts and Stats --
----------------------


do -- Script performance/Chart list
	
	--[[
	local chartStatExample = {
		Name = "RoundScript";
		Stats = {
			-- {Activity, InvocationCount}
			{0, 0};
			{0, 0};
		}
	}
	--]]
	
	-- this manages the button and the chartPage
	local function createChartButton(devConsole, chartList, chartStat, config)
		
		local this = {
			ChartList = chartList;
			ChartStat = chartStat;
			Open = false;
		}
		
		local button = Primitives.Button(nil, 'Button')
		this.Frame = button
		this.Button = button
		
		button.AutoButtonColor = false
		local size0 = UDim2_new(1, -12 - chartList.ScrollingFrame.ScrollBarThickness, 0, 16) -- Size when script is closed
		local size1 = UDim2_new(1, -2  - chartList.ScrollingFrame.ScrollBarThickness, 0, 16) -- Size when script is open
		button.Size = size0
		button.Name = (chartStat.Name or "[no name]")
		if not chartStat.Name then
			button.TextColor3 = Color3.new(1, 0.5, 0.5)
		end
		button.BackgroundColor3 = Style.ScriptButtonColor
		button.BackgroundTransparency = Style.ScriptBackgroundTransparency
		
		local notifyFrame = Primitives.Frame(button, 'NotifyFrame')
		notifyFrame.BackgroundTransparency = 0
		notifyFrame.Size = UDim2.new(0, 8, 1, 0)
		notifyFrame.BackgroundColor3 = Color3.new(0, 0.75, 0)
		
		local label = Primitives.InvisibleTextLabel(button, 'Label', chartStat.Name)
		label.Size = UDim2_new(1, -notifyFrame.Size.X.Offset - 4 - 1, 1, 0)
		label.Position = UDim2_new(0, notifyFrame.Size.X.Offset + 4, 0, 0)
		label.FontSize = 'Size14'
		label.TextXAlignment = 'Left' -- Enum.TextXAlignment.Left
		--label.TextWrap = true
		
		local buttonEffectFunction = devConsole:CreateButtonEffectFunction(button)
		devConsole:ConnectButtonHover(button, function(clicking, hovering)
			buttonEffectFunction(clicking, hovering)
		end)

		button.MouseButton1Down:connect(function()
			-- not ideal
			for i, that in pairs(chartList.ChartButtons) do
				if this ~= that and that.Open then
					that:SetOpen(false)
				end
			end
			this:SetOpen(true)
		end)
		
		-- This fires when the button opens/closes
		local disconnector = CreateDisconnectSignal()
		-- This fires when the button disposes
		local disconnector2 = CreateDisconnectSignal() -- (Best variable name ever)
		
		local function refreshNotifyFrame()
			notifyFrame.BackgroundColor3 = config.GetNotifyColor(this)
		end
		refreshNotifyFrame()
		disconnector2:connect(chartList.OnStatUpdate:connect(refreshNotifyFrame))
				
		function this.SetOpen(this, open)
			if this.Open == open then
				return
			end
			this.Open = open
			
			button:TweenSize(open and size1 or size0, "Out", "Sine", 0.25, true)
			
			disconnector:fire()
			
			if open then
				
				-- The chart page is initialized directly from the button, (this is not ideal, but it works)
				local statsBody = Primitives.FolderFrame(chartList.Body, 'StatsBody') -- Button container
				
				local chartPage = config.CreateChartPage(this, statsBody)
				
				chartPage:SetVisible(true)
				
				disconnector:connect(chartList.OnStatUpdate:connect(function()
					chartPage:OnPointAdded()
				end))
				
				disconnector:connect(function()
					chartPage:Dispose()
					statsBody:Destroy()
				end)
				
			end
			
		end
		
		function this.Dispose(this)
			button:Destroy()
			disconnector:fire()
			disconnector2:fire()
		end
		
		return this
	end
	
	
	local function defaultSorter(a, b) -- this sorts chartButtons
		return a.ChartStat.Name < b.ChartStat.Name
	end

	function Methods.CreateChartList(devConsole, config)
		
		local this = {
			Config = config;
			Visible = false;
			OnStatUpdate = CreateSignal();
			ChartButtons = {}; -- usage: chartButtons[position] = scriptButton
			ChartStats = {}; -- usage: chartStats[chartStat.Name] = chartStat
		}
		
		local frame = Primitives.FolderFrame(nil, 'ScriptList')
		this.Frame = frame
		frame.Visible = false
		
		local sideMenu = Primitives.Frame(frame, 'SideMenu') -- not necessarily parented to frame!
		sideMenu.Size = UDim2_new(0, 196, 1, 0)
		this.SideMenu = sideMenu
		sideMenu.Visible = false
		
		local body = Primitives.FolderFrame(frame, 'Body')
		this.Body = body
		body.Size = UDim2_new(1, -sideMenu.Size.X.Offset, 1, 0)
		body.Position = UDim2_new(0, sideMenu.Size.X.Offset, 0, 0)
		
		local scrollingFrame = Instance.new("ScrollingFrame", sideMenu)
		scrollingFrame.BorderSizePixel = 0
		scrollingFrame.ZIndex = ZINDEX
		scrollingFrame.ScrollBarThickness = 12
		scrollingFrame.Selectable = false
		this.ScrollingFrame = scrollingFrame
		do
			local y = 1 -- if we want to add a label above it later
			scrollingFrame.Size = UDim2_new(1, 0, 1, -y)
			scrollingFrame.Position = UDim2_new(0, 0, 0, y)
			scrollingFrame.BackgroundTransparency = 1
		end
		
		local chartButtons = this.ChartButtons
		local chartStats = this.ChartStats

		local sorter = defaultSorter
		
		function this.SetChartButtonSorter(this, sorterNew)
			if sorter == sorterNew then
				return
			end
			sorter = sorterNew
			table.sort(chartButtons, sorter)
			this:Refresh()
		end
		
		function this.GetChartButton(this, name) -- not used?
			for i = #chartButtons, 1, -1 do
				local chartButton = chartButtons[i]
				if chartButton.ChartStat.Name == name then
					return chartButton, i
				end
			end
		end
		
		function this.RemoveChart(this, name)
			chartStats[name] = nil
			for i = #chartButtons, 1, -1 do
				local chartButton = chartButtons[i]
				if chartButton.ChartStat.Name == name then
					chartButton:Dispose()
					table.remove(chartButtons, i)
					return
				end
			end
		end
		
		function this.UpdateStats(this, newStats)
			
			local timeStamp = os_time() -- Should it use tick instead?
			
			local scriptAddedOrRemoved = false
			
			for name, stat in pairs(chartStats) do
				if not newStats[name] then
					scriptAddedOrRemoved = true
					this:RemoveChart(name)
				end
			end
			
			for name, newStat in pairs(newStats) do
				local chartStat = chartStats[name]
				if not chartStats[name] then
					chartStat = {
						Name = name;
						Stats = {}; -- this could be loaded
					}
					chartStats[name] = chartStat
					if this.Visible then
						local chartButton = createChartButton(devConsole, this, chartStat, config)
						chartButton.Frame.Parent = scrollingFrame
						chartButtons[#chartButtons + 1] = chartButton
					end
				end
				local stats = chartStat.Stats
				stats[#stats + 1] = newStat
			end
			
			table.sort(chartButtons, sorter)
			
			this:Refresh()
			
			this.OnStatUpdate:fire()
			
		end
		
		function this.Refresh(this)
			
			if not this.Visible then
				for i = #chartButtons, 1, -1 do
					chartButtons[i]:Dispose()
					chartButtons[i] = nil
				end
				return
			end
			
			table.sort(chartButtons, sorter)
			
			local y = 0
			for i = 1, #chartButtons do
				local chartButton = chartButtons[i]
				local visible = config.FilterButton(chartButton)
				local button = chartButton.Button
				button.Visible = visible
				if visible then
					button.Position = UDim2_new(0, 1, 0, y) -- Should it lerp to position if animating?
					y = y + button.AbsoluteSize.Y + 1
				end
			end
			
			scrollingFrame.CanvasSize = UDim2_new(0, 0, 0, y)
			
		end
		this:Refresh()
		
		function this.SetVisible(this, visible)
			if visible == this.Visible then
				return
			end
			this.Visible = visible
			
			frame.Visible = visible
			sideMenu.Visible = visible
			
			if visible then
				for name, chartStat in pairs(chartStats) do
					local chartButton = createChartButton(devConsole, this, chartStat, config)
					chartButton.Button.Parent = scrollingFrame
					chartButtons[#chartButtons + 1] = chartButton
				end
				this:Refresh()
			else
				for i = #chartButtons, 1, -1 do
					chartButtons[i]:Dispose()
					chartButtons[i] = nil
				end
			end
		end
		
		return this
	end
end

do -- Chart
	
	local barWidth = 4
	local numBars = math.ceil((Style.ChartWidth - Style.BorderSize * 2) / (barWidth + 1))
	
	local function round(x)
		return math.floor(x * 1000 + 0.5) / 1000
	end
	
	local function CreateBar()
		local bar = Primitives.Frame()
		bar.BackgroundTransparency = 0
		bar.BackgroundColor3 = Color3_new(0, 0.5, 1)
		return bar
	end
	
	local function CreateGraph(points, statIndex, autoScale)
		-- point = points[i][statIndex]
		
		local this = {}
		
		local direction = Style.ChartGraphDirection -- -1 means coming from right, 1 means coming from left
		
		local frame = Primitives.Frame(nil, 'Graph')
		this.Frame = frame
		frame.ClipsDescendants = true
		
		local scaleFrame = Primitives.FolderFrame(frame, 'ScaleFrame')
		
		local body = Primitives.FolderFrame(scaleFrame, 'Body')
		body.Size = UDim2_new(0, barWidth, 1, 0)
		
		local bars = {}
		local barHeights = {}
		local barPositions = {}
		
		do -- reference notches
			local function getReferenceHeight(position)
				if position % 60 == 0 then
					return 24
				elseif position % 30 == 0 then
					return 12
				elseif position % 15 == 0 then
					return 4
				elseif position % 5 == 0 then
					return 1
				else
					return 0
				end
			end
			for position = 0, numBars do
				local height = getReferenceHeight(position)
				if height ~= 0 then
					local notch = Instance_new('Frame', frame)
					notch.ZIndex = ZINDEX
					notch.BorderSizePixel = 0
					notch.BackgroundColor3 = Color3_new(1, 1, 1)
					notch.Size = UDim2_new(0, 1, 0, height)
					notch.Position = UDim2_new(0, position * (barWidth + 1), 1, -height)
				end
			end
		end
		local scale = 1
		
		local position = 0
		
		local visible = false
		
		local function generateSizeAndPosition(height, position)
			height = height * scale
			return
				UDim2_new(0, barWidth, height, 0),
				UDim2_new(0, (barWidth + 1) * position * -direction + 1, 1 - height, 0)
		end
		
		local function RefreshScale(animate)
			if not autoScale then
				return
			end
			local heightMax;
			for i = math_max(#points - numBars + 1, 1), #points do
				local height = points[i][statIndex]
				if not heightMax or height > heightMax then
					heightMax = height
				end
			end
			
			if not heightMax or heightMax <= 0 then
				local size, position = UDim2_new(1, 0, 1, 0), UDim2_new(0, 0, 0, 0)
				if animate then
					scaleFrame:TweenSizeAndPosition(size, position, 'Out', 'Sine', 0.25, true)
				else
					scaleFrame.Size, scaleFrame.Position = UDim2_new(1, 0, 1, 0), UDim2_new(0, 0, 0, 0)
				end
				return
			end
			
			local scaleNew = 1 / heightMax * 0.95
			if math.abs(scale - scaleNew) < 0.0000001 then
				return
			end
			-- Possible performance boost Todo: if the scale isn't significantly different (within like 0.5-4), just adjust scaleFrame's size
			scale = scaleNew
			
			for i = 1, #bars do
				local bar = bars[i]
				local height = barHeights[i]
				local barSize, barPosition = generateSizeAndPosition(height, barPositions[i])
				if animate then
					bar:TweenSizeAndPosition(barSize, barPosition, 'Out', 'Sine', 0.25, true)
				else
					bar.Size, bar.Position = barSize, barPosition
				end
			end
			
			--local scale = 1 / heightMax * 0.95
			--scaleFrame:TweenSizeAndPosition(UDim2_new(1, 0, scale, 0), UDim2_new(0, 0, 1 - scale, 0), 'Out', 'Sine', 0.25, true)

		end
		
		function this.OnPointAdded(this)
			if not visible then
				return
			end
			local bar;
			
			-- possible game crasher
			while #bars > numBars do
				if bar then
					bar:Destroy()
				end
				bar = bars[1]
				table.remove(bars, 1)
				table.remove(barHeights, 1)
				table.remove(barPositions, 1)
			end 
			
			local point = points[#points] and points[#points][statIndex]
			assert(point)
			if not bar then
				bar = CreateBar()
				bar.Parent = body
			end
			
			local height = point
			
			bars[#bars + 1] = bar
			barHeights[#barHeights + 1] = height
			barPositions[#barPositions + 1] = position
			
			bar.Size, bar.Position = generateSizeAndPosition(height, position)
			
			body:TweenPosition(UDim2_new(1 - (direction * 0.5 + 0.5), (barWidth + 1) * position * direction, 0, 0), 'Out', 'Sine', 0.25, true)
			
			position = position + 1
			
			RefreshScale(true)
		end

		function this.SetVisible(this, visibleNew)

			body.Position = UDim2_new(1 - (direction * 0.5 + 0.5), 0, 0, 0)
			if visibleNew == visible then
				return
			end
			visible = visibleNew
			if not visible then
				for i = #bars, 1, -1 do
					bars[i]:Destroy()
					bars[i] = nil
				end
				return
			end

			position = 0
			for i = math_max(#points - numBars + 1, 1), #points do
				local bar = bars[position + 1]
				if not bar then
					bar = CreateBar()
					bar.Parent = body
					bars[position + 1] = bar
				end

				local point = points[i][statIndex]
				local height = point
				
				barHeights[position + 1] = height
				barPositions[position + 1] = position
				
				bar.Size, bar.Position = generateSizeAndPosition(height, position)
				
				position = position + 1
			end
			
			body.Position = UDim2_new(1 - (direction * 0.5 + 0.5), (barWidth + 1) * (position - 1) * direction, 0, 0)
			
			RefreshScale(false)
			
		end
		
		return this
	end
	
	local function createLabel(...)
		local n = Primitives.InvisibleTextLabel(...)
		n.TextXAlignment = 'Left'
		n.FontSize = 'Size14'
		return n
	end
	
	function Methods.CreateChart(devConsole, points, title, statIndex, pointToString)
	
		pointToString = pointToString or function(point)
			if point then
				local precision = 10000
				local v = point * precision
				if v < 1 and v > 0 then
					return "<" .. (1 / precision)
				else
					return math.floor(v + 0.5) / precision .. ""
				end
			else
				return ""
			end
		end
		
		local chart = {}
		
		local frame = Primitives.Frame(nil, 'Chart')
		chart.Frame = frame
		frame.Size = UDim2_new(0, Style.ChartWidth, 0, Style.ChartHeight)
		
		local labelCurrent = createLabel(frame, 'Current', "Current: " .. pointToString(points[#points] and points[#points][statIndex]))
		labelCurrent.Size = UDim2_new(0, 0.5, 0, Style.ChartTitleHeight)
		labelCurrent.Position = UDim2_new(0, 4, 0, Style.ChartTitleHeight + 1)
		
		local graph = CreateGraph(points, statIndex, true)
		graph.Frame.Parent = frame
		graph.Frame.Size = UDim2_new(0, Style.ChartWidth - Style.BorderSize * 2, 0, Style.ChartGraphHeight)
		graph.Frame.Position = UDim2_new(0, Style.BorderSize, 0, Style.ChartTitleHeight + Style.ChartDataHeight)
		
		do
			local bar = Primitives.Frame(frame, 'Bar')
			bar.Size = UDim2_new(1, 0, 0, Style.ChartTitleHeight)
			
			local label = Primitives.InvisibleTextLabel(bar, 'Title', title)
			label.TextXAlignment = 'Left' -- Enum.TextXAlignment.Left
			label.Size = UDim2_new(1, -4, 1, 0)
			label.Position = UDim2_new(0, 4, 0, 0)
			label.FontSize = 'Size18'
		end
		
		local visible = false
		function chart.SetVisible(chart, visibleNew)
			if visibleNew == visible then
				return
			end
			visible = visibleNew
			graph:SetVisible(visible)
		end
		
		function chart.OnPointAdded(chart)
			local point = points[#points]
			
			if not point then
				return
			end
			
			labelCurrent.Text = "Current: " .. pointToString(point and point[statIndex])
			
			graph:OnPointAdded()
		end
		
		return chart
	end
end

--------------------
-- Output console --
--------------------
do
	function Methods.CreateCommandLine(devConsole)
		local this = {
			CommandInputted = CreateSignal();
		}
		
		local frame = Primitives.FolderFrame(nil, 'CommandLine')
		this.Frame = frame
		frame.Size = UDim2_new(1, 0, 0, Style.CommandLineHeight)
		
		local textBoxFrame = Primitives.Frame(frame, 'TextBoxFrame')
		textBoxFrame.Size = UDim2_new(1, 0, 0, Style.CommandLineHeight)
		textBoxFrame.Position = UDim2_new(0, 0, 0, 0)
		textBoxFrame.ClipsDescendants = true
		
		local label = Primitives.InvisibleTextLabel(textBoxFrame, 'Label', ">")
		label.Position = UDim2_new(0, 4, 0, 0)
		label.Size = UDim2_new(0, 12, 1, -1)
		label.FontSize = 'Size14'
		
		local DEFAULT_COMMAND_BAR_TEXT = "Type command here"
		
		local textBox = Primitives.TextBox(textBoxFrame, 'TextBox')
		--textBox.TextWrapped = true -- This needs to auto-resize
		textBox.BackgroundTransparency = 1
		textBox.Text = DEFAULT_COMMAND_BAR_TEXT
		textBox.ClearTextOnFocus = false
		local padding = 2
		textBox.Size = UDim2_new(1, -(padding * 2) - 4 - 12, 0, 500)
		textBox.Position = UDim2_new(0, 4 + 12 + padding, 0, 0)
		textBox.TextXAlignment = 'Left'
		textBox.TextYAlignment = 'Top'
		textBox.FontSize = 'Size18'
		textBox.TextWrapped = true

		-- override SelectionImageObject to better fit
		if isTenFootInterface then
			local selectionImage = Instance.new('ImageLabel')
			selectionImage.Name = "SelectionImage"
			selectionImage.Size = UDim2.new(1, textBoxFrame.AbsoluteSize.x + 36, 0, Style.CommandLineHeight + 24)
			selectionImage.Position = UDim2.new(0, -18, 0, -12)
			selectionImage.Image = 'rbxasset://textures/ui/SelectionBox.png'
			selectionImage.ScaleType = Enum.ScaleType.Slice
			selectionImage.SliceCenter = Rect.new(21,21,41,41)
			selectionImage.BackgroundTransparency = 1

			textBox.SelectionImageObject = selectionImage
		end
		
		do
			local defaultSize = UDim2_new(1, 0, 0, Style.CommandLineHeight)
			local first = true
			
			textBox.Changed:connect(function(property)
				if property == 'TextBounds' or property == 'AbsoluteSize' then
					if first then -- There's a glitch that only occurs on the first change
						first = false
						return
					end
					local textBounds = textBox.TextBounds
					if textBounds.Y > Style.CommandLineHeight then
						textBoxFrame.Size = UDim2_new(1, 0, 0, textBounds.Y + 2)
					else
						textBoxFrame.Size = defaultSize
					end
				end
			end)
		end
		
		local disconnector = CreateDisconnectSignal()
		
		local backtrackPosition = 0
		local inputtedText = {}
		local isLastWeak = false
		local function addInputtedText(text, weak)
			-- weak means it gets overwritten by the next text that's inputted
			if isLastWeak then
				table.remove(inputtedText, 1)
			end
			if inputtedText[1] == text then
				isLastWeak = isLastWeak and weak
				return
			end
			isLastWeak = weak
			if not weak then
				for i = #inputtedText, 1, -1 do
					if inputtedText[i] == text then
						table.remove(inputtedText, i)
					end
				end
			end
			table.insert(inputtedText, 1, text)
		end
		local function backtrack(direction)
			backtrackPosition = backtrackPosition + direction
			if backtrackPosition < 1 then
				backtrackPosition = 1
			elseif backtrackPosition > #inputtedText then
				backtrackPosition = #inputtedText
			end
			if inputtedText[backtrackPosition] then
				-- Setting the text doesn't always work, especially after losing focus without pressing enter, then clicking back
				textBox.Text = inputtedText[backtrackPosition]
			end
		end
		
		local focusLostWithoutEnter = false
		
		textBox.Focused:connect(function()
			if textBox.Text == DEFAULT_COMMAND_BAR_TEXT then
				textBox.Text = ""
			end
			disconnector:fire()
			backtrackPosition = 0
			disconnector:connect(UserInputService.InputBegan:connect(function(input)
				if input.KeyCode == Enum.KeyCode.Up then
					if backtrackPosition == 0 and not focusLostWithoutEnter then
						-- They typed something, then pressed up. They might want what they typed back, so we store it
						--  after they input the next thing, we know they meant to discard this, which is why it's "weak" (second arg is true)
						addInputtedText(textBox.Text, true)
						backtrackPosition = 1
					end
					backtrack(1)
				elseif input.KeyCode == Enum.KeyCode.Down then
					backtrack(-1)
				end
			end))
		end)
		
		textBox.FocusLost:connect(function(enterPressed)
			disconnector:fire()
			if enterPressed then
				focusLostWithoutEnter = false
				
				local text = textBox.Text
				addInputtedText(text, false)
				this.CommandInputted:fire(text)
				textBox.Text = ""

				-- let's not spam the popup keyboard after text is entered
				if not isTenFootInterface then
					textBox:CaptureFocus()
				end
			else
				backtrackPosition = 0
				focusLostWithoutEnter = true
				addInputtedText(textBox.Text, true)
				if textBox.Text == "" then
					textBox.Text = DEFAULT_COMMAND_BAR_TEXT
				end
			end
		end)

		return this
	end
end
do
	local padding = 5
	local LabelSize = UDim2_new(1, -padding, 0, 2048)
	
	local TextColors = Style.MessageColors
	local TextColorUnknown = Color3_new(0.5, 0, 1)
	
	local function isHidden(message)
		return false
	end

	function Methods.CreateOutput(devConsole, messages, messageFilter)

		-- AKA 'Log'
		local heightChanged = CreateSignal()
		local output = {
			Visible = false;
			Height = 0;
			HeightChanged = heightChanged;
		}
		
		local function setHeight(height)
			height = height + 4
			output.Height = height
			heightChanged:fire(height)
		end

		-- The label container
		local frame = Primitives.FolderFrame(nil, 'Output')
		frame.ClipsDescendants = true
		output.Frame = frame

		local textWrappedEnabled = false

		do
			local lastX = 0
			connectPropertyChanged(frame, 'AbsoluteSize', function(size)
				local currentX = size.X
				--currentY = currentY - currentY
				if currentX ~= lastX then
					lastX = currentX
					output:RefreshMessages()
				end
			end)
		end

		local labels = {}
		local labelPositions = {}

		local function RefreshTextWrapped()
			if not output.Visible then
				return
			end
			local y = 1
			for i = 1, #labels do
				local label = labels[i]
				label.TextWrapped = textWrappedEnabled
				local height = label.TextBounds.Y
				label.Size = LabelSize -- UDim2_new(1, 0, 0, height)
				label.Position = UDim2_new(0, padding, 0, y)
				y = y + height
				if height > 16 then
					y = y + 4
				end
			end
			setHeight(y)
		end
		local MAX_LINES = 2048

		local function RefreshMessagesForReal(messageStartPosition)
			if not output.Visible then
				return
			end

			local y = 1
			local labelPosition = 0 -- position of last used label

			-- Failed optimization:
			messageStartPosition = nil
			if messageStartPosition then
				local labelPositionLast;
				for i = messageStartPosition, math_max(1, #messages - MAX_LINES), -1 do
					if labelPositions[i] then
						labelPositionLast = labelPositions[i]
						break
					end
				end
				if labels[labelPositionLast] then
					labelPosition = labelPositionLast
					local label = labels[labelPositionLast]
					y = label.Position.Y.Offset + label.Size.Y.Offset
				else
					messageStartPosition = nil
				end
			end

			for i = messageStartPosition or math_max(1, #messages - MAX_LINES), #messages do
				local message = messages[i]
				if messageFilter(message) then
					labelPosition = labelPosition + 1
					labelPositions[i] = labelPosition
					local label = labels[labelPosition]
					if not label then
						label = Instance_new('TextLabel', frame)
						label.ZIndex = ZINDEX
						label.BackgroundTransparency = 1
						--label.Font = Style.Font
						label.FontSize = 'Size10'
						label.TextXAlignment = 'Left'
						label.TextYAlignment = 'Top'
						labels[labelPosition] = label
					end
					label.TextWrapped = textWrappedEnabled
					label.Size = LabelSize
					label.TextColor3 = TextColors[message.Type] or TextColorUnknown
					label.Text = message.Time .. " -- " .. message.Message
					
					local height = label.TextBounds.Y
					label.Size = LabelSize -- UDim2_new(1, -padding, 0, height)
					label.Position = UDim2_new(0, padding, 0, y)

					y = y + height
					
					if height > 16 then
						y = y + 4
					end
				else
					labelPositions[i] = false
				end
			end

			-- Destroy extra labels
			for i = #labels, labelPosition + 1, -1 do
				labels[i]:Destroy()
				labels[i] = nil
			end
			
			setHeight(y)
		end
		
		local refreshHandle;
		function output.RefreshMessages(output, messageStartPosition)
			if not output.Visible then
				return
			end
			if not refreshHandle then
				refreshHandle = true
				coroutine.wrap(function() -- Not ideal
					wait()
					refreshHandle = false
					RefreshMessagesForReal()
				end)()
			end
		end
		
		function output.SetTextWrappedEnabled(output, textWrappedEnabledNew)
			if textWrappedEnabledNew == textWrappedEnabled then
				return
			end
			textWrappedEnabled = textWrappedEnabledNew
			RefreshTextWrapped()
		end
		
		function output.SetVisible(output, visible)
			if visible == output.Visible then
				return
			end
			output.Visible = visible
			if visible then
				RefreshMessagesForReal()
			else
				for i = #labels, 1, -1 do
					labels[i]:Destroy()
					labels[i] = nil
				end
			end
		end

		return output
	end
end

----------
-- Tabs --
----------
function Methods.RefreshTabs(devConsole)
	-- Go through and reposition them
	local x = Style.BorderSize
	local tabs = devConsole.Tabs
	for i = 1, #tabs do
		local tab = tabs[i]
		if tab.ButtonFrame.Visible then
			x = x + 3
			tab.ButtonFrame.Position = UDim2_new(0, x, 0, 0)
			x = x + tab.ButtonFrame.AbsoluteSize.X + 3
		end
	end
end

function Methods.AddTab(devConsole, text, width, body, openCallback, visibleCallback)
	-- Body is a frame that contains the tab contents
	body.Visible = false
	
	local tab = {
		Open = false; -- If the tab is open
		Visible = false; -- If the tab is shown
		OpenCallback = openCallback;
		VisibleCallback = visibleCallback;
		Body = body;
	}
	
	local buttonFrame = Primitives.InvisibleButton(devConsole.Frame.Interior.Tabs, 'Tab_' .. text)
	tab.ButtonFrame = buttonFrame
	buttonFrame.Size = UDim2_new(0, width, 0, Style.TabHeight)
	buttonFrame.Visible = false
	
	local textLabel = Primitives.TextLabel(buttonFrame, 'Label', text)
	textLabel.FontSize = Enum.FontSize.Size14
	--textLabel.TextYAlignment = Enum.TextYAlignment.Top
	
	devConsole:ConnectButtonHover(buttonFrame, devConsole:CreateButtonEffectFunction(textLabel))

	-- These are the dimensions when the tab is closed
	local size0 = UDim2_new(1, 0, 1, -7)
	local position0 = UDim2_new(0, 0, 0, 4)
	-- There are the dimensions when the tab is open
	local size1 = UDim2_new(1, 0, 1, -4)
	local position1 = UDim2_new(0, 0, 0, 4)
	-- It starts closed
	textLabel.Size = size0
	textLabel.Position = position0
	
	function tab.SetVisible(tab, visible)
		if visible == tab.Visible then
			return
		end
		tab.Visible = visible
		tab:SetOpen(false)
		if tab.VisibleCallback then
			tab.VisibleCallback(visible)
		end
		buttonFrame.Visible = visible
		devConsole:RefreshTabs()
		if not visible then
			tab.SetOpen(false)
		end
	end

	function tab.SetOpen(tab, open)
		if open == tab.Open then
			return
		end
		tab.Open = open

		if open then
			if tab.SavedScrollbarValue then
				devConsole.WindowScrollbar:SetValue(tab.SavedScrollbarValue)  -- This doesn't load correctly?
			end
			local tabs = devConsole.Tabs
			for i = 1, #tabs do
				if tabs[i] ~= tab then
					tabs[i]:SetOpen(false)
				end
			end
			if body then
				body.Visible = true
			end
			devConsole:RefreshTabs()
			-- Set dimensions for folder effect
			textLabel.Size = size1
			textLabel.Position = position1
			devConsole.CurrentOpenedTab = buttonFrame
		else
			tab.SavedScrollbarValue = devConsole.WindowScrollbar:GetValue() -- This doesn't save correctly

			if body then
				body.Visible = false
				-- todo: (not essential) these 2 lines should instead exist during open (above block) after going through tabs
				devConsole.Frame.Interior.WindowContainer.Window.Body.Size = UDim2_new(1, 0, 1, 0) 
				devConsole.Frame.Interior.WindowContainer.Window.Body.Position = UDim2_new(0, 0, 0, 0)
			end
			
			-- Set dimensions for folder effect
			textLabel.Size = size0
			textLabel.Position = position0
		end
		
		if tab.OpenCallback then
			tab.OpenCallback(open)
		end
		
	end
	
	buttonFrame.MouseButton1Click:connect(function()
		if tab.Visible then
			tab:SetOpen(true)
		end
	end)
	
	table.insert(devConsole.Tabs, tab)
	
	return tab
	
end

----------------
-- Scroll bar --
----------------
function Methods.ApplyScrollbarToFrame(devConsole, scrollbar, window, body, frame)
	local windowHeight, bodyHeight
	local height = scrollbar:GetHeight()
	local value = scrollbar:GetValue()
	local function getHeights()
		return window.AbsoluteSize.Y, body.AbsoluteSize.Y
	end
	local function refreshDimension()
		local windowHeightNew, bodyHeightNew = getHeights()

		if bodyHeight ~= bodyHeightNew or windowHeight ~= windowHeightNew then
			bodyHeight, windowHeight = bodyHeightNew, windowHeightNew
			height = windowHeight / bodyHeight
			scrollbar:SetHeight(height)
			
			local yOffset = (bodyHeight - windowHeight) * value
			local x = body.Position.X
			local y = body.Position.Y
			body.Position = UDim2_new(x.Scale, x.Offset, y.Scale, -math.floor(yOffset))
		end

	end
	
	local function setValue(valueNew)
		value = valueNew
		refreshDimension()
		local yOffset = (bodyHeight - windowHeight) * value
		local x = body.Position.X
		local y = body.Position.Y
		body.Position = UDim2_new(x.Scale, x.Offset, y.Scale, -math.floor(yOffset))
	end
	scrollbar.ValueChanged:connect(setValue)
	setValue(scrollbar:GetValue())

	local scrollDistance = 120
	
	window.Active = true

	scrollbar.ButtonUp.MouseButton1Click:connect(function()
		scrollbar:Scroll(-scrollDistance, getHeights())
	end)
	scrollbar.ButtonDown.MouseButton1Click:connect(function()
		scrollbar:Scroll(scrollDistance, getHeights())
	end)

	connectPropertyChanged(window, 'AbsoluteSize', refreshDimension)
	connectPropertyChanged(body, 'AbsoluteSize', function()
		local windowHeight, bodyHeight = getHeights()
		local value = scrollbar:GetValue()
		if value ~= 1 and value ~= 0 then
			local value = -body.Position.Y.Offset / (bodyHeight - windowHeight)
			scrollbar:SetValue(value)
		end
		refreshDimension()
	end)

	window.MouseWheelForward:connect(function()
		scrollbar:Scroll(-scrollDistance, getHeights())
	end)
	window.MouseWheelBackward:connect(function()
		scrollbar:Scroll(scrollDistance, getHeights())
	end)
	window.TouchPan:connect(function(positions, delta, velocity, userInputState)
		scrollbar:Scroll(-delta.y, getHeights())
	end)
end

function Methods.CreateScrollbar(devConsole, rotation)
	local scrollbar = {}

	local main = Primitives.FolderFrame(main, 'Scrollbar')
	scrollbar.Frame = main

	local frame = Primitives.Button(main, 'Frame')
	frame.AutoButtonColor = false
	frame.Size = UDim2_new(1, 0, 1, -(Style.HandleHeight) * 2 - 2)
	frame.Position = UDim2_new(0, 0, 0, Style.HandleHeight + 1)
	-- frame.BackgroundTransparency = 0.75
	
	-- This replaces the scrollbar when it's not being used
	local frame2 = Primitives.Frame(main, 'Frame')
	frame2.Size = UDim2_new(1, 0, 1, 0)
	frame2.Position = UDim2_new(0, 0, 0, 0)
	
	function scrollbar.SetVisible(scrollbar, visible)
		frame.Visible = visible
		frame2.Visible = not visible
	end
	
	local buttonUp = Primitives.ImageButton(frame, 'Up', 'https://www.roblox.com/asset/?id=261880783')
	scrollbar.ButtonUp = buttonUp
	buttonUp.Size = UDim2_new(1, 0, 0, Style.HandleHeight)
	buttonUp.Position = UDim2_new(0, 0, 0, -Style.HandleHeight - 1)
	buttonUp.AutoButtonColor = false
	devConsole:ConnectButtonHover(buttonUp, devConsole:CreateButtonEffectFunction(buttonUp))

	local buttonDown = Primitives.ImageButton(frame, 'Down', 'https://www.roblox.com/asset/?id=261880783')
	scrollbar.ButtonDown = buttonDown
	buttonDown.Size = UDim2_new(1, 0, 0, Style.HandleHeight)
	buttonDown.Position = UDim2_new(0, 0, 1, 1)
	buttonDown.Rotation = 180
	buttonDown.AutoButtonColor = false
	devConsole:ConnectButtonHover(buttonDown, devConsole:CreateButtonEffectFunction(buttonDown))

	local bar = Primitives.Button(frame, 'Bar')
	bar.Size = UDim2_new(1, 0, 0.5, 0)
	bar.Position = UDim2_new(0, 0, 0.25, 0)
	
	bar.AutoButtonColor = false
	
	local grip = Primitives.InvisibleImageLabel(bar, 'Image', 'https://www.roblox.com/asset/?id=261904959')
	grip.Size = UDim2_new(0, 16, 0, 16)
	grip.Position = UDim2_new(0.5, -8, 0.5, -8)

	local buttonEffectFunction = devConsole:CreateButtonEffectFunction(bar, nil, bar.BackgroundColor3, bar.BackgroundColor3)
	
	-- Inertial scrolling would be added around here
	
	local value = 1
	local valueChanged = CreateSignal()
	scrollbar.ValueChanged = valueChanged
	-- value = 0: at very top
	-- value = 1: at very bottom
	
	local height = 0.25
	local heightChanged = CreateSignal()
	scrollbar.HeightChanged = heightChanged
	-- height = 0: infinite page size
	-- height = 1: bar fills frame completely, no need to scroll
	
	local function getValueAtPosition(pos)
		return ((pos - main.AbsolutePosition.Y) / main.AbsoluteSize.Y) / (1 - height)
	end
	
	-- Refreshes the position and size of the scrollbar
	local function refresh()
		local y = height
		bar.Size = UDim2_new(1, 0, y, 0)
		bar.Position = UDim2_new(0, 0, value * (1 - y), 0)
	end
	refresh()
	
	function scrollbar.SetValue(scrollbar, valueNew)
		if valueNew < 0 then
			valueNew = 0
		elseif valueNew > 1 then
			valueNew = 1
		end
		if valueNew ~= value then
			value = valueNew
			refresh()
			valueChanged:fire(valueNew)
		end
	end
	function scrollbar.GetValue(scrollbar)
		return value
	end
	
	function scrollbar.Scroll(scrollbar, direction, windowHeight, bodyHeight)
		scrollbar:SetValue(value + direction / bodyHeight) -- needs to be adjusted
	end
	
	function scrollbar.SetHeight(scrollbar, heightNew)
		if heightNew < 0 then
			heightNew = 0 -- this is still an awkward case of divide-by-zero that shouldn't happen
		elseif heightNew > 1 then
			heightNew = 1
		end
		heightNew = math.max(heightNew, 0.1) -- Minimum scroll bar size, from that point on it is not the actual ratio
		if heightNew ~= height then
			height = heightNew
			scrollbar:SetVisible(heightNew < 1)
			refresh()
			heightChanged:fire(heightNew)
		end
	end
	function scrollbar.GetHeight(scrollbar)
		return height
	end

	devConsole:ConnectButtonDragging(bar, function()
		local value0 = value -- starting value
		return function(dx, dy)
			local dposition = dy -- net position change relative to the bar's axis (could support rotated scroll bars)
			local dvalue = (dposition / frame.AbsoluteSize.Y) / (1 - height) -- net value change
			scrollbar:SetValue(value0 + dvalue)
		end
	end, buttonEffectFunction)
	
	return scrollbar
end

----------------------
-- Fancy color lerp --
----------------------
local RenderLerpAnimation; do
	local math_cos = math.cos
	local math_pi = math.pi
	function RenderLerpAnimation(disconnectSignal, length, callback)
		disconnectSignal:fire()
		local timeStamp = tick()
		local listener = RunService.RenderStepped:connect(function()
			local t = (tick() - timeStamp) / length
			if t >= 1 then
				t = 1
				disconnectSignal:fire()
			else
				t = (1 - math_cos(t * math_pi)) / 2 -- cosine interpolation aka 'Sine' in :TweenSizeAndPosition
			end
			callback(t)
		end)
		disconnectSignal:connect(listener)
		return listener
	end
end

if EYECANDY_ENABLED then
	-- This is the pretty version
	function Methods.CreateButtonEffectFunction(devConsole, button, normalColor, clickingColor, hoveringColor)
		normalColor = normalColor or button.BackgroundColor3
		clickingColor = clickingColor or Style.GetButtonDownColor(normalColor)
		hoveringColor = hoveringColor or Style.GetButtonHoverColor(normalColor)
		local disconnectSignal = CreateDisconnectSignal()
		return function(clicking, hovering)
			local color0 = button.BackgroundColor3
			local color1 = clicking and clickingColor or (hovering and hoveringColor or normalColor)
			local r0, g0, b0 = color0.r, color0.g, color0.b
			local r1, g1, b1 = color1.r, color1.g, color1.b
			local r2, g2, b2 = r1 - r0, g1 - g0, b1 - b0
			RenderLerpAnimation(disconnectSignal, clicking and 0.125 or 0.25, function(t)
				button.BackgroundColor3 = Color3_new(r0 + r2 * t, g0 + g2 * t, b0 + b2 * t)
			end)
		end
	end
else
	-- This is the simple version
	function Methods.CreateButtonEffectFunction(devConsole, button, normalColor, clickingColor, hoveringColor)
		normalColor = normalColor or button.BackgroundColor3
		clickingColor = clickingColor or Style.GetButtonDownColor(normalColor)
		hoveringColor = hoveringColor or Style.GetButtonHoverColor(normalColor)
		return function(clicking, hovering)
			button.BackgroundColor3 = clicking and clickingColor or (hovering and hoveringColor or normalColor)
		end
	end
end

function Methods.GenerateOptionButtonAnimationToggle(devConsole, interior, button, gear, tabContainer, optionsClippingFrame, optionsFrame)
	
	local tabContainerSize0 = tabContainer.Size
	local tabContainerSize1 = UDim2_new(
		tabContainerSize0.X.Scale, tabContainerSize0.X.Offset + (Style.GearSize + 2) + Style.BorderSize,
		tabContainerSize0.Y.Scale, tabContainerSize0.Y.Offset)
		
	local gearRotation0 = gear.Rotation
	local gearRotation1 = gear.Rotation - 90
	local interiorSize0 = interior.Size
	local interiorSize1 = UDim2_new(interiorSize0.X.Scale, interiorSize0.X.Offset, interiorSize0.Y.Scale, interiorSize0.Y.Offset - Style.OptionAreaHeight)
	local interiorPosition0 = interior.Position
	local interiorPosition1 = UDim2_new(interiorPosition0.X.Scale, interiorPosition0.X.Offset, interiorPosition0.Y.Scale, interiorPosition0.Y.Offset + Style.OptionAreaHeight)
	
	local length = 0.5
	local disconnector = CreateDisconnectSignal()
	return function(open)
		if open then
			interior:TweenSizeAndPosition(interiorSize1, interiorPosition1, 'Out', 'Sine', length, true)
			tabContainer:TweenSize(tabContainerSize1, 'Out', 'Sine', length, true)
			optionsClippingFrame:TweenSizeAndPosition(
				UDim2_new(1, 0, 0, Style.OptionAreaHeight),
				UDim2_new(0, 0, 0, -Style.OptionAreaHeight),
				'Out', 'Sine', length, true
			)
			optionsFrame:TweenPosition(
				UDim2_new(0, 0, 0, 0),-- -Style.OptionAreaHeight),
				'Out', 'Sine', length, true
			)
			local gearRotation = gear.Rotation
			RenderLerpAnimation(disconnector, length, function(t)
				gear.Rotation = gearRotation1 * t + gearRotation * (1 - t)
			end)
		else
			interior:TweenSizeAndPosition(interiorSize0, interiorPosition0, 'Out', 'Sine', length, true)
			tabContainer:TweenSize(tabContainerSize0, 'Out', 'Sine', length, true)
			optionsClippingFrame:TweenSizeAndPosition(
				UDim2_new(1, 0, 0, 0),
				UDim2_new(0, 0, 0, 0),
				'Out', 'Sine', length, true
			)
			optionsFrame:TweenPosition(
				UDim2_new(0, 0, 0, Style.OptionAreaHeight),
				'Out', 'Sine', length, true
			)
			local gearRotation = gear.Rotation
			RenderLerpAnimation(disconnector, length, function(t)
				gear.Rotation = gearRotation0 * t + gearRotation * (1 - t)
			end)
		end	
	end
end

------------------------------
-- Events for color effects --
------------------------------
do
	local globalInteractEvent = CreateSignal()
	function Methods.ConnectButtonHover(devConsole, button, mouseInteractCallback)
		-- void mouseInteractCallback(bool clicking, bool hovering)
		
		local this = {}
		
		local clicking = false
		local hovering = false
		local function set(clickingNew, hoveringNew)
			if hoveringNew and TouchEnabled then
				hoveringNew = false -- Touch screens don't hover
			end
			if clickingNew ~= clicking or hoveringNew ~= hovering then
				clicking, hovering = clickingNew, hoveringNew
				mouseInteractCallback(clicking, hovering)
			end
		end
		
		button.MouseButton1Down:connect(function()
			set(true, true)
		end)
		button.MouseButton1Up:connect(function()
			set(false, true)
		end)
		button.MouseEnter:connect(function()
			set(clicking, true)
		end)
		button.MouseLeave:connect(function()
			set(false, false)
		end)
		--[[ these might cause memory leakes (when creating temporary buttons)
		-- This solves the case in which the user presses F9 while hovering over a button
		devConsole.VisibleChanged:connect(function()
			set(false, false)
		end)
		
		globalInteractEvent:connect(function()
			set(false, false)
		end)
		--]]
	end
end

-------------------------
-- Events for draggers -- (for the window's top handle, the resize button, and scrollbars)
-------------------------
function Methods.ConnectButtonDragging(devConsole, button, dragCallback, mouseInteractCallback)
	
	-- How dragCallback is called: local deltaCallback = dragCallback(xPositionAtMouseDown, yPositionAtMouseDown)
	-- How deltaCallback is called: deltaCallback(netChangeInAbsoluteXPositionSinceMouseDown, netChangeInAbsoluteYPositionSinceMouseDown)
	
	local dragging = false -- AKA 'clicking'
	local hovering = false
	
	local listeners = {}
	
	local disconnectCallback;
	
	local function stopDragging()
		if not dragging then
			return
		end
		dragging = false
		mouseInteractCallback(dragging, hovering)
		for i = #listeners, 1, -1 do
			listeners[i]:disconnect()
			listeners[i] = nil
		end
	end
	
	local ButtonUserInputTypes = {
		[Enum.UserInputType.MouseButton1] = true;
		[Enum.UserInputType.Touch] = true; -- I'm not sure if touch actually works here
	}
	
	local mouse = game:GetService("Players").LocalPlayer:GetMouse()

	local function startDragging(startP)
		if dragging then
			return
		end
		dragging = true
		
		mouseInteractCallback(dragging, hovering)
		local deltaCallback;
		
		local x0, y0 = startP.X, startP.Y
		--[[
		listeners[#listeners + 1] = UserInputService.InputBegan:connect(function(input)
			if ButtonUserInputTypes[input.UserInputType] then
				local position = input.Position
				if position and not x0 then
					x0, y0 = position.X, position.Y -- The same click
				end
			end
		end)
		--]]
		listeners[#listeners + 1] = UserInputService.InputEnded:connect(function(input)
			if ButtonUserInputTypes[input.UserInputType] then
				stopDragging()
			end
		end)
		listeners[#listeners + 1] = UserInputService.InputChanged:connect(function(input)
		
			if not (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch)then -- added in a touch check
				return
			end
			
			local p1 = input.Position

			if not p1 then
				return
			end
			local x1, y1 = p1.X, p1.Y
			if not deltaCallback then
				deltaCallback, disconnectCallback = dragCallback(x0 or x1, y0 or y1)
			end
			if x0 then
				deltaCallback(x1 - x0, y1 - y0)
			end
		end)
	end
	
	--button.MouseButton1Down:connect(startDragging)
	--button.MouseButton1Up:connect(stopDragging)
	
	button.InputBegan:connect(function(iobj)
		if iobj.UserInputType == Enum.UserInputType.Touch or iobj.UserInputType == Enum.UserInputType.MouseButton1 then
			startDragging(iobj.Position)
		end
	end)
	
	button.InputEnded:connect(function(iobj)
		if iobj.UserInputType == Enum.UserInputType.Touch or iobj.UserInputType == Enum.UserInputType.MouseButton1 then
			stopDragging()
		end
	end)	
	
	button.MouseEnter:connect(function()
		if not hovering then
			hovering = true
			mouseInteractCallback(dragging, hovering)
		end
	end)
	button.MouseLeave:connect(function()
		if hovering then
			hovering = false
			mouseInteractCallback(dragging, hovering)
		end
	end)
	
	devConsole.VisibleChanged:connect(stopDragging)
end

-----------------
-- Permissions --
-----------------
do
	local permissionsLoading, permissions = false;
	function DeveloperConsole.GetPermissions()
		while permissionsLoading do wait() end
		
		if permissions then
			return permissions
		end
		
		permissions = {}
		permissionsLoading = true
		
		pcall(function()
			permissions.CreatorFlagValue = settings():GetFFlag("UseCanManageApiToDetermineConsoleAccess")
		end)
	
		pcall(function()
			-- This might not support group games, I'll leave it up to "UseCanManageApiToDetermineConsoleAccess"
			permissions.IsCreator = permissions.CreatorFlagValue or game:GetService("Players").LocalPlayer.userId == game.CreatorId
		end)
		
		if permissions.CreatorFlagValue then -- Use the new API
			permissions.IsCreator = false
			local success, result = pcall(function()
				local url = string.format("/users/%d/canmanage/%d", game:GetService("Players").LocalPlayer.userId, game.PlaceId)
				return game:GetService('HttpRbxApiService'):GetAsync(url, Enum.ThrottlingPriority.Default)
			end)
			if success and type(result) == "string" then
				-- API returns: {"Success":BOOLEAN,"CanManage":BOOLEAN}
				-- Convert from JSON to a table
				-- pcall in case of invalid JSON
				success, result = pcall(function()
					return game:GetService('HttpService'):JSONDecode(result)
				end)
				if success and result.CanManage == true then
					permissions.IsCreator = result.CanManage
				end
			end
		end
		
		permissions.ClientCodeExecutionEnabled = false
		pcall(function()
			permissions.ServerCodeExecutionEnabled = permissions.IsCreator and settings():GetFFlag("ConsoleCodeExecutionEnabled")
		end)
		
		if DEBUG then
			permissions.IsCreator = true
			permissions.ServerCodeExecutionEnabled = true
		end
		
		permissions.MayViewServerLog = permissions.IsCreator
		permissions.MayViewClientLog = true
		
		permissions.MayViewServerStats = permissions.IsCreator
		permissions.MayViewServerScripts = permissions.IsCreator
		permissions.MayViewServerJobs = permissions.IsCreator
		
		permissionsLoading = false
		
		return permissions
	end
end

----------------------
-- Output interface --
----------------------
do
	local messagesAndStats;
	function DeveloperConsole.GetMessagesAndStats(permissions)
		
		if messagesAndStats then
			return messagesAndStats
		end
	
		local function NewOutputMessageSync(getMessages)
			local this;
			this = {
				Messages = nil; -- Private member, DeveloperConsole should use :GetMessages()
				MessageAdded = CreateSignal();
				GetMessages = function()
					local messages = this.Messages
					if not messages then
						-- If it errors while getting messages, it skip it next time
						if this.Attempted then
							messages = {}
						else
							this.Attempted = true
							messages = getMessages(this)
							this.Messages = messages
						end
		
					end
					return messages
				end;
			}
			return this
		end
		
		local ConvertTimeStamp; do
			-- Easy, fast, and working nicely
			local function numberWithZero(num)
				return (num < 10 and "0" or "") .. num
			end
			local string_format = string.format -- optimization
			function ConvertTimeStamp(timeStamp)
				local localTime = timeStamp - os_time() + math.floor(tick())
				local dayTime = localTime % 86400
						
				local hour = math.floor(dayTime/3600)
				
				dayTime = dayTime - (hour * 3600)
				local minute = math.floor(dayTime/60)
				
				dayTime = dayTime - (minute * 60)
				local second = dayTime
	
				local h = numberWithZero(hour)
				local m = numberWithZero(minute)
				local s = numberWithZero(dayTime)
		
				return string_format("%s:%s:%s", h, m, s)
			end
		end
		
		local warningsToFilter = {"ClassDescriptor failed to learn", "EventDescriptor failed to learn", "Type failed to learn"}
		
		-- Filter "ClassDescriptor failed to learn" errors
		local function filterMessageOnAdd(message)
			if message.Type ~= Enum.MessageType.MessageWarning.Value then
				return false
			end
			local found = false
			for _, filterString in ipairs(warningsToFilter) do
				if string.find(message.Message, filterString) ~= nil then
					found = true
					break
				end
			end
			return found
		end
	
		local outputMessageSyncLocal;
		if permissions.MayViewClientLog then
			outputMessageSyncLocal = NewOutputMessageSync(function(this)
				local messages = {}
				
				local LogService = game:GetService("LogService")
				do -- This do block keeps history from sticking around in memory
					local history = LogService:GetLogHistory()
					for i = 1, #history do
						local msg = history[i]
						local message = {
							Message = msg.message or "[DevConsole Error 1]";
							Time = ConvertTimeStamp(msg.timestamp);
							Type = msg.messageType.Value;
						}
						if not filterMessageOnAdd(message) then
							messages[#messages + 1] = message
						end
					end
				end
				
				LogService.MessageOut:connect(function(text, messageType)
					local message = {
						Message = text or "[DevConsole Error 2]";
						Time = ConvertTimeStamp(os_time());
						Type = messageType.Value;
					}
					if not filterMessageOnAdd(message) then
						messages[#messages + 1] = message
						this.MessageAdded:fire(message)
					end
				end)
			
				return messages
			end)
		end
		
		local outputMessageSyncServer;
		if permissions.MayViewServerLog then
			outputMessageSyncServer = NewOutputMessageSync(function(this)
				local messages = {}
				
				local LogService = game:GetService("LogService")
				
				LogService.ServerMessageOut:connect(function(text, messageType, timestamp)
					local message = {
						Message = text or "[DevConsole Error 3]";
						Time = ConvertTimeStamp(timestamp);
						Type = messageType.Value;
					}
					if not filterMessageOnAdd(message) then
						messages[#messages + 1] = message
						this.MessageAdded:fire(message)
					end
				end)
				LogService:RequestServerOutput()
				
				return messages
			end)
		end
	
		local statsSyncServer;
		if permissions.MayViewServerStats or permissions.MayViewServerScripts then
			statsSyncServer = {
				Stats = nil; -- Private member, use GetStats instead
				StatsReceived = CreateSignal();
			}
			local statsListenerConnection;
			function statsSyncServer.GetStats(statsSyncServer)
				local stats = statsSyncServer.Stats
				if not stats then
					stats = {}
					pcall(function()
						local clientReplicator = game:FindService("NetworkClient"):GetChildren()[1]
							if clientReplicator then
							statsListenerConnection = clientReplicator.StatsReceived:connect(function(stat)
								statsSyncServer.StatsReceived:fire(stat)
							end)
							clientReplicator:RequestServerStats(true)
						end
					end)
					statsSyncServer.Stats = stats
				end
				return stats
			end
			
		end
		--]]
		
		messagesAndStats = {
			OutputMessageSyncLocal = outputMessageSyncLocal;
			OutputMessageSyncServer = outputMessageSyncServer;
			StatsSyncServer = statsSyncServer;
		}
		
		return messagesAndStats
	end
end

--[[ Module Table ]]--
-- We only create the dev console if we need it; user toggles visibility.

local DevConsoleModuleTable = {}
local myDeveloperConsole = nil

-- Tenfoot Interface set up
local function onDevConsoleVisibilityChanged(isVisible)
	local blockMenuActionName = "blockMenuAction"
	local closeDevConsoleActionName = "closeDevConsoleAction"
	local selectionParentName = "devConsoleSelectionGroup"

	local function closeDevConsole(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End then
			myDeveloperConsole:SetVisible(false)
		end
	end

	if isVisible then
		-- block menu open input while dev console is open
		ContextActionService:BindCoreAction(blockMenuActionName, function() end, false, Enum.KeyCode.ButtonStart)

		local menuModule = require(Modules.Settings.SettingsHub)
		menuModule:SetVisibility(false, true)
		ContextActionService:BindCoreAction(closeDevConsoleActionName, closeDevConsole, false, Enum.KeyCode.ButtonB)

		GuiService:AddSelectionParent(selectionParentName, myDeveloperConsole.Frame)
		GuiService.SelectedCoreObject = myDeveloperConsole.CurrentOpenedTab
	else
		ContextActionService:UnbindCoreAction(closeDevConsoleActionName)
		ContextActionService:UnbindCoreAction(blockMenuActionName)

		GuiService:RemoveSelectionGroup(selectionParentName)
		GuiService.SelectedCoreObject = nil
	end
end

local devConsoleCreating = false
local function getDeveloperConsole()
	if (not myDeveloperConsole and not devConsoleCreating) then
		devConsoleCreating = true
		local permissions = DeveloperConsole.GetPermissions()
		local messagesAndStats = DeveloperConsole.GetMessagesAndStats(permissions)

		myDeveloperConsole = DeveloperConsole.new(RobloxGui, permissions, messagesAndStats)

		if isTenFootInterface then
			myDeveloperConsole.VisibleChanged:connect(onDevConsoleVisibilityChanged)
		end
		devConsoleCreating = false
	end
	return myDeveloperConsole
end

function DevConsoleModuleTable:GetVisibility()
	local devConsole = getDeveloperConsole()
	if devConsole then
		return devConsole.Visible
	else
		return false
	end
end

function DevConsoleModuleTable:SetVisibility(value)
	local devConsole = getDeveloperConsole()
	if devConsole then
		devConsole:SetVisible(value)
	end
end


local creatingLock = false
local creatingVisibleValueToSet = false

local function SetCoreConsoleCreation()
	if (creatingLock) then return end
	creatingLock = true

	spawn(function()
		--// Keep GetVisibility call before SetVisibility because the first call will yield for some time and 
		--// there is the possibility that during the yield time the value of 'creatingVisibleValueToSet' may
		--// change.
		DevConsoleModuleTable:GetVisibility()
		DevConsoleModuleTable:SetVisibility(creatingVisibleValueToSet)

		creatingLock = false
	end)
end

local StarterGui = game:GetService("StarterGui")
StarterGui:RegisterGetCore("DeveloperConsoleVisible", function()
	if (not myDeveloperConsole) then
		SetCoreConsoleCreation()
		return creatingVisibleValueToSet;
	else
		return DevConsoleModuleTable:GetVisibility()
	end
end)
StarterGui:RegisterSetCore("DeveloperConsoleVisible", function(visible)
	if (type(visible) ~= "boolean") then
		error("DeveloperConsoleVisible must be given a boolean value.")
	end

	if (not myDeveloperConsole) then
		creatingVisibleValueToSet = visible
		SetCoreConsoleCreation()
	else
		DevConsoleModuleTable:SetVisibility(visible)
	end
end)

return DevConsoleModuleTable
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC6D4151621B64785AE0939F2A3BDAC36">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NewChat</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	// FileName: NewChat.lua
	// Written by: Xsitsu
	// Description: Bridges the topbar in corescripts to any chat system running in the non-corescripts environment.
]]
local CoreGuiService = game:GetService("CoreGui")
local RobloxGui = CoreGuiService:WaitForChild("RobloxGui")

local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")

local Util = require(RobloxGui.Modules.ChatUtil)


local moduleApiTable = {}
do
		local ChatWindowState =
		{
			Visible = true,
			MessageCount = 0,
			TopbarEnabled = true,
			CoreGuiEnabled = true,
		}

		local communicationsConnections = {}
		local eventConnections = {}

		local MakeSystemMessageCache = {}

		local function FindInCollectionByKeyAndType(collection, indexName, type)
			if (collection and collection[indexName] and collection[indexName]:IsA(type)) then
				return collection[indexName]
			end
			return nil
		end

		local function DispatchEvent(eventName, ...)
			local event = FindInCollectionByKeyAndType(communicationsConnections.ChatWindow, eventName, "BindableEvent")
			if (event) then
				event:Fire(...)
				return true
			end
			return false
		end

		local function AttemptInvokeFunction(functionName, ...)
			local func = FindInCollectionByKeyAndType(communicationsConnections.ChatWindow, functionName, "BindableFunction")
			if (func) then
				return true, func:Invoke()
			end
			return false, nil
		end

		local function DoConnectGetCore(connectionName)
			StarterGui:RegisterGetCore(connectionName, function(data)
				local func = FindInCollectionByKeyAndType(communicationsConnections.GetCore, connectionName, "BindableFunction")
				local rVal = nil
				if (func) then rVal = func:Invoke(data) end
				return rVal
			end)
		end

		function moduleApiTable:ToggleVisibility()
			ChatWindowState.Visible = not ChatWindowState.Visible
			local didFire = DispatchEvent("ToggleVisibility")
			if (not didFire) then
				moduleApiTable.VisibilityStateChanged:fire(ChatWindowState.Visible)
			end
		end

		function moduleApiTable:SetVisible(visible)
			ChatWindowState.Visible = visible
			local didFire = DispatchEvent("SetVisible", ChatWindowState.Visible)
			if (not didFire) then
				moduleApiTable.VisibilityStateChanged:fire(ChatWindowState.Visible)
			end
		end

		function moduleApiTable:FocusChatBar()
			DispatchEvent("FocusChatBar")
		end

		function moduleApiTable:GetVisibility()
			local success, retVal = AttemptInvokeFunction("GetVisibility")
			if (success) then
				return retVal
			else
				return ChatWindowState.Visible
			end
		end

		function moduleApiTable:GetMessageCount()
			local success, retVal = AttemptInvokeFunction("GetMessageCount")
			if (success) then
				return retVal
			else
				return ChatWindowState.MessageCount
			end
		end

		function moduleApiTable:TopbarEnabledChanged(enabled)
			ChatWindowState.TopbarEnabled = enabled
			DispatchEvent("TopbarEnabledChanged", ChatWindowState.TopbarEnabled)
		end

		function moduleApiTable:IsFocused(useWasFocused)
			local success, retVal = AttemptInvokeFunction("IsFocused", useWasFocused)
			if (sucucess) then
				return retVal
			else
				return false
			end
		end

		moduleApiTable.ChatBarFocusChanged = Util.Signal()
		moduleApiTable.VisibilityStateChanged = Util.Signal()
		moduleApiTable.MessagesChanged = Util.Signal()



		StarterGui.CoreGuiChangedSignal:connect(function(coreGuiType, enabled)
			if (coreGuiType == Enum.CoreGuiType.All or coreGuiType == Enum.CoreGuiType.Chat) then
				ChatWindowState.CoreGuiEnabled = enabled
				DispatchEvent("CoreGuiEnabled", ChatWindowState.CoreGuiEnabled)
			end
		end)

		GuiService:AddSpecialKey(Enum.SpecialKey.ChatHotkey)
		GuiService.SpecialKeyPressed:connect(function(key, modifiers)
			DispatchEvent("SpecialKeyPressed", key, modifiers)
		end)

		StarterGui:RegisterSetCore("ChatMakeSystemMessage", function(data)
			local event = FindInCollectionByKeyAndType(communicationsConnections.SetCore, "ChatMakeSystemMessage", "BindableEvent")
			if (event) then
				event:Fire(data)
			else
				table.insert(MakeSystemMessageCache, data)
			end
		end)

		DoConnectGetCore("ChatWindowPosition")
		DoConnectGetCore("ChatWindowSize")
		DoConnectGetCore("ChatBarDisabled")

		local function RegisterCoreGuiConnections(containerTable)
			if (type(containerTable) == "table") then
				local chatWindowCollection = containerTable.ChatWindow
				local setCoreCollection = containerTable.SetCore
				local getCoreCollection = containerTable.GetCore

				if (type(chatWindowCollection) == "table") then
					for i, v in pairs(eventConnections) do
						v:disconnect()
					end

					eventConnections = {}
					communicationsConnections.ChatWindow = {}

					communicationsConnections.ChatWindow.ToggleVisibility = FindInCollectionByKeyAndType(chatWindowCollection, "ToggleVisibility", "BindableEvent")
					communicationsConnections.ChatWindow.SetVisible = FindInCollectionByKeyAndType(chatWindowCollection, "SetVisible", "BindableEvent")
					communicationsConnections.ChatWindow.FocusChatBar = FindInCollectionByKeyAndType(chatWindowCollection, "FocusChatBar", "BindableEvent")
					communicationsConnections.ChatWindow.TopbarEnabledChanged = FindInCollectionByKeyAndType(chatWindowCollection, "TopbarEnabledChanged", "BindableEvent")
					communicationsConnections.ChatWindow.IsFocused = FindInCollectionByKeyAndType(chatWindowCollection, "IsFocused", "BindableFunction")
					communicationsConnections.ChatWindow.SpecialKeyPressed = FindInCollectionByKeyAndType(chatWindowCollection, "SpecialKeyPressed", "BindableEvent")


					local function DoConnect(index)
						communicationsConnections.ChatWindow[index] = FindInCollectionByKeyAndType(chatWindowCollection, index, "BindableEvent")
						if (communicationsConnections.ChatWindow[index]) then
							local con = communicationsConnections.ChatWindow[index].Event:connect(function(...) moduleApiTable[index]:fire(...) end)
							table.insert(eventConnections, con)
						end
					end

					DoConnect("ChatBarFocusChanged")
					DoConnect("VisibilityStateChanged")
					DoConnect("MessagesChanged")

					local index = "MessagePosted"
					communicationsConnections.ChatWindow[index] = FindInCollectionByKeyAndType(chatWindowCollection, index, "BindableEvent")
					if (communicationsConnections.ChatWindow[index]) then
						local con = communicationsConnections.ChatWindow[index].Event:connect(function(message) game:GetService("Players"):Chat(message) end)
						table.insert(eventConnections, con)
					end

					moduleApiTable:SetVisible(ChatWindowState.Visible)
					moduleApiTable:TopbarEnabledChanged(ChatWindowState.TopbarEnabled)

					local event = FindInCollectionByKeyAndType(chatWindowCollection, "CoreGuiEnabled", "BindableEvent")
					if (event) then
						communicationsConnections.ChatWindow.CoreGuiEnabled = event
						event:Fire(ChatWindowState.CoreGuiEnabled)
					end

				else
					error("Table 'ChatWindow' must be provided!")

				end

				if (type(setCoreCollection) == "table" and type(getCoreCollection) == "table") then
					communicationsConnections.SetCore = {}
					communicationsConnections.GetCore = {}

					local event = FindInCollectionByKeyAndType(setCoreCollection, "ChatMakeSystemMessage", "BindableEvent")
					if (event) then
						communicationsConnections.SetCore.ChatMakeSystemMessage = event
						for i, messageData in pairs(MakeSystemMessageCache) do
							pcall(function() StarterGui:SetCore("ChatMakeSystemMessage", messageData) end)
						end
						MakeSystemMessageCache = {}
					end

					communicationsConnections.GetCore.ChatWindowPosition = FindInCollectionByKeyAndType(getCoreCollection, "ChatWindowPosition", "BindableFunction")
					communicationsConnections.GetCore.ChatWindowSize = FindInCollectionByKeyAndType(getCoreCollection, "ChatWindowSize", "BindableFunction")
					communicationsConnections.GetCore.ChatBarDisabled = FindInCollectionByKeyAndType(getCoreCollection, "ChatBarDisabled", "BindableFunction")

				elseif (type(setCoreCollection) ~= nil or type(getCoreCollection) ~= nil) then
					error("Both 'SetCore' and 'GetCore' must be tables if provided!")

				end

			end
		end

		StarterGui:RegisterSetCore("CoreGuiChatConnections", RegisterCoreGuiConnections)

end

return moduleApiTable
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8B4DDB22FD8F465DAA843C36C91CFC37">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerPermissionsModule</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local PlayerPermissionsModule = {}

local function HasRankInGroupFunctionFactory(groupId, requiredRank)
	local hasRankCache = {}
	assert(type(requiredRank) == "number", "requiredRank must be a number")
	return function(player)
		if player and player.UserId > 0 then
			if hasRankCache[player.UserId] == nil then
				local hasRank = false
				pcall(function()
					hasRank = player:GetRankInGroup(groupId) >= requiredRank
				end)
				hasRankCache[player.UserId] = hasRank
			end
			return hasRankCache[player.UserId]
		end
		return false
	end
end

local function IsInGroupFunctionFactory(groupId)
	local inGroupCache = {}
	return function(player)
		if player and player.UserId > 0 then
			if inGroupCache[player.UserId] == nil then
				local inGroup = false
				pcall(function()
					inGroup = player:IsInGroup(groupId)
				end)
				inGroupCache[player.UserId] = inGroup
			end
			return inGroupCache[player.UserId]
		end
		return false
	end
end

PlayerPermissionsModule.IsPlayerAdminAsync = IsInGroupFunctionFactory(1200769)
PlayerPermissionsModule.IsPlayerInternAsync = HasRankInGroupFunctionFactory(2868472, 100)

return PlayerPermissionsModule]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXE020735EDC4C4F15AF38B741E7B77D2C">
				<Properties>
					<string name="Name">Common</string>
				</Properties>
				<Item class="ModuleScript" referent="RBXCAF49943604240E3A99DA296F8399341">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Http</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
                // Http.lua

                // API for making http calls into roblox endpoints
]]
local HttpService = game:GetService('HttpService')
local HttpRbxApiService = game:GetService('HttpRbxApiService')

local Http = {} -- module return table

local BaseUrl = game:GetService('ContentProvider').BaseUrl:lower()
BaseUrl = string.gsub(BaseUrl, "/m.", "/www.")
BaseUrl = string.gsub(BaseUrl, "http://", "https://")

local AssetGameBaseUrl = string.gsub(BaseUrl, "https://www.", "https://assetgame.")


function Http.GetBaseUrl()
    return BaseUrl
end
function Http.GetAssetGameBaseUrl()
    return AssetGameBaseUrl
end

function Http.DecodeJSON(json)
    local success, result = pcall(function()
        return HttpService:JSONDecode(json)
    end)
    if not success then
        print("Http.DecodeJSON() failed because", result, "for input:", json)
        return
    end

    return result
end

function Http.EncodeJSON(jsonTable)
    local success, result = pcall(function()
        return HttpService:JSONEncode(jsonTable)
    end)
    if not success then
        print("Http.EncodeJSON() failed because", result)
        return
    end

    return result
end

function Http.RbxGetAsync(path, returnRaw)
    local success, result = pcall(function()
        return game:HttpGetAsync(path)
    end)
    if not success then
        print("Http.RbxGetAsync() failed because", result, "for path:", path)
        return
    end

    if returnRaw then
        return result
    end
    
    return Http.DecodeJSON(result)
end

function Http.RbxPostAsync(path, returnRaw)
    local success, result = pcall(function()
        return game:HttpPostAsync(path, '')
    end)
    if not success then
        print("Http.RbxPostAsync() failed because", result, "for path:", path)
        return
    end

    if returnRaw then
        return result
    end

    return Http.DecodeJSON(result)
end

function Http.RbxApiGetAsync(path, throttlePriority, returnRaw)
    -- throttlePriority: defaults to Enum.ThrottlingPriority.Default through reflection
    local success, result = pcall(function()
        return HttpRbxApiService:GetAsync(path, throttlePriority)
    end)
    if not success then
        print("Http.RbxApiGetAsync() failed because", result, "for path:", path)
        return
    end

    if returnRaw then
        return result
    end

    return Http.DecodeJSON(result)
end

function Http.RbxApiPostAsync(path, params, throttlePriority, contentType, returnRaw)
    -- throttlePriority: defaults to Enum.ThrottlingPriority.Default through reflection
    -- contentType: defaults to Enum.HttpContentType.ApplicationJson through reflection
    local success, result = pcall(function()
        return HttpRbxApiService:PostAsync(path, params, throttlePriority, contentType)
    end)

    if not success then
        print("Http.RbxApiPostAsync() failed because", result, "for path:", path)
        return
    end

    if returnRaw then
        return result
    end

    return Http.DecodeJSON(result)
end

return Http
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9FAA27873B1544C29343FF9CAD18823E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ObjectPool</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--	// FileName: ObjectPool.lua
--	// Written by: TheGamer101
--	// Description: An object pool class used to avoid unnecessarily instantiating Instances.

local module = {}
--////////////////////////////// Include
--//////////////////////////////////////
local modulesFolder = script.Parent
local ClassMaker = require(modulesFolder:WaitForChild("ClassMaker"))

--////////////////////////////// Methods
--//////////////////////////////////////
local methods = {}

function methods:GetInstance(className)
  if self.InstancePoolsByClass[className] == nil then
    self.InstancePoolsByClass[className] = {}
  end
  local availableInstances = #self.InstancePoolsByClass[className]
  if availableInstances > 0 then
    local instance = self.InstancePoolsByClass[className][availableInstances]
    table.remove(self.InstancePoolsByClass[className])
    return instance
  end
  return Instance.new(className)
end

function methods:ReturnInstance(instance)
  if self.InstancePoolsByClass[instance.ClassName] == nil then
    self.InstancePoolsByClass[instance.ClassName] = {}
  end
  if #self.InstancePoolsByClass[instance.ClassName] < self.PoolSizePerType then
    table.insert(self.InstancePoolsByClass[instance.ClassName], instance)
  else
    instance:Destroy()
  end
end

--///////////////////////// Constructors
--//////////////////////////////////////
ClassMaker.RegisterClassType("ObjectPool", methods)

function module.new(poolSizePerType)
	local obj = {}
	obj.InstancePoolsByClass = {}
	obj.Name = "ObjectPool"
  obj.PoolSizePerType = poolSizePerType

	ClassMaker.MakeClass("ObjectPool", obj)

	return obj
end

return module
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA31F0FF8607C47ABBAD27E5F94C86BA4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClassMaker</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--	// FileName: ClassMaker.lua
--	// Written by: Xsitsu
--	// Description: Really basic class maker module.

local classes = {}

local function ToStringFunction(tbl)
	return string.format("%s: %s", tbl.__ClassName, tbl.MemoryLocation)
end

local function NotValidMemberErrorFunction(tbl, index)
	error(string.format("%s is not a valid member of %s", index, tbl.__ClassName), 3)
end

local function DumpFunction(self)
	return tostring(self)
end

local function IsAFunction(self, classType)
	return (self.__ClassName == classType)
end

local module = {}

function module.RegisterClassType(classType, classMethods)
	if (not classes[classType]) then
		local metatable = {}
		metatable.__metatable = "The metatable is locked"
		metatable.__tostring = ToStringFunction
		metatable.__newindex = function() NotValidMemberErrorFunction() end

		metatable.__ClassName = classType

		local useClassMethods = {}
		useClassMethods.Dump = DumpFunction
		useClassMethods.IsA = IsAFunction

		for i, v in pairs(classMethods) do
			useClassMethods[i] = v
		end
		metatable.__ClassMethods = useClassMethods

		metatable.__index = function(tbl, index)
			local rVal = rawget(tbl, index) or rawget(metatable.__ClassMethods, index) or rawget(metatable, index)
			if (rVal) then return rVal end
			NotValidMemberErrorFunction(tbl, index)
		end

		classes[classType] = metatable
	else
		error(string.format("Class of type '%s' already exists.", classType))
	end
end

function module.MakeClass(classType, classProperties)
	if (classes[classType]) then
		classProperties.MemoryLocation = tostring(classProperties):match("[0123456789ABCDEF]+")
		return setmetatable(classProperties, classes[classType])
	else
		error(string.format("Class of type '%s' does not exist.", classType))
	end
end

return module
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5C05C9C67FDA4AEEA9E581F59D283CD2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ForceUseNewChat</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[---Change to true to force new chat on.
return false
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE2E0FEC39AE6422D9AF062F862375517">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CommonUtil</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source">return {}</ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX80435099A91D4718A66572CBBD14FAE0">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LoadingScreen3D</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[-- LoadingScreen3D.lua --
-- Written by Kip Turner, copyright ROBLOX 2016 --

local GUI_DISTANCE_FROM_CAMERA = 6
local VERTICAL_SCREEN_PERCENT = 1/3
local HORIZONTAL_SCREEN_PERCENT = 1/3
local SECOND_TO_FADE = 2.5
local ROTATIONS_PER_SECOND = 0.5
local TEXT_SCROLL_SPEED = 25

local CoreGui = game:GetService('CoreGui')
local RunService = game:GetService('RunService')
local MarketPlaceService = game:GetService('MarketplaceService')
local UserInputService = game:GetService('UserInputService')
local ReplicatedFirst = game:GetService('ReplicatedFirst')
local GuiService = game:GetService('GuiService')

local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local Util = require(RobloxGui.Modules.Settings.Utility)

local function FadeElements(element, newValue, duration)
	duration = duration or 0.5
	if element == nil then return end
	if element:IsA('ImageLabel') or element:IsA('ImageButton') then
		Util:TweenProperty(element, 'ImageTransparency', element.ImageTransparency, newValue, duration, Util:GetEaseInOutQuad())
	end
	if element:IsA('GuiObject') then
		Util:TweenProperty(element, 'BackgroundTransparency', element.BackgroundTransparency, newValue, duration, Util:GetEaseInOutQuad())
	end
	if element:IsA('TextLabel') or element:IsA('TextBox') or element:IsA('TextButton') then
		Util:TweenProperty(element, 'TextTransparency', element.TextTransparency, newValue, duration, Util:GetEaseInOutQuad())
	end
	for _, child in pairs(element:GetChildren()) do
		FadeElements(child, newValue, duration)
	end
end


local GameInfoProvider = {}
do
	local LoadingFinishedSignal = Instance.new('BindableEvent')
	GameInfoProvider.Finished = false
	GameInfoProvider.GameAssetInfo = nil
	GameInfoProvider.LoadingFinishedEvent = LoadingFinishedSignal.Event
	
	function GameInfoProvider:GetGameName()
		if self.GameAssetInfo ~= nil then
			return self.GameAssetInfo.Name
		else
			return ''
		end
	end

	function GameInfoProvider:GetCreatorName()
		if self.GameAssetInfo ~= nil then
			return self.GameAssetInfo.Creator.Name
		else
			return ''
		end
	end

	function GameInfoProvider:IsReady()
		return self.Finished
	end

	function GameInfoProvider:LoadAssetsAsync()
		spawn(function()
			while game.PlaceId <= 0 do
				wait()
			end

			-- load game asset info
			local success, result = pcall(function()
				self.GameAssetInfo = MarketPlaceService:GetProductInfo(game.PlaceId)
			end)
			if not success then
				print("LoadingScript->GameInfoProvider:LoadAssets:", result)
			end
			self.Finished = true
			LoadingFinishedSignal:Fire()
		end)
	end
end




local LoadingScreen = {}


local surfaceGuiAdorn = Util:Create'Part'
{
	Name = "LoadingGui";
	Transparency = 1;
	CanCollide = false;
	Anchored = true;
	Archivable = false;
	FormFactor = Enum.FormFactor.Custom;
	RobloxLocked = true;
	Parent = workspace.CurrentCamera;
}

local loadingSurfaceGui = Util:Create'SurfaceGui'
{
	Name = "LoadingSurfaceGui";
	Adornee = surfaceGuiAdorn;
	ToolPunchThroughDistance = 1000;
	CanvasSize = Vector2.new(500, 500);
	Archivable = false;
	Parent = CoreGui;
}

local backgroundImage = Util:Create'ImageLabel'
{
	Name = 'LoadingBackground';
	Size = UDim2.new(1,0,1,0);
	Image = 'rbxasset://textures/ui/LoadingScreen/BackgroundLight.png';
	ScaleType = Enum.ScaleType.Slice;
	SliceCenter = Rect.new(70,70,110,110);
	BackgroundTransparency = 1;
	Parent = loadingSurfaceGui;
}

local spinnerRotation = 0
local spinnerImage = Util:Create'ImageLabel'
{
	Name = 'Spinner';
	Size = UDim2.new(0.25,0,0.25,0);
	Position = UDim2.new(0.5 - (0.25/2), 0, 0.45 - (0.25/2), 0);
	Image = 'rbxasset://textures/ui/LoadingScreen/LoadingSpinner.png';
	BackgroundTransparency = 1;
	Parent = backgroundImage;
}


local loadingText = Util:Create'TextLabel'
{
	Name = 'LoadingText';
	Text = 'Loading...';
	BackgroundTransparency = 1;
	Font = Enum.Font.SourceSans;
	FontSize = Enum.FontSize.Size60;
	Position = UDim2.new(0.5,0,0.2,0);
	Parent = backgroundImage;
}

local gameNameText = Util:Create'TextLabel'
{
	Name = 'GameNameText';
	Text = '';
	BackgroundTransparency = 1;
	Font = Enum.Font.SourceSans;
	FontSize = Enum.FontSize.Size60;
	Size = UDim2.new(0.9, 0, 0.1, 0);
	Position = UDim2.new(0.05,0,0.65,0);
	ClipsDescendants = true;
	Parent = backgroundImage;
}


local creatorTextContainer = Util:Create'Frame'
{
	Name = 'CreatorTextContainer';
	Size = UDim2.new(0.9, 0, 0.1, 0);
	Position = UDim2.new(0.05,0,0.77,0);
	BackgroundTransparency = 1;
	ClipsDescendants = true;
	Parent = backgroundImage;
}

local creatorTextPosition = 0
local creatorText = Util:Create'TextLabel'
{
	Name = 'CreatorText';
	Text = '';
	BackgroundTransparency = 1;
	Font = Enum.Font.SourceSans;
	FontSize = Enum.FontSize.Size42;
	Size = UDim2.new(1, 0, 1, 0);
	Parent = creatorTextContainer;
}


local function ScreenDimsAtDepth(depth)
	local camera = workspace.CurrentCamera
	if camera then
		local aspectRatio = camera.ViewportSize.x / camera.ViewportSize.y
		local studHeight = 2 * depth * math.tan(math.rad(camera.FieldOfView/2))
		local studWidth = studHeight * aspectRatio

		return Vector2.new(studWidth, studHeight)
	end
	return Vector2.new(0,0)
end

local CleanedUp = false
local freeze = true
delay(2.5, function()
	freeze = false
end)
local function UpdateLayout(delta)
	local screenDims = ScreenDimsAtDepth(GUI_DISTANCE_FROM_CAMERA)

	surfaceGuiAdorn.Size = Vector3.new(screenDims.x * HORIZONTAL_SCREEN_PERCENT, screenDims.y * VERTICAL_SCREEN_PERCENT, 1)
	local camera = workspace.CurrentCamera
	if camera then
		surfaceGuiAdorn.Parent = camera
	end


	if creatorText.TextBounds.X < creatorTextContainer.AbsoluteSize.X then
		creatorText.Position = UDim2.new(0, 0, 0, 0)
		creatorText.Size = UDim2.new(1, 0, 1, 0)
	elseif delta ~= nil then
		creatorText.Size = UDim2.new(0, creatorText.TextBounds.X, 1, 0)
		if not freeze then
			local newX = (creatorTextPosition - delta * TEXT_SCROLL_SPEED)
			if newX + creatorText.AbsoluteSize.X < creatorTextContainer.AbsoluteSize.X then
				freeze = true
				spawn(function()
					Util:TweenProperty(creatorText, 'TextTransparency', creatorText.TextTransparency, 1, 1, Util:GetEaseInOutQuad())
					wait(1.5)
					if CleanedUp then return end
					creatorTextPosition = 0
					Util:TweenProperty(creatorText, 'TextTransparency', creatorText.TextTransparency, 0, 1, Util:GetEaseInOutQuad())
					wait(1.5)
					freeze = false
				end)
			else
				creatorTextPosition = newX
			end
		end
		creatorText.Position = UDim2.new(0, creatorTextPosition, 0, 0)
	end

	if not gameNameText.TextFits then
		gameNameText.Size = UDim2.new(0.9, 0, 0.3, 0)
		gameNameText.Position = UDim2.new(0.05,0,0.5,0)
		gameNameText.TextScaled = true
		gameNameText.TextWrapped = true

		spinnerImage.Position = UDim2.new(0.5 - (0.25/2), 0, 0.225, 0)
		loadingText.Position = UDim2.new(0.5,0,0.15,0)
	end

end

local CameraChangedConn = nil
local WorkspaceChangedConn = nil

local function CleanUp()
	if CleanedUp then return end
	CleanedUp = true

	FadeElements(loadingSurfaceGui, 1, SECOND_TO_FADE)
	wait(SECOND_TO_FADE)

	RunService:UnbindFromRenderStep("LoadingGui3D")
	surfaceGuiAdorn.Parent = nil
	if CameraChangedConn then
		CameraChangedConn:disconnect()
		CameraChangedConn = nil
	end
	if WorkspaceChangedConn then
		WorkspaceChangedConn:disconnect()
		WorkspaceChangedConn = nil
	end
end

local function OnGameInfoLoaded()
	local creatorName = GameInfoProvider:GetCreatorName()
	if creatorName and creatorName ~= '' then
		creatorName = string.format("By %s", tostring(creatorName))
	end
	gameNameText.Text = GameInfoProvider:GetGameName()
	creatorText.Text = creatorName
end

local function OnReplicatingFinishedAsync()
	local function OnGameLoaded()
		CleanUp()
	end

	if game:IsLoaded() then
		OnGameLoaded()
	else
		game.Loaded:wait()
		OnGameLoaded()
	end
end

local function OnDefaultLoadingGuiRemoved()
	CleanUp()
end


local function UpdateSurfaceGuiPosition()
	local camera = workspace.CurrentCamera
	if camera then
		local cameraCFrame = camera.CFrame
		local cameraLook = cameraCFrame.lookVector

		surfaceGuiAdorn.CFrame = (cameraCFrame * CFrame.Angles(0,math.pi,0)) + cameraLook * GUI_DISTANCE_FROM_CAMERA
	end
end

do
	local lastUpdate = tick()
	RunService:BindToRenderStep("LoadingGui3D", Enum.RenderPriority.Last.Value, function()
		local now = tick()
		local delta = now - lastUpdate

		UpdateSurfaceGuiPosition()
		UpdateLayout(delta)

		local rotation = delta * ROTATIONS_PER_SECOND * 360
		spinnerRotation = spinnerRotation + rotation
		spinnerImage.Rotation = spinnerRotation

		lastUpdate = now
	end)
	UpdateSurfaceGuiPosition()
	UpdateLayout()

	local function connectCameraEvent()
		if workspace.CurrentCamera then
			if CameraChangedConn then
				CameraChangedConn:disconnect()
			end
			CameraChangedConn = workspace.CurrentCamera.Changed:connect(function(prop)
				if prop == 'CFrame' then
					UpdateSurfaceGuiPosition()
				end
			end)
		end
	end
	WorkspaceChangedConn = workspace.Changed:connect(function(prop)
		if prop == 'CurrentCamera' then
			connectCameraEvent()
		end
	end)

	connectCameraEvent()
end

GameInfoProvider:LoadAssetsAsync()
if GameInfoProvider:IsReady() then
	OnGameInfoLoaded()
end
GameInfoProvider.LoadingFinishedEvent:connect(OnGameInfoLoaded)


if ReplicatedFirst:IsFinishedReplicating() then
	spawn(OnReplicatingFinishedAsync)
else
	ReplicatedFirst.FinishedReplicating:connect(OnReplicatingFinishedAsync)
end

if ReplicatedFirst:IsDefaultLoadingGuiRemoved() then
	OnDefaultLoadingGuiRemoved()
else
	ReplicatedFirst.RemoveDefaultLoadingGuiSignal:connect(OnDefaultLoadingGuiRemoved)
end

GuiService.ErrorMessageChanged:connect(function()
	-- TODO
end)

GuiService.UiMessageChanged:connect(function(type, newMessage)
	-- TODO
end)

return LoadingScreen

]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX50CBFE1F65524182A3E53E05F39C2ADF">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ChatSelector</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	// FileName: ChatSelector.lua
	// Written by: Xsitsu
	// Description: Code for determining which chat version to use in game.
]]

local FORCE_IS_CONSOLE = false
local FORCE_IS_VR = false

local CoreGuiService = game:GetService("CoreGui")
local RobloxGui = CoreGuiService:WaitForChild("RobloxGui")
local Modules = RobloxGui:WaitForChild("Modules")
local Common = Modules:WaitForChild("Common")
local FORCE_UseNewChat = require(Common:WaitForChild("ForceUseNewChat"))

local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")

local Players = game:GetService("Players")

local Util = require(RobloxGui.Modules.ChatUtil)

local function GetUseLuaFlag()
	local loop_continue = true
	while loop_continue do
		local success, retVal = pcall(function()
			return game.IsSFFlagsLoaded
		end)
		if not success then
			loop_continue = false
		elseif retVal then
			loop_continue = false
		else
			wait(0.1)
		end
	end

	local success, retVal = pcall(function() return game:GetService("Chat"):GetShouldUseLuaChat() end)
	local useNewChat = success and retVal
	return useNewChat
end

local readFlagSuccess, flagEnabled = pcall(function() return settings():GetFFlag("CorescriptNewLoadChat") end)
local TryLoadNewChat = readFlagSuccess and flagEnabled


local useModule = nil

local state = {Visible = true}
local interface = {}
do
	function interface:GetNewLuaChatFlag()
		return GetUseLuaFlag() or FORCE_UseNewChat
	end

	function interface:ToggleVisibility()
		if (useModule) then
			useModule:ToggleVisibility()
		else
			state.Visible = not state.Visible
		end
	end

	function interface:SetVisible(visible)
		if (useModule) then
			useModule:SetVisible(visible)
		else
			state.Visible = visible
		end
	end

	function interface:FocusChatBar()
		if (useModule) then
			useModule:FocusChatBar()
		end
	end

	function interface:GetVisibility()
		if (useModule) then
			return useModule:GetVisibility()
		else
			return state.Visible
		end
	end

	function interface:GetMessageCount()
		if (useModule) then
			return useModule:GetMessageCount()
		else
			return 0
		end
	end

	function interface:TopbarEnabledChanged(...)
		if (useModule) then
			return useModule:TopbarEnabledChanged(...)
		end
	end

	function interface:IsFocused(useWasFocused)
		if (useModule) then
			return useModule:IsFocused(useWasFocused)
		else
			return false
		end
	end

	interface.ChatBarFocusChanged = Util.Signal()
	interface.VisibilityStateChanged = Util.Signal()
	interface.MessagesChanged = Util.Signal()
end

local StopQueueingSystemMessages = false
local MakeSystemMessageQueue = {}
local function MakeSystemMessageQueueingFunction(data)
	if (StopQueueingSystemMessages) then return end
	table.insert(MakeSystemMessageQueue, data)
end

local function NonFunc() end
StarterGui:RegisterSetCore("ChatMakeSystemMessage", MakeSystemMessageQueueingFunction)
StarterGui:RegisterSetCore("ChatWindowPosition", NonFunc)
StarterGui:RegisterSetCore("ChatWindowSize", NonFunc)
StarterGui:RegisterGetCore("ChatWindowPosition", NonFunc)
StarterGui:RegisterGetCore("ChatWindowSize", NonFunc)
StarterGui:RegisterSetCore("ChatBarDisabled", NonFunc)
StarterGui:RegisterGetCore("ChatBarDisabled", NonFunc)

local readChatActiveFlagSuccess, chatActiveEnabled = pcall(function() return settings():GetFFlag("CorescriptSetCoreChatActiveEnabled") end)
if readChatActiveFlagSuccess and chatActiveEnabled then
	StarterGui:RegisterGetCore("ChatActive", function()
		return interface:GetVisibility()
	end)
	StarterGui:RegisterSetCore("ChatActive", function(visible)
		return interface:SetVisible(visible)
	end)
end


local function ConnectSignals(useModule, interface, sigName)
	--// "MessagesChanged" event is not created for Studio Start Server
	if (useModule[sigName]) then
		useModule[sigName]:connect(function(...) interface[sigName]:fire(...) end)
	end
end

local isConsole = GuiService:IsTenFootInterface() or FORCE_IS_CONSOLE
local isVR = UserInputService.VREnabled or FORCE_IS_VR

if ( (TryLoadNewChat or FORCE_UseNewChat) and not isConsole and not isVR ) then
	spawn(function()
		local useNewChat = GetUseLuaFlag() or FORCE_UseNewChat
		local useModuleScript = useNewChat and RobloxGui.Modules.NewChat or RobloxGui.Modules.Chat
		useModule = require(useModuleScript)

		ConnectSignals(useModule, interface, "ChatBarFocusChanged")
		ConnectSignals(useModule, interface, "VisibilityStateChanged")

		while Players.LocalPlayer == nil do Players.ChildAdded:wait() end
		local LocalPlayer = Players.LocalPlayer

		if (LocalPlayer.ChatMode == Enum.ChatMode.TextAndMenu or RunService:IsStudio()) then
			ConnectSignals(useModule, interface, "MessagesChanged")
			StarterGui:RegisterGetCore("UseNewLuaChat", function() return useNewChat end)
		else
			--// Cause new chat window UI to not be created in Studio Start Server
			StarterGui:RegisterGetCore("UseNewLuaChat", function() return false end)
		end

		useModule:SetVisible(state.Visible)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Chat))

		StopQueueingSystemMessages = true
		for i, messageData in pairs(MakeSystemMessageQueue) do
			pcall(function() StarterGui:SetCore("ChatMakeSystemMessage", messageData) end)
		end
	end)
else
	useModule = require(RobloxGui.Modules.Chat)

	ConnectSignals(useModule, interface, "ChatBarFocusChanged")
	ConnectSignals(useModule, interface, "VisibilityStateChanged")

	while Players.LocalPlayer == nil do Players.ChildAdded:wait() end
	local LocalPlayer = Players.LocalPlayer

	if (LocalPlayer.ChatMode == Enum.ChatMode.TextAndMenu or RunService:IsStudio()) then
		ConnectSignals(useModule, interface, "MessagesChanged")
	end

	StarterGui:RegisterGetCore("UseNewLuaChat", function() return false end)

end

return interface
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8031313AEE8B406EA3BD42F664757039">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ChatUtil</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local Util = {}
do
	function Util.Signal()
		local sig = {}

		local mSignaler = Instance.new('BindableEvent')

		local mArgData = nil
		local mArgDataCount = nil

		function sig:fire(...)
			mArgData = {...}
			mArgDataCount = select('#', ...)
			mSignaler:Fire()
		end

		function sig:connect(f)
			if not f then error("connect(nil)", 2) end
			return mSignaler.Event:connect(function()
				f(unpack(mArgData, 1, mArgDataCount))
			end)
		end

		function sig:wait()
			mSignaler.Event:wait()
			assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
			return unpack(mArgData, 1, mArgDataCount)
		end

		return sig
	end
end

return Util]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX74E755D55E194424A686F925EE7AE1C6">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackScript</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[-- Backpack Version 5.01
-- OnlyTwentyCharacters, SolarCrane

-------------------
--| Exposed API |--
-------------------

local BackpackScript = {}
BackpackScript.OpenClose = nil -- Function to toggle open/close
BackpackScript.IsOpen = false
BackpackScript.StateChanged = Instance.new('BindableEvent') -- Fires after any open/close, passes IsNowOpen

---------------------
--| Configurables |--
---------------------

local ICON_SIZE = 60
local FONT_SIZE = Enum.FontSize.Size14
local ICON_BUFFER = 5

local BACKGROUND_FADE = 0.50
local BACKGROUND_COLOR = Color3.new(31/255, 31/255, 31/255)

local SLOT_DRAGGABLE_COLOR = Color3.new(49/255, 49/255, 49/255)
local SLOT_EQUIP_COLOR = Color3.new(90/255, 142/255, 233/255)
local SLOT_EQUIP_THICKNESS = 0.1 -- Relative
local SLOT_FADE_LOCKED = 0.50 -- Locked means undraggable
local SLOT_BORDER_COLOR = Color3.new(1, 1, 1) -- Appears when dragging

local TOOLTIP_BUFFER = 6
local TOOLTIP_HEIGHT = 16
local TOOLTIP_OFFSET = -25 -- From top

local ARROW_IMAGE_OPEN = 'rbxasset://textures/ui/Backpack_Open.png'
local ARROW_IMAGE_CLOSE = 'rbxasset://textures/ui/Backpack_Close.png'
local ARROW_SIZE = UDim2.new(0, 14, 0, 9)
local ARROW_HOTKEY = Enum.KeyCode.Backquote.Value --TODO: Hookup '~' too?
local ARROW_HOTKEY_STRING = '`'
local ARROW_HOVER_COLOR = Color3.new(0,162/255,1)

local HOTBAR_SLOTS_FULL = 10
local HOTBAR_SLOTS_VR = 6
local HOTBAR_SLOTS_MINI = 3
local HOTBAR_SLOTS_WIDTH_CUTOFF = 1024 -- Anything smaller is MINI
local HOTBAR_OFFSET_FROMBOTTOM = -30 -- Offset to make room for the Health GUI

local INVENTORY_ROWS_FULL = 4
local INVENTORY_ROWS_VR = 3
local INVENTORY_ROWS_MINI = 2
local INVENTORY_HEADER_SIZE = 40
local INVENTORY_ARROWS_BUFFER_VR = 40

local SEARCH_BUFFER = 5
local SEARCH_WIDTH = 200
local SEARCH_TEXT = "   Search"
local SEARCH_TEXT_OFFSET_FROMLEFT = 0
local SEARCH_BACKGROUND_COLOR = Color3.new(0.37, 0.37, 0.37)
local SEARCH_BACKGROUND_FADE = 0.15

local DOUBLE_CLICK_TIME = 0.5

local ZERO_KEY_VALUE = Enum.KeyCode.Zero.Value
local DROP_HOTKEY_VALUE = Enum.KeyCode.Backspace.Value

local GAMEPAD_INPUT_TYPES =
{
	[Enum.UserInputType.Gamepad1] = true;
	[Enum.UserInputType.Gamepad2] = true;
	[Enum.UserInputType.Gamepad3] = true;
	[Enum.UserInputType.Gamepad4] = true;
	[Enum.UserInputType.Gamepad5] = true;
	[Enum.UserInputType.Gamepad6] = true;
	[Enum.UserInputType.Gamepad7] = true;
	[Enum.UserInputType.Gamepad8] = true;
}

-----------------
--| Variables |--
-----------------
local PlayersService = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local StarterGui = game:GetService('StarterGui')
local GuiService = game:GetService('GuiService')
local CoreGui = game:GetService('CoreGui')
local ContextActionService = game:GetService('ContextActionService')
local RobloxGui = CoreGui:WaitForChild('RobloxGui')
RobloxGui:WaitForChild("Modules"):WaitForChild("TenFootInterface")
local IsTenFootInterface = require(RobloxGui.Modules.TenFootInterface):IsEnabled()
local Utility = require(RobloxGui.Modules.Settings.Utility)
local TopbarEnabled = true

if IsTenFootInterface then
	ICON_SIZE = 100
	FONT_SIZE = Enum.FontSize.Size24
end

local GamepadActionsBound = false

local IS_PHONE = UserInputService.TouchEnabled and GuiService:GetScreenResolution().X < HOTBAR_SLOTS_WIDTH_CUTOFF

local Player = PlayersService.LocalPlayer

local MainFrame = nil
local HotbarFrame = nil
local OpenInventoryButton = nil
local CloseInventoryButton = nil
local InventoryFrame = nil
local ScrollingFrame = nil
local ScrollUpInventoryButton = nil
local ScrollDownInventoryButton = nil

local Character = nil
local Humanoid = nil
local Backpack = nil

local Slots = {} -- List of all Slots by index
local LowestEmptySlot = nil
local SlotsByTool = {} -- Map of Tools to their assigned Slots
local HotkeyFns = {} -- Map of KeyCode values to their assigned behaviors
local Dragging = {} -- Only used to check if anything is being dragged, to disable other input
local FullHotbarSlots = 0 -- Now being used to also determine whether or not LB and RB on the gamepad are enabled.
local ActiveHopper = nil -- NOTE: HopperBin
local StarterToolFound = false -- Special handling is required for the gear currently equipped on the site
local WholeThingEnabled = false
local TextBoxFocused = false -- ANY TextBox, not just the search box
local ResultsIndices = nil -- Results of a search, or nil
local HotkeyStrings = {} -- Used for eating/releasing hotkeys
local CharConns = {} -- Holds character connections to be cleared later
local GamepadEnabled = false -- determines if our gui needs to be gamepad friendly

local IsVR = UserInputService.VREnabled -- Are we currently using a VR device?
local NumberOfHotbarSlots = IsVR and HOTBAR_SLOTS_VR or (IS_PHONE and HOTBAR_SLOTS_MINI or HOTBAR_SLOTS_FULL) -- Number of slots shown at the bottom
local NumberOfInventoryRows = IsVR and INVENTORY_ROWS_VR or (IS_PHONE and INVENTORY_ROWS_MINI or INVENTORY_ROWS_FULL) -- How many rows in the popped-up inventory

local lastEquippedSlot = nil

-----------------
--| Functions |--
-----------------

local function NewGui(className, objectName)
	local newGui = Instance.new(className)
	newGui.Name = objectName
	newGui.BackgroundColor3 = Color3.new(0, 0, 0)
	newGui.BackgroundTransparency = 1
	newGui.BorderColor3 = Color3.new(0, 0, 0)
	newGui.BorderSizePixel = 0
	newGui.Size = UDim2.new(1, 0, 1, 0)
	if className:match('Text') then
		newGui.TextColor3 = Color3.new(1, 1, 1)
		newGui.Text = ''
		newGui.Font = Enum.Font.SourceSans
		newGui.FontSize = FONT_SIZE
		newGui.TextWrapped = true
		if className == 'TextButton' then
			newGui.Font = Enum.Font.SourceSansBold
			newGui.BorderSizePixel = 1
		end
	end
	return newGui
end

local function FindLowestEmpty()
	for i = 1, NumberOfHotbarSlots do
		local slot = Slots[i]
		if not slot.Tool then
			return slot
		end
	end
	return nil
end

local function isInventoryEmpty()
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		if slot and slot.Tool then
			return false
		end
	end
	return true
end

local function UseGazeSelection()
	return UserInputService.VREnabled
end

local function AdjustHotbarFrames()
	local inventoryOpen = InventoryFrame.Visible -- (Show all)
	local visualTotal = (inventoryOpen) and NumberOfHotbarSlots or FullHotbarSlots
	local visualIndex = 0
	local hotbarIsVisible = (visualTotal >= 1)

	for i = 1, NumberOfHotbarSlots do
		local slot = Slots[i]
		if slot.Tool or inventoryOpen then
			visualIndex = visualIndex + 1
			slot:Readjust(visualIndex, visualTotal)
			slot.Frame.Visible = true
		else
			slot.Frame.Visible = false
		end
	end

	OpenInventoryButton.Visible = not inventoryOpen and (hotbarIsVisible or not isInventoryEmpty())
	OpenInventoryButton.Position = UDim2.new(0.5, -15, 1, hotbarIsVisible and -110 or -50)
end

local function AdjustInventoryFrames()
	local lowestPoint = 0
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		slot:Reposition()
		slot.Frame.Visible = (slot.Tool ~= nil)
		lowestPoint = math.max(lowestPoint, slot.Frame.Position.Y.Offset + slot.Frame.Size.Y.Offset)
	end
	ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, lowestPoint + ICON_BUFFER)
end

local function UpdateBackpackLayout()
	HotbarFrame.Size = UDim2.new(0, ICON_BUFFER + (NumberOfHotbarSlots * (ICON_SIZE + ICON_BUFFER)), 0, ICON_BUFFER + ICON_SIZE + ICON_BUFFER)
	HotbarFrame.Position = UDim2.new(0.5, -HotbarFrame.Size.X.Offset / 2, 1, -HotbarFrame.Size.Y.Offset)
	InventoryFrame.Size = UDim2.new(0, HotbarFrame.Size.X.Offset, 0, (HotbarFrame.Size.Y.Offset * NumberOfInventoryRows) + INVENTORY_HEADER_SIZE + (IsVR and 2*INVENTORY_ARROWS_BUFFER_VR or 0))
	InventoryFrame.Position = UDim2.new(0.5, -InventoryFrame.Size.X.Offset / 2, 1, HotbarFrame.Position.Y.Offset - InventoryFrame.Size.Y.Offset)

	ScrollingFrame.Size = UDim2.new(1, ScrollingFrame.ScrollBarThickness + 1, 1, -INVENTORY_HEADER_SIZE - (IsVR and 2*INVENTORY_ARROWS_BUFFER_VR or 0))
	ScrollingFrame.Position = UDim2.new(0, 0, 0, INVENTORY_HEADER_SIZE + (IsVR and INVENTORY_ARROWS_BUFFER_VR or 0))
	AdjustHotbarFrames()
	AdjustInventoryFrames()
end

local function Clamp(low, high, num)
	return math.min(high, math.max(low, num))
end

local function CheckBounds(guiObject, x, y)
	local pos = guiObject.AbsolutePosition
	local size = guiObject.AbsoluteSize
	return (x > pos.X and x <= pos.X + size.X and y > pos.Y and y <= pos.Y + size.Y)
end

local function GetOffset(guiObject, point)
	local centerPoint = guiObject.AbsolutePosition + (guiObject.AbsoluteSize / 2)
	return (centerPoint - point).magnitude
end

local function DisableActiveHopper() --NOTE: HopperBin
	ActiveHopper:ToggleSelect()
	SlotsByTool[ActiveHopper]:UpdateEquipView()
	ActiveHopper = nil
end

local function UnequipAllTools() --NOTE: HopperBin
	if Humanoid then
		Humanoid:UnequipTools()
		if ActiveHopper then
			DisableActiveHopper()
		end
	end
end

local function EquipNewTool(tool) --NOTE: HopperBin
	UnequipAllTools()
	if tool:IsA('HopperBin') then
		tool:ToggleSelect()
		SlotsByTool[tool]:UpdateEquipView()
		ActiveHopper = tool
	else
		--Humanoid:EquipTool(tool) --NOTE: This would also unequip current Tool
		tool.Parent = Character --TODO: Switch back to above line after EquipTool is fixed!
	end
end

local function IsEquipped(tool)
	return tool and ((tool:IsA('HopperBin') and tool.Active) or tool.Parent == Character) --NOTE: HopperBin
end

local function MakeSlot(parent, index)
	index = index or (#Slots + 1)

	-- Slot Definition --

	local slot = {}
	slot.Tool = nil
	slot.Index = index
	slot.Frame = nil

	local SlotFrame = nil
	local ToolIcon = nil
	local ToolName = nil
	local ToolChangeConn = nil
	local HighlightFrame = nil
	local SelectionObj = nil

	--NOTE: The following are only defined for Hotbar Slots
	local ToolTip = nil
	local SlotNumber = nil

	-- Slot Functions --

	local function UpdateSlotFading()
		if UserInputService.VREnabled then
			local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
			local BackpackPanel = Panel3D.Get("Backpack")

			local panelTransparency = BackpackPanel.transparency
			local slotTransparency = SLOT_FADE_LOCKED

			-- This equation multiplies the two transparencies together.
			local finalTransparency = panelTransparency + slotTransparency - panelTransparency * slotTransparency

			SlotFrame.BackgroundTransparency = finalTransparency
			SlotFrame.TextTransparency = finalTransparency
			if ToolIcon then
				ToolIcon.ImageTransparency = InventoryFrame.Visible and 0 or panelTransparency
			end
			if HighlightFrame then
				for _, child in pairs(HighlightFrame:GetChildren()) do
					child.BackgroundTransparency = finalTransparency
				end
			end

			SlotFrame.SelectionImageObject = SelectionObj
		else
			SlotFrame.SelectionImageObject = nil
			SlotFrame.BackgroundTransparency = (SlotFrame.Draggable) and 0 or SLOT_FADE_LOCKED
		end
		SlotFrame.BackgroundColor3 = (SlotFrame.Draggable) and SLOT_DRAGGABLE_COLOR or BACKGROUND_COLOR
	end

	function slot:Reposition()
		-- Slots are positioned into rows
		local index = (ResultsIndices and ResultsIndices[self]) or self.Index
		local sizePlus = ICON_BUFFER + ICON_SIZE

		local modSlots = 0
		modSlots = ((index - 1) % NumberOfHotbarSlots) + 1

		local row = 0
		row = (index > NumberOfHotbarSlots) and (math.floor((index - 1) / NumberOfHotbarSlots)) - 1 or 0

		SlotFrame.Position = UDim2.new(0, ICON_BUFFER + ((modSlots - 1) * sizePlus), 0, ICON_BUFFER + (sizePlus * row))
	end

	function slot:Readjust(visualIndex, visualTotal) --NOTE: Only used for Hotbar slots
		local centered = HotbarFrame.Size.X.Offset / 2
		local sizePlus = ICON_BUFFER + ICON_SIZE
		local midpointish = (visualTotal / 2) + 0.5
		local factor = visualIndex - midpointish
		SlotFrame.Position = UDim2.new(0, centered - (ICON_SIZE / 2) + (sizePlus * factor), 0, ICON_BUFFER)
	end

	function slot:Fill(tool)
		if not tool then
			return self:Clear()
		end

		self.Tool = tool

		local function assignToolData()
			local icon = tool.TextureId
			ToolIcon.Image = icon
			ToolName.Text = (icon == '') and tool.Name or '' -- (Only show name if no icon)
			if ToolTip and tool:IsA('Tool') then --NOTE: HopperBin
				ToolTip.Text = tool.ToolTip
				local width = ToolTip.TextBounds.X + TOOLTIP_BUFFER
				ToolTip.Size = UDim2.new(0, width, 0, TOOLTIP_HEIGHT)
				ToolTip.Position = UDim2.new(0.5, -width / 2, 0, TOOLTIP_OFFSET)
			end
		end
		assignToolData()

		if ToolChangeConn then
			ToolChangeConn:disconnect()
			ToolChangeConn = nil
		end

		ToolChangeConn = tool.Changed:connect(function(property)
			if property == 'TextureId' or property == 'Name' or property == 'ToolTip' then
				assignToolData()
			end
		end)

		local hotbarSlot = (self.Index <= NumberOfHotbarSlots)
		local inventoryOpen = InventoryFrame.Visible

		if (not hotbarSlot or inventoryOpen) and not UserInputService.VREnabled then
			SlotFrame.Draggable = true
		end

		self:UpdateEquipView()

		if hotbarSlot then
			FullHotbarSlots = FullHotbarSlots + 1
			-- If using a controller, determine whether or not we can enable BindCoreAction("RBXHotbarEquip", etc)
			if WholeThingEnabled then
				if FullHotbarSlots >= 1 and not GamepadActionsBound then
					-- Player added first item to a hotbar slot, enable BindCoreAction
					GamepadActionsBound = true
					ContextActionService:BindCoreAction("RBXHotbarEquip", changeToolFunc, false, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1)
				end
			end
		end

		SlotsByTool[tool] = self
		LowestEmptySlot = FindLowestEmpty()
	end

	function slot:Clear()
		if not self.Tool then return end

		if ToolChangeConn then
			ToolChangeConn:disconnect()
			ToolChangeConn = nil
		end

		ToolIcon.Image = ''
		ToolName.Text = ''
		if ToolTip then
			ToolTip.Text = ''
			ToolTip.Visible = false
		end
		SlotFrame.Draggable = false

		self:UpdateEquipView(true) -- Show as unequipped

		if self.Index <= NumberOfHotbarSlots then
			FullHotbarSlots = FullHotbarSlots - 1
			if FullHotbarSlots < 1 then
				-- Player removed last item from hotbar; UnbindCoreAction("RBXHotbarEquip"), allowing the developer to use LB and RB.
				GamepadActionsBound = false
				ContextActionService:UnbindCoreAction("RBXHotbarEquip")
			end
		end

		SlotsByTool[self.Tool] = nil
		self.Tool = nil
		LowestEmptySlot = FindLowestEmpty()
	end

	function slot:UpdateEquipView(unequippedOverride)
		if not unequippedOverride and IsEquipped(self.Tool) then -- Equipped
			lastEquippedSlot = slot
			if not HighlightFrame then
				HighlightFrame = NewGui('Frame', 'Equipped')
				HighlightFrame.ZIndex = SlotFrame.ZIndex
				local t = SLOT_EQUIP_THICKNESS
				local dataTable = { -- Relative sizes and positions
					{t,       1, 0,     0},
					{1 - 2*t, t, t,     0},
					{t,       1, 1 - t, 0},
					{1 - 2*t, t, t,     1 - t},
				}
				for _, data in pairs(dataTable) do
					local edgeFrame = NewGui('Frame', 'Edge')
					edgeFrame.BackgroundTransparency = 0
					edgeFrame.BackgroundColor3 = SLOT_EQUIP_COLOR
					edgeFrame.Size = UDim2.new(data[1], 0, data[2], 0)
					edgeFrame.Position = UDim2.new(data[3], 0, data[4], 0)
					edgeFrame.ZIndex = HighlightFrame.ZIndex
					edgeFrame.Parent = HighlightFrame
				end
			end
			HighlightFrame.Parent = SlotFrame
		else -- In the Backpack
			if HighlightFrame then
				HighlightFrame.Parent = nil
			end
		end
		UpdateSlotFading()
	end

	function slot:IsEquipped()
		return IsEquipped(self.Tool)
	end

	function slot:Delete()
		SlotFrame:Destroy() --NOTE: Also clears connections
		table.remove(Slots, self.Index)
		local newSize = #Slots

		-- Now adjust the rest (both visually and representationally)
		for i = self.Index, newSize do
			Slots[i]:SlideBack()
		end

		if newSize % NumberOfHotbarSlots == 0 then -- We lost a row at the bottom! Adjust the CanvasSize
			local lastSlot = Slots[newSize]
			local lowestPoint = lastSlot.Frame.Position.Y.Offset + lastSlot.Frame.Size.Y.Offset
			ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, lowestPoint + ICON_BUFFER)
		end
	end

	function slot:Swap(targetSlot) --NOTE: This slot (self) must not be empty!
		local myTool, otherTool = self.Tool, targetSlot.Tool
		self:Clear()
		if otherTool then -- (Target slot might be empty)
			targetSlot:Clear()
			self:Fill(otherTool)
		end
		if myTool then
			targetSlot:Fill(myTool)
		else
			targetSlot:Clear()
		end
	end

	function slot:SlideBack() -- For inventory slot shifting
		self.Index = self.Index - 1
		SlotFrame.Name = self.Index
		self:Reposition()
	end

	function slot:TurnNumber(on)
		if SlotNumber then
			SlotNumber.Visible = on
		end
	end

	function slot:SetClickability(on) -- (Happens on open/close arrow)
		if self.Tool then
			if UserInputService.VREnabled then
				SlotFrame.Draggable = false
			else
				SlotFrame.Draggable = not on
			end
			UpdateSlotFading()
		end
	end

	function slot:CheckTerms(terms)
		local hits = 0
		local function checkEm(str, term)
			local _, n = str:lower():gsub(term, '')
			hits = hits + n
		end
		local tool = self.Tool
		if tool then
			for term in pairs(terms) do
				checkEm(tool.Name, term)
				if tool:IsA('Tool') then --NOTE: HopperBin
					checkEm(tool.ToolTip, term)
				end
			end
		end
		return hits
	end

	-- Slot select logic, activated by clicking or pressing hotkey
		function slot:Select()
			local tool = slot.Tool
			if tool then
				if IsEquipped(tool) then --NOTE: HopperBin
					UnequipAllTools()
				elseif tool.Parent == Backpack then
					EquipNewTool(tool)
				end
			end
		end

	-- Slot Init Logic --

	SlotFrame = NewGui('TextButton', index)
	SlotFrame.BackgroundColor3 = BACKGROUND_COLOR
	SlotFrame.BorderColor3 = SLOT_BORDER_COLOR
	SlotFrame.Text = ""
	SlotFrame.AutoButtonColor = false
	SlotFrame.BorderSizePixel = 0
	SlotFrame.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
	SlotFrame.Active = true
	SlotFrame.Draggable = false
	SlotFrame.BackgroundTransparency = SLOT_FADE_LOCKED
	SlotFrame.MouseButton1Click:connect(function() changeSlot(slot) end)
	slot.Frame = SlotFrame

	do
		local selectionObjectClipper = NewGui('Frame', 'SelectionObjectClipper')
		selectionObjectClipper.Visible = false
		selectionObjectClipper.Parent = SlotFrame

		SelectionObj = NewGui('ImageLabel', 'Selector')
		SelectionObj.Size = UDim2.new(1, 0, 1, 0)
		SelectionObj.Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png"
		SelectionObj.ScaleType = Enum.ScaleType.Slice
		SelectionObj.SliceCenter = Rect.new(12,12,52,52)
		SelectionObj.Parent = selectionObjectClipper
	end


	ToolIcon = NewGui('ImageLabel', 'Icon')
	ToolIcon.Size = UDim2.new(0.8, 0, 0.8, 0)
	ToolIcon.Position = UDim2.new(0.1, 0, 0.1, 0)
	ToolIcon.Parent = SlotFrame

	ToolName = NewGui('TextLabel', 'ToolName')
	ToolName.Size = UDim2.new(1, -2, 1, -2)
	ToolName.Position = UDim2.new(0, 1, 0, 1)
	ToolName.Parent = SlotFrame

	slot:Reposition()

	if index <= NumberOfHotbarSlots then -- Hotbar-Specific Slot Stuff
		-- ToolTip stuff
		ToolTip = NewGui('TextLabel', 'ToolTip')
		ToolTip.TextWrapped = false
		ToolTip.TextYAlignment = Enum.TextYAlignment.Top
		ToolTip.BackgroundColor3 = Color3.new(0.4, 0.4, 0.4)
		ToolTip.BackgroundTransparency = 0
		ToolTip.Visible = false
		ToolTip.Parent = SlotFrame
		SlotFrame.MouseEnter:connect(function()
			if ToolTip.Text ~= '' then
				ToolTip.Visible = true
			end
		end)
		SlotFrame.MouseLeave:connect(function() ToolTip.Visible = false end)

		function slot:MoveToInventory()
			if slot.Index <= NumberOfHotbarSlots then -- From a Hotbar slot
				local tool = slot.Tool
				self:Clear() --NOTE: Order matters here
				local newSlot = MakeSlot(ScrollingFrame)
				newSlot:Fill(tool)
				if IsEquipped(tool) then -- Also unequip it --NOTE: HopperBin
					UnequipAllTools()
				end
				-- Also hide the inventory slot if we're showing results right now
				if ResultsIndices then
					newSlot.Frame.Visible = false
				end
			end
		end

		-- Show label and assign hotkeys for 1-9 and 0 (zero is always last slot when > 10 total)
		if index < 10 or index == NumberOfHotbarSlots then -- NOTE: Hardcoded on purpose!
			local slotNum = (index < 10) and index or 0
			SlotNumber = NewGui('TextLabel', 'Number')
			SlotNumber.Text = slotNum
			SlotNumber.Size = UDim2.new(0.15, 0, 0.15, 0)
			SlotNumber.Visible = false
			SlotNumber.Parent = SlotFrame
			HotkeyFns[ZERO_KEY_VALUE + slotNum] = slot.Select
		end
	else -- Inventory-Specific Slot Stuff

		local newRow = false
		newRow = (index % NumberOfHotbarSlots == 1)

		if newRow then -- We are the first slot of a new row! Adjust the CanvasSize
			local lowestPoint = SlotFrame.Position.Y.Offset + SlotFrame.Size.Y.Offset
			ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, lowestPoint + ICON_BUFFER)
		end

		-- Scroll to new inventory slot, if we're open and not viewing search results
		if InventoryFrame.Visible and not ResultsIndices then
			local offset = ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteSize.Y
			ScrollingFrame.CanvasPosition = Vector2.new(0, math.max(0, offset))
		end
	end

	do -- Dragging Logic
		local startPoint = SlotFrame.Position
		local lastUpTime = 0
		local startParent = nil

		SlotFrame.DragBegin:connect(function(dragPoint)
			Dragging[SlotFrame] = true
			startPoint = dragPoint

			SlotFrame.BorderSizePixel = 2

			-- Raise above other slots
			SlotFrame.ZIndex = 2
			ToolIcon.ZIndex = 2
			ToolName.ZIndex = 2
			if SlotNumber then
				SlotNumber.ZIndex = 2
			end
			if HighlightFrame then
				HighlightFrame.ZIndex = 2
				for _, child in pairs(HighlightFrame:GetChildren()) do
					child.ZIndex = 2
				end
			end

			-- Circumvent the ScrollingFrame's ClipsDescendants property
			startParent = SlotFrame.Parent
			if startParent == ScrollingFrame then
				SlotFrame.Parent = InventoryFrame
				local pos = ScrollingFrame.Position
				local offset = ScrollingFrame.CanvasPosition - Vector2.new(pos.X.Offset, pos.Y.Offset)
				SlotFrame.Position = SlotFrame.Position - UDim2.new(0, offset.X, 0, offset.Y)
			end
		end)

		SlotFrame.DragStopped:connect(function(x, y)
			local now = tick()
			SlotFrame.Position = startPoint
			SlotFrame.Parent = startParent

			SlotFrame.BorderSizePixel = 0

			-- Restore height
			SlotFrame.ZIndex = 1
			ToolIcon.ZIndex = 1
			ToolName.ZIndex = 1
			if SlotNumber then
				SlotNumber.ZIndex = 1
			end
			if HighlightFrame then
				HighlightFrame.ZIndex = 1
				for _, child in pairs(HighlightFrame:GetChildren()) do
					child.ZIndex = 1
				end
			end

			Dragging[SlotFrame] = nil

			-- Make sure the tool wasn't dropped
			if not slot.Tool then
				return
			end

			-- Check where we were dropped
			if CheckBounds(InventoryFrame, x, y) then
				if slot.Index <= NumberOfHotbarSlots then
					slot:MoveToInventory()
				end
				-- Check for double clicking on an inventory slot, to move into empty hotbar slot
				if slot.Index > NumberOfHotbarSlots and now - lastUpTime < DOUBLE_CLICK_TIME then
					if LowestEmptySlot then
						local myTool = slot.Tool
						slot:Clear()
						LowestEmptySlot:Fill(myTool)
						slot:Delete()
					end
					now = 0 -- Resets the timer
				end
			elseif CheckBounds(HotbarFrame, x, y) then
				local closest = {math.huge, nil}
				for i = 1, NumberOfHotbarSlots do
					local otherSlot = Slots[i]
					local offset = GetOffset(otherSlot.Frame, Vector2.new(x, y))
					if offset < closest[1] then
						closest = {offset, otherSlot}
					end
				end
				local closestSlot = closest[2]
				if closestSlot ~= slot then
					slot:Swap(closestSlot)
					if slot.Index > NumberOfHotbarSlots then
						local tool = slot.Tool
						if not tool then -- Clean up after ourselves if we're an inventory slot that's now empty
							slot:Delete()
						else -- Moved inventory slot to hotbar slot, and gained a tool that needs to be unequipped
							if IsEquipped(tool) then --NOTE: HopperBin
								UnequipAllTools()
							end
							-- Also hide the inventory slot if we're showing results right now
							if ResultsIndices then
								slot.Frame.Visible = false
							end
						end
					end
				end
			else
				-- local tool = slot.Tool
				-- if tool.CanBeDropped then --TODO: HopperBins
					-- tool.Parent = workspace
					-- --TODO: Move away from character
				-- end
				if slot.Index <= NumberOfHotbarSlots then
					slot:MoveToInventory() --NOTE: Temporary
				end
			end

			lastUpTime = now
		end)
	end

	-- All ready!
	SlotFrame.Parent = parent
	Slots[index] = slot
	return slot
end

-- NOTE: We should probably migrate to a 2 collection system:
-- One collection for the hotbar and another collection for the inventory
local function SetNumberOfHotbarSlots(numSlots)
	if NumberOfHotbarSlots ~= numSlots then
		local prevNumberOfSlots = NumberOfHotbarSlots
		local newNumberOfSlots = numSlots
		-- If we are shrinking the number of slots we need
		-- to move around our tools to the right locations
		if prevNumberOfSlots > newNumberOfSlots then
			-- Delete the slots that are now no longer in the Hotbar
			-- Iterate backwards as to not corrupt our iterator
			for i = prevNumberOfSlots, newNumberOfSlots + 1, -1 do
				local slot = Slots[i]
				if slot then
					slot:MoveToInventory()
					slot:Delete()
				end
			end
			-- Also need to slide-back the inventory slots now that they are indexed earlier
			for i = prevNumberOfSlots, newNumberOfSlots + 1, -1 do
				local slot = Slots[i]
				if not slot.Tool then
					slot:Delete()
				end
			end
		else -- If we added more slots
			for i = prevNumberOfSlots, newNumberOfSlots do
				-- Incrementally add hotbar slots
				NumberOfHotbarSlots = i
				if Slots[i] then
					-- Move old
					local oldSlot = Slots[i]
					local oldTool = Slots[i].Tool

					local newSlot = MakeSlot(HotbarFrame, i)

					if oldTool then
						newSlot:Fill(oldTool)
					elseif not LowestEmptySlot then
						LowestEmptySlot = newSlot
					end
				else
					local slot = MakeSlot(HotbarFrame, i)

					slot.Frame.Visible = false

					if not LowestEmptySlot then
						LowestEmptySlot = slot
					end
				end
			end
		end
		NumberOfHotbarSlots = numSlots
		FullHotbarSlots = 0
		for i = 1, NumberOfHotbarSlots do
			if Slots[i] and Slots[i].Tool then
				FullHotbarSlots = FullHotbarSlots + 1
			end
		end

		UpdateBackpackLayout()
	end
end

local function OnChildAdded(child) -- To Character or Backpack
	if not child:IsA('Tool') and not child:IsA('HopperBin') then --NOTE: HopperBin
		if child:IsA('Humanoid') and child.Parent == Character then
			Humanoid = child
		end
		return
	end
	local tool = child

	if ActiveHopper and tool.Parent == Character then --NOTE: HopperBin
		DisableActiveHopper()
	end

	--TODO: Optimize / refactor / do something else
	if not StarterToolFound and tool.Parent == Character and not SlotsByTool[tool] then
		local starterGear = Player:FindFirstChild('StarterGear')
		if starterGear then
			if starterGear:FindFirstChild(tool.Name) then
				StarterToolFound = true
				local slot = LowestEmptySlot or MakeSlot(ScrollingFrame)
				for i = slot.Index, 1, -1 do
					local curr = Slots[i] -- An empty slot, because above
					local pIndex = i - 1
					if pIndex > 0 then
						local prev = Slots[pIndex] -- Guaranteed to be full, because above
						prev:Swap(curr)
					else
						curr:Fill(tool)
					end
				end
				-- Have to manually unequip a possibly equipped tool
				for _, child in pairs(Character:GetChildren()) do
					if child:IsA('Tool') and child ~= tool then
						child.Parent = Backpack
					end
				end
				AdjustHotbarFrames()
				return -- We're done here
			end
		end
	end

	-- The tool is either moving or new
	local slot = SlotsByTool[tool]
	if slot then
		slot:UpdateEquipView()
	else -- New! Put into lowest hotbar slot or new inventory slot
		slot = LowestEmptySlot or MakeSlot(ScrollingFrame)
		slot:Fill(tool)
		if slot.Index <= NumberOfHotbarSlots and not InventoryFrame.Visible then
			AdjustHotbarFrames()
		end
		if tool:IsA('HopperBin') then --NOTE: HopperBin
			if tool.Active then
				UnequipAllTools()
				ActiveHopper = tool
			end
		end
	end
end

local function OnChildRemoved(child) -- From Character or Backpack
	if not child:IsA('Tool') and not child:IsA('HopperBin') then --NOTE: HopperBin
		return
	end
	local tool = child

	-- Ignore this event if we're just moving between the two
	local newParent = tool.Parent
	if newParent == Character or newParent == Backpack then
		return
	end

	local slot = SlotsByTool[tool]
	if slot then
		slot:Clear()
		if slot.Index > NumberOfHotbarSlots then -- Inventory slot
			slot:Delete()
		elseif not InventoryFrame.Visible then
			AdjustHotbarFrames()
		end
	end

	if tool == ActiveHopper then --NOTE: HopperBin
		ActiveHopper = nil
	end
end

local function OnCharacterAdded(character)
	-- First, clean up any old slots
	for i = #Slots, 1, -1 do
		local slot = Slots[i]
		if slot.Tool then
			slot:Clear()
		end
		if i > NumberOfHotbarSlots then
			slot:Delete()
		end
	end
	ActiveHopper = nil --NOTE: HopperBin

	-- And any old connections
	for _, conn in pairs(CharConns) do
		conn:disconnect()
	end
	CharConns = {}

	-- Hook up the new character
	Character = character
	table.insert(CharConns, character.ChildRemoved:connect(OnChildRemoved))
	table.insert(CharConns, character.ChildAdded:connect(OnChildAdded))
	for _, child in pairs(character:GetChildren()) do
		OnChildAdded(child)
	end
	--NOTE: Humanoid is set inside OnChildAdded

	-- And the new backpack, when it gets here
	Backpack = Player:WaitForChild('Backpack')
	table.insert(CharConns, Backpack.ChildRemoved:connect(OnChildRemoved))
	table.insert(CharConns, Backpack.ChildAdded:connect(OnChildAdded))
	for _, child in pairs(Backpack:GetChildren()) do
		OnChildAdded(child)
	end

	AdjustHotbarFrames()
end

local function OnInputBegan(input, isProcessed)
	-- Pass through keyboard hotkeys when not typing into a TextBox and not disabled (except for the Drop key)
	if input.UserInputType == Enum.UserInputType.Keyboard and not TextBoxFocused and (WholeThingEnabled or input.KeyCode.Value == DROP_HOTKEY_VALUE) then
		local hotkeyBehavior = HotkeyFns[input.KeyCode.Value]
		if hotkeyBehavior then
			hotkeyBehavior(isProcessed)
		end
	end
end

local function OnUISChanged(property)
	if property == 'KeyboardEnabled' or property == "VREnabled" then
		local on = UserInputService.KeyboardEnabled and not UserInputService.VREnabled
		for i = 1, NumberOfHotbarSlots do
			Slots[i]:TurnNumber(on)
		end
	end
end

-------------------------
--| Gamepad Functions |--
-------------------------
local lastChangeToolInputObject = nil
local lastChangeToolInputTime = nil
local maxEquipDeltaTime = 0.06
local noOpFunc = function() end
local selectDirection = Vector2.new(0,0)
local hotbarVisible = false

function unbindAllGamepadEquipActions()
	ContextActionService:UnbindCoreAction("RBXBackpackHasGamepadFocus")
	ContextActionService:UnbindCoreAction("RBXCloseInventory")
end

local function setHotbarVisibility(visible, isInventoryScreen)
	for i = 1, NumberOfHotbarSlots do
		local hotbarSlot = Slots[i]
		if hotbarSlot and hotbarSlot.Frame and (isInventoryScreen or hotbarSlot.Tool) then
			hotbarSlot.Frame.Visible = visible
		end
	end
end

local function getInputDirection(inputObject)
	local buttonModifier = 1
	if inputObject.UserInputState == Enum.UserInputState.End then
		buttonModifier = -1
	end

	if inputObject.KeyCode == Enum.KeyCode.Thumbstick1 then

		local magnitude = inputObject.Position.magnitude

		if magnitude > 0.98 then
			local normalizedVector = Vector2.new(inputObject.Position.x / magnitude, -inputObject.Position.y / magnitude)
			selectDirection =  normalizedVector
		else
			selectDirection = Vector2.new(0,0)
		end
	elseif inputObject.KeyCode == Enum.KeyCode.DPadLeft then
		selectDirection = Vector2.new(selectDirection.x - 1 * buttonModifier, selectDirection.y)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadRight then
		selectDirection = Vector2.new(selectDirection.x + 1 * buttonModifier, selectDirection.y)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadUp then
		selectDirection = Vector2.new(selectDirection.x, selectDirection.y - 1 * buttonModifier)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadDown then
		selectDirection = Vector2.new(selectDirection.x, selectDirection.y + 1 * buttonModifier)
	else
		selectDirection = Vector2.new(0,0)
	end

	return selectDirection
end

local selectToolExperiment = function(actionName, inputState, inputObject)
	local inputDirection = getInputDirection(inputObject)

	if inputDirection == Vector2.new(0,0) then
		return
	end

	local angle = math.atan2(inputDirection.y, inputDirection.x) - math.atan2(-1, 0)
	if angle < 0 then
		angle = angle + (math.pi * 2)
	end

	local quarterPi = (math.pi * 0.25)

	local index = (angle/quarterPi) + 1
	index = math.floor(index + 0.5) -- round index to whole number
	if index > NumberOfHotbarSlots then
		index = 1
	end

	if index > 0 then
		local selectedSlot = Slots[index]
		if selectedSlot and selectedSlot.Tool and not selectedSlot:IsEquipped() then
			selectedSlot:Select()
		end
	else
		UnequipAllTools()
	end
end

changeToolFunc = function(actionName, inputState, inputObject)
	if inputState ~= Enum.UserInputState.Begin then return end

	if lastChangeToolInputObject then
		if (lastChangeToolInputObject.KeyCode == Enum.KeyCode.ButtonR1 and
			inputObject.KeyCode == Enum.KeyCode.ButtonL1) or
			(lastChangeToolInputObject.KeyCode == Enum.KeyCode.ButtonL1 and
			inputObject.KeyCode == Enum.KeyCode.ButtonR1) then
				if (tick() - lastChangeToolInputTime) <= maxEquipDeltaTime then
					UnequipAllTools()
					lastChangeToolInputObject = inputObject
					lastChangeToolInputTime = tick()
					return
				end
		end
	end

	lastChangeToolInputObject = inputObject
	lastChangeToolInputTime = tick()

	delay(maxEquipDeltaTime, function()
		if lastChangeToolInputObject ~= inputObject then return end

		local moveDirection = 0
		if (inputObject.KeyCode == Enum.KeyCode.ButtonL1) then
			moveDirection = -1
		else
			moveDirection = 1
		end

		for i = 1, NumberOfHotbarSlots do
			local hotbarSlot = Slots[i]
			if hotbarSlot:IsEquipped() then

				local newSlotPosition = moveDirection + i
				if newSlotPosition > NumberOfHotbarSlots then
					newSlotPosition = 1
				elseif newSlotPosition < 1 then
					newSlotPosition = NumberOfHotbarSlots
				end

				local origNewSlotPos = newSlotPosition
				while not Slots[newSlotPosition].Tool do
					newSlotPosition = newSlotPosition + moveDirection
					if newSlotPosition == origNewSlotPos then return end

					if newSlotPosition > NumberOfHotbarSlots then
						newSlotPosition = 1
					elseif newSlotPosition < 1 then
						newSlotPosition = NumberOfHotbarSlots
					end
				end

				Slots[newSlotPosition]:Select()
				return
			end
		end

		if lastEquippedSlot and lastEquippedSlot.Tool then
			lastEquippedSlot:Select()
			return
		end

		for i = 1, NumberOfHotbarSlots do
			if Slots[i].Tool then
				Slots[i]:Select()
				return
			end
		end
	end)
end

function getGamepadSwapSlot()
	for i = 1, #Slots do
		if Slots[i].Frame.BorderSizePixel > 0 then
			return Slots[i]
		end
	end
end

function changeSlot(slot)
	local swapInVr = not UserInputService.VREnabled or InventoryFrame.Visible

	if slot.Frame == GuiService.SelectedCoreObject and swapInVr then
		local currentlySelectedSlot = getGamepadSwapSlot()

		if currentlySelectedSlot then
			currentlySelectedSlot.Frame.BorderSizePixel = 0
			if currentlySelectedSlot ~= slot then
				slot:Swap(currentlySelectedSlot)

				if slot.Index > NumberOfHotbarSlots and not slot.Tool then
					if GuiService.SelectedCoreObject == slot.Frame then
						GuiService.SelectedCoreObject = currentlySelectedSlot.Frame
					end
					slot:Delete()
				end

				if currentlySelectedSlot.Index > NumberOfHotbarSlots and not currentlySelectedSlot.Tool then
					if GuiService.SelectedCoreObject == currentlySelectedSlot.Frame then
						GuiService.SelectedCoreObject = slot.Frame
					end
					currentlySelectedSlot:Delete()
				end
			end
		else
			local startSize = slot.Frame.Size
			local startPosition = slot.Frame.Position
			slot.Frame:TweenSizeAndPosition(startSize + UDim2.new(0, 10, 0, 10), startPosition - UDim2.new(0, 5, 0, 5), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, .1, true, function() slot.Frame:TweenSizeAndPosition(startSize, startPosition, Enum.EasingDirection.In, Enum.EasingStyle.Quad, .1, true) end)
			slot.Frame.BorderSizePixel = 3
		end
	else
		slot:Select()
	end
end


function enableGamepadInventoryControl()
	local goBackOneLevel = function(actionName, inputState, inputObject)
		if inputState ~= Enum.UserInputState.Begin then return end

		local selectedSlot = getGamepadSwapSlot()
		if selectedSlot then
			local selectedSlot = getGamepadSwapSlot()
			if selectedSlot then
				selectedSlot.Frame.BorderSizePixel = 0
				return
			end
		elseif InventoryFrame.Visible then
			BackpackScript.OpenClose()
			spawn(function() GuiService:SetMenuIsOpen(false) end)
		end
	end

	ContextActionService:BindCoreAction("RBXBackpackHasGamepadFocus", noOpFunc, false, Enum.UserInputType.Gamepad1)
	ContextActionService:BindCoreAction("RBXCloseInventory", goBackOneLevel, false, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonStart)

	-- Gaze select will automatically select the object for us!
	if not UseGazeSelection() then
		GuiService.SelectedCoreObject = HotbarFrame:FindFirstChild("1")
	end
end


function disableGamepadInventoryControl()
	unbindAllGamepadEquipActions()

	for i = 1, NumberOfHotbarSlots do
		local hotbarSlot = Slots[i]
		if hotbarSlot and hotbarSlot.Frame then
			hotbarSlot.Frame.BorderSizePixel = 0
		end
	end

	if GuiService.SelectedCoreObject and GuiService.SelectedCoreObject:IsDescendantOf(MainFrame) then
		GuiService.SelectedCoreObject = nil
	end
end


local function bindBackpackHotbarAction()
	if WholeThingEnabled and not GamepadActionsBound then
		GamepadActionsBound = true
		ContextActionService:BindCoreAction("RBXHotbarEquip", changeToolFunc, false, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1)
	end
end

local function unbindBackpackHotbarAction()
	disableGamepadInventoryControl()
	GamepadActionsBound = false
	ContextActionService:UnbindCoreAction("RBXHotbarEquip")
end

function gamepadDisconnected()
	GamepadEnabled = false
	disableGamepadInventoryControl()
end

function gamepadConnected()
	GamepadEnabled = true
	GuiService:AddSelectionParent("RBXBackpackSelection", MainFrame)

	if FullHotbarSlots >= 1 then
		bindBackpackHotbarAction()
	end
	
	if InventoryFrame.Visible then
		enableGamepadInventoryControl()
	end
end
-----------------------------
--| End Gamepad Functions |--
-----------------------------

local function EvaluateBackpackPanelVisibility(enabled)
	return enabled and StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Backpack) and TopbarEnabled and UserInputService.VREnabled
end


local function OnCoreGuiChanged(coreGuiType, enabled)
	-- Check for enabling/disabling the whole thing
	if coreGuiType == Enum.CoreGuiType.Backpack or coreGuiType == Enum.CoreGuiType.All then
		enabled = enabled and TopbarEnabled 
		WholeThingEnabled = enabled
		MainFrame.Visible = enabled

		if UserInputService.VREnabled then
			local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("Backpack"):SetVisible(EvaluateBackpackPanelVisibility(enabled))
		end

		-- Eat/Release hotkeys (Doesn't affect UserInputService)
		for _, keyString in pairs(HotkeyStrings) do
			if enabled then
				GuiService:AddKey(keyString)
			else
				GuiService:RemoveKey(keyString)
			end
		end

		if enabled then
			if FullHotbarSlots >=1 then
				bindBackpackHotbarAction()
			end
		else
			unbindBackpackHotbarAction()
		end
	end
end


local function MakeVRRoundButton(name, image)
	local newButton = NewGui('ImageButton', name)
	newButton.Size = UDim2.new(0, 40, 0, 40)
	newButton.Image = "rbxasset://textures/ui/Keyboard/close_button_background.png";

	local buttonIcon = NewGui('ImageLabel', 'Icon')
	buttonIcon.Size = UDim2.new(0.5,0,0.5,0);
	buttonIcon.Position = UDim2.new(0.25,0,0.25,0);
	buttonIcon.Image = image;
	buttonIcon.Parent = newButton;

	local buttonSelectionObject = NewGui('ImageLabel', 'Selection')
	buttonSelectionObject.Size = UDim2.new(0.9,0,0.9,0);
	buttonSelectionObject.Position = UDim2.new(0.05,0,0.05,0);
	buttonSelectionObject.Image = "rbxasset://textures/ui/Keyboard/close_button_selection.png";
	newButton.SelectionImageObject = buttonSelectionObject

	return newButton, buttonIcon, buttonSelectionObject
end


--------------------
--| Script Logic |--
--------------------

-- Make the main frame, which (mostly) covers the screen
MainFrame = NewGui('Frame', 'Backpack')
MainFrame.Visible = false
MainFrame.Parent = RobloxGui

-- Make the HotbarFrame, which holds only the Hotbar Slots
HotbarFrame = NewGui('Frame', 'Hotbar')
HotbarFrame.Parent = MainFrame

-- Make all the Hotbar Slots
for i = 1, NumberOfHotbarSlots do
	local slot = MakeSlot(HotbarFrame, i)
	slot.Frame.Visible = false

	if not LowestEmptySlot then
		LowestEmptySlot = slot
	end
end

-- Up arrow to open the inventory
OpenInventoryButton = NewGui('ImageButton', 'OpenInventory')
do
	OpenInventoryButton.Size = UDim2.new(0, 30, 0, 30)
	OpenInventoryButton.Image = "rbxasset://textures/ui/Backpack/ScrollUpArrow.png";
	OpenInventoryButton.MouseButton1Click:connect(function()
		BackpackScript.OpenClose()
	end)
	OpenInventoryButton.SelectionGained:connect(function()
		OpenInventoryButton.ImageColor3 = ARROW_HOVER_COLOR
	end)
	OpenInventoryButton.SelectionLost:connect(function()
		OpenInventoryButton.ImageColor3 = Color3.new(1,1,1)
	end)
	local openInventoryButtonSelectionObject = NewGui('Frame', 'Selection')
	openInventoryButtonSelectionObject.Visible = false
	OpenInventoryButton.SelectionImageObject = openInventoryButtonSelectionObject
end

CloseInventoryButton = MakeVRRoundButton('CloseInventory', 'rbxasset://textures/ui/Keyboard/close_button_icon.png')
CloseInventoryButton.Position = UDim2.new(0, 0, 0, -50)
CloseInventoryButton.MouseButton1Click:connect(function()
	if InventoryFrame.Visible then
		BackpackScript.OpenClose()
	end
end)

LeftBumperButton = NewGui('ImageLabel', 'LeftBumper')
LeftBumperButton.Size = UDim2.new(0, 40, 0, 40)
LeftBumperButton.Position = UDim2.new(0, -LeftBumperButton.Size.X.Offset, 0.5, -LeftBumperButton.Size.Y.Offset/2)

RightBumperButton = NewGui('ImageLabel', 'RightBumper')
RightBumperButton.Size = UDim2.new(0, 40, 0, 40)
RightBumperButton.Position = UDim2.new(1, 0, 0.5, -RightBumperButton.Size.Y.Offset/2)

-- Make the Inventory, which holds the ScrollingFrame, the header, and the search box
InventoryFrame = NewGui('Frame', 'Inventory')
InventoryFrame.BackgroundTransparency = BACKGROUND_FADE
InventoryFrame.BackgroundColor3 = BACKGROUND_COLOR
InventoryFrame.Active = true
InventoryFrame.Visible = false
InventoryFrame.Parent = MainFrame

-- Make the ScrollingFrame, which holds the rest of the Slots (however many)
ScrollingFrame = NewGui('ScrollingFrame', 'ScrollingFrame')
ScrollingFrame.Selectable = false
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
ScrollingFrame.Parent = InventoryFrame

ScrollUpInventoryButton = MakeVRRoundButton('ScrollUpButton', 'rbxasset://textures/ui/Backpack/ScrollUpArrow.png')
ScrollUpInventoryButton.Size = UDim2.new(0, 34, 0, 34)
ScrollUpInventoryButton.Position = UDim2.new(0.5, -ScrollUpInventoryButton.Size.X.Offset/2, 0, INVENTORY_HEADER_SIZE + 3)
ScrollUpInventoryButton.Icon.Position = ScrollUpInventoryButton.Icon.Position - UDim2.new(0,0,0,2)
ScrollUpInventoryButton.MouseButton1Click:connect(function()
	ScrollingFrame.CanvasPosition = Vector2.new(
		ScrollingFrame.CanvasPosition.X,
		Clamp(0, ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y, ScrollingFrame.CanvasPosition.Y - (ICON_BUFFER + ICON_SIZE)))
end)

ScrollDownInventoryButton = MakeVRRoundButton('ScrollDownButton', 'rbxasset://textures/ui/Backpack/ScrollUpArrow.png')
ScrollDownInventoryButton.Rotation = 180
ScrollDownInventoryButton.Icon.Position = ScrollDownInventoryButton.Icon.Position - UDim2.new(0,0,0,2)
ScrollDownInventoryButton.Size = UDim2.new(0, 34, 0, 34)
ScrollDownInventoryButton.Position = UDim2.new(0.5, -ScrollDownInventoryButton.Size.X.Offset/2, 1, -ScrollDownInventoryButton.Size.Y.Offset - 3)
ScrollDownInventoryButton.MouseButton1Click:connect(function()
	ScrollingFrame.CanvasPosition = Vector2.new(
		ScrollingFrame.CanvasPosition.X,
		Clamp(0, ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y, ScrollingFrame.CanvasPosition.Y + (ICON_BUFFER + ICON_SIZE)))
end)

ScrollingFrame.Changed:connect(function(prop)
	if prop == 'AbsoluteWindowSize' or prop == 'CanvasPosition' or prop == 'CanvasSize' then
		local canScrollUp = ScrollingFrame.CanvasPosition.Y ~= 0
		local canScrollDown = ScrollingFrame.CanvasPosition.Y < ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y

		ScrollUpInventoryButton.Visible = canScrollUp
		ScrollDownInventoryButton.Visible = canScrollDown
	end
end)

-- Position the frames and sizes for the Backpack GUI elements
UpdateBackpackLayout()

--Make the gamepad hint frame
local gamepadHintsFrame = Utility:Create'Frame'
{
	Name = "GamepadHintsFrame",
	Size = UDim2.new(0, HotbarFrame.Size.X.Offset, 0, (IsTenFootInterface and 95 or 60)),
	BackgroundTransparency = 1,
	Visible = false,
	Parent = MainFrame
}

local function addGamepadHint(hintImage, hintImageLarge, hintText)
	local hintFrame = Utility:Create'Frame'
	{
		Name = "HintFrame",
		Size = UDim2.new(1, 0, 1, -5),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1,
		Parent = gamepadHintsFrame
	}

	local hintImage = Utility:Create'ImageLabel'
	{
		Name = "HintImage",
		Size = (IsTenFootInterface and UDim2.new(0,90,0,90) or UDim2.new(0,60,0,60)),
		BackgroundTransparency = 1,
		Image = (IsTenFootInterface and hintImageLarge or hintImage),
		Parent = hintFrame
	}

	local hintText = Utility:Create'TextLabel'
	{
		Name = "HintText",
		Position = UDim2.new(0, (IsTenFootInterface and 100 or 70), 0, 0),
		Size = UDim2.new(1, -(IsTenFootInterface and 100 or 70), 1, 0),
		Font = Enum.Font.SourceSansBold,
		FontSize = (IsTenFootInterface and Enum.FontSize.Size36 or Enum.FontSize.Size24),
		BackgroundTransparency = 1,
		Text = hintText,
		TextColor3 = Color3.new(1,1,1),
		TextXAlignment = Enum.TextXAlignment.Left,
		Parent = hintFrame
	}
end

local function resizeGamepadHintsFrame()
	gamepadHintsFrame.Size = UDim2.new(HotbarFrame.Size.X.Scale, HotbarFrame.Size.X.Offset, 0, (IsTenFootInterface and 95 or 60))
	gamepadHintsFrame.Position = UDim2.new(HotbarFrame.Position.X.Scale, HotbarFrame.Position.X.Offset, InventoryFrame.Position.Y.Scale, InventoryFrame.Position.Y.Offset - gamepadHintsFrame.Size.Y.Offset)

	local spaceTaken = 0

	local gamepadHints = gamepadHintsFrame:GetChildren()
	--First get the total space taken by all the hints
	for i = 1, #gamepadHints do
		gamepadHints[i].Size = UDim2.new(1, 0, 1, -5)
		gamepadHints[i].Position = UDim2.new(0, 0, 0, 0)
		spaceTaken = spaceTaken + (gamepadHints[i].HintText.Position.X.Offset + gamepadHints[i].HintText.TextBounds.X)
	end

	--The space between all the frames should be equal
	local spaceBetweenElements = (gamepadHintsFrame.AbsoluteSize.X - spaceTaken)/(#gamepadHints - 1)
	for i = 1, #gamepadHints do
		gamepadHints[i].Position = (i == 1 and UDim2.new(0, 0, 0, 0) or UDim2.new(0, gamepadHints[i-1].Position.X.Offset + gamepadHints[i-1].Size.X.Offset + spaceBetweenElements, 0, 0))
		gamepadHints[i].Size = UDim2.new(0, (gamepadHints[i].HintText.Position.X.Offset + gamepadHints[i].HintText.TextBounds.X), 1, -5)
	end
end

addGamepadHint("rbxasset://textures/ui/Settings/Help/XButtonDark.png", "rbxasset://textures/ui/Settings/Help/XButtonDark@2x.png", "Remove From Hotbar")
addGamepadHint("rbxasset://textures/ui/Settings/Help/AButtonDark.png", "rbxasset://textures/ui/Settings/Help/AButtonDark@2x.png", "Select/Swap")
addGamepadHint("rbxasset://textures/ui/Settings/Help/BButtonDark.png", "rbxasset://textures/ui/Settings/Help/BButtonDark@2x.png", "Close Backpack")

do -- Search stuff
	local searchFrame = NewGui('Frame', 'Search')
	searchFrame.BackgroundColor3 = SEARCH_BACKGROUND_COLOR
	searchFrame.BackgroundTransparency = SEARCH_BACKGROUND_FADE
	searchFrame.Size = UDim2.new(0, SEARCH_WIDTH - (SEARCH_BUFFER * 2), 0, INVENTORY_HEADER_SIZE - (SEARCH_BUFFER * 2))
	searchFrame.Position = UDim2.new(1, -searchFrame.Size.X.Offset - SEARCH_BUFFER, 0, SEARCH_BUFFER)
	searchFrame.Parent = InventoryFrame

	local searchBox = NewGui('TextBox', 'TextBox')
	searchBox.Text = SEARCH_TEXT
	searchBox.ClearTextOnFocus = false
	searchBox.FontSize = Enum.FontSize.Size24
	searchBox.TextXAlignment = Enum.TextXAlignment.Left
	searchBox.Size = searchFrame.Size - UDim2.new(0, SEARCH_TEXT_OFFSET_FROMLEFT, 0, 0)
	searchBox.Position = UDim2.new(0, SEARCH_TEXT_OFFSET_FROMLEFT, 0, 0)
	searchBox.Parent = searchFrame

	local xButton = NewGui('TextButton', 'X')
	xButton.Text = 'x'
	xButton.TextColor3 = SLOT_EQUIP_COLOR
	xButton.FontSize = Enum.FontSize.Size24
	xButton.TextYAlignment = Enum.TextYAlignment.Bottom
	xButton.BackgroundColor3 = SEARCH_BACKGROUND_COLOR
	xButton.BackgroundTransparency = 0
	xButton.Size = UDim2.new(0, searchFrame.Size.Y.Offset - (SEARCH_BUFFER * 2), 0, searchFrame.Size.Y.Offset - (SEARCH_BUFFER * 2))
	xButton.Position = UDim2.new(1, -xButton.Size.X.Offset - (SEARCH_BUFFER * 2), 0.5, -xButton.Size.Y.Offset / 2)
	xButton.ZIndex = 0
	xButton.Visible = false
	xButton.BorderSizePixel = 0
	xButton.Parent = searchFrame

	local function search()
		local terms = {}
		for word in searchBox.Text:gmatch('%S+') do
			terms[word:lower()] = true
		end

		local hitTable = {}
		for i = NumberOfHotbarSlots + 1, #Slots do -- Only search inventory slots
			local slot = Slots[i]
			local hits = slot:CheckTerms(terms)
			table.insert(hitTable, {slot, hits})
			slot.Frame.Visible = false
		end

		table.sort(hitTable, function(left, right)
			return left[2] > right[2]
		end)
		ResultsIndices = {}

		for i, data in ipairs(hitTable) do
			local slot, hits = data[1], data[2]
			if hits > 0 then
				ResultsIndices[slot] = NumberOfHotbarSlots + i
				slot:Reposition()
				slot.Frame.Visible = true
			end
		end

		ScrollingFrame.CanvasPosition = Vector2.new(0, 0)

		xButton.ZIndex = 3
	end

	local function clearResults()
		if xButton.ZIndex > 0 then
			ResultsIndices = nil
			for i = NumberOfHotbarSlots + 1, #Slots do
				local slot = Slots[i]
				slot:Reposition()
				slot.Frame.Visible = true
			end
			xButton.ZIndex = 0
		end
	end

	local function reset()
		clearResults()
		searchBox.Text = SEARCH_TEXT
	end

	local function onChanged(property)
		if property == 'Text' then
			local text = searchBox.Text
			if text == '' then
				clearResults()
			elseif text ~= SEARCH_TEXT then
				search()
			end
			xButton.Visible = (text ~= '' and text ~= SEARCH_TEXT)
		end
	end

	local function onFocused()
		if searchBox.Text == SEARCH_TEXT then
			searchBox.Text = ''
		end
	end

	local function focusLost(enterPressed)
		if enterPressed then
			--TODO: Could optimize
			search()
		elseif searchBox.Text == '' then
			searchBox.Text = SEARCH_TEXT
		end
	end

	searchBox.Focused:connect(onFocused)
	xButton.MouseButton1Click:connect(reset)
	searchBox.Changed:connect(onChanged)
	searchBox.FocusLost:connect(focusLost)

	BackpackScript.StateChanged.Event:connect(function(isNowOpen)
		xButton.Modal = isNowOpen -- Allows free mouse movement even in first person
		if not isNowOpen then
			reset()
		end
	end)

	HotkeyFns[Enum.KeyCode.Escape.Value] = function(isProcessed)
		if isProcessed then -- Pressed from within a TextBox
			reset()
		elseif InventoryFrame.Visible then
			BackpackScript.OpenClose()
		end
	end

	local function detectGamepad(lastInputType)
		if lastInputType == Enum.UserInputType.Gamepad1 and not UserInputService.VREnabled then
			searchFrame.Visible = false
		else
			searchFrame.Visible = true
		end
	end
	UserInputService.LastInputTypeChanged:connect(detectGamepad)
end

do -- Make the Inventory expand/collapse arrow (unless TopBar)
	local removeHotBarSlot = function(name, state, input)
		if state ~= Enum.UserInputState.Begin then return end
		if not GuiService.SelectedCoreObject then return end

		for i = 1, NumberOfHotbarSlots do
			if Slots[i].Frame == GuiService.SelectedCoreObject and Slots[i].Tool then
				Slots[i]:MoveToInventory()
				return
			end
		end
	end

	local function openClose()
		if not next(Dragging) then -- Only continue if nothing is being dragged
			InventoryFrame.Visible = not InventoryFrame.Visible
			local nowOpen = InventoryFrame.Visible
			AdjustHotbarFrames()
			HotbarFrame.Active = not HotbarFrame.Active
			for i = 1, NumberOfHotbarSlots do
				Slots[i]:SetClickability(not nowOpen)
			end
		end

		if InventoryFrame.Visible then
			if GamepadEnabled then
				if GAMEPAD_INPUT_TYPES[UserInputService:GetLastInputType()] then
					resizeGamepadHintsFrame()
					gamepadHintsFrame.Visible = not UserInputService.VREnabled
				end
				enableGamepadInventoryControl()
			end
			
		else
			if GamepadEnabled then
				gamepadHintsFrame.Visible = false
			end
			disableGamepadInventoryControl()
		end

		if InventoryFrame.Visible then
			ContextActionService:BindCoreAction("RBXRemoveSlot", removeHotBarSlot, false, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindCoreAction("RBXRemoveSlot")
		end

		BackpackScript.IsOpen = InventoryFrame.Visible
		BackpackScript.StateChanged:Fire(InventoryFrame.Visible)
	end
	HotkeyFns[ARROW_HOTKEY] = openClose
	BackpackScript.OpenClose = openClose -- Exposed
end

-- Now that we're done building the GUI, we connect to all the major events

-- Wait for the player if LocalPlayer wasn't ready earlier
while not Player do
	wait()
	Player = PlayersService.LocalPlayer
end

-- Listen to current and all future characters of our player
Player.CharacterAdded:connect(OnCharacterAdded)
if Player.Character then
	OnCharacterAdded(Player.Character)
end

do -- Hotkey stuff
	-- Init HotkeyStrings, used for eating hotkeys
	for i = 0, 9 do
		table.insert(HotkeyStrings, tostring(i))
	end
	table.insert(HotkeyStrings, ARROW_HOTKEY_STRING)

	-- Listen to key down
	UserInputService.InputBegan:connect(OnInputBegan)

	-- Listen to ANY TextBox gaining or losing focus, for disabling all hotkeys
	UserInputService.TextBoxFocused:connect(function() TextBoxFocused = true end)
	UserInputService.TextBoxFocusReleased:connect(function() TextBoxFocused = false end)

	-- Manual unequip for HopperBins on drop button pressed
	HotkeyFns[DROP_HOTKEY_VALUE] = function() --NOTE: HopperBin
		if ActiveHopper then
			UnequipAllTools()
		end
	end

	-- Listen to keyboard status, for showing/hiding hotkey labels
	UserInputService.Changed:connect(OnUISChanged)
	OnUISChanged('KeyboardEnabled')

	-- Listen to gamepad status, for allowing gamepad style selection/equip
	if UserInputService:GetGamepadConnected(Enum.UserInputType.Gamepad1) then
		gamepadConnected()
	end
	UserInputService.GamepadConnected:connect(function(gamepadEnum)
		if gamepadEnum == Enum.UserInputType.Gamepad1 then
			gamepadConnected()
		end
	end)
	UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
		if gamepadEnum == Enum.UserInputType.Gamepad1 then
			gamepadDisconnected()
		end
	end)
end

function BackpackScript:TopbarEnabledChanged(enabled)
	TopbarEnabled = enabled
	-- Update coregui to reflect new topbar status
	OnCoreGuiChanged(Enum.CoreGuiType.Backpack, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Backpack))
end

-- Listen to enable/disable signals from the StarterGui
StarterGui.CoreGuiChangedSignal:connect(OnCoreGuiChanged)
local backpackType, healthType = Enum.CoreGuiType.Backpack, Enum.CoreGuiType.Health
OnCoreGuiChanged(backpackType, StarterGui:GetCoreGuiEnabled(backpackType))
OnCoreGuiChanged(healthType, StarterGui:GetCoreGuiEnabled(healthType))


local BackpackStateChangedInVRConn, VRModuleOpenedConn, VRModuleClosedConn = nil, nil, nil
local function OnVREnabled(prop)
	if prop == "VREnabled" then
		local Panel3D = require(RobloxGui.Modules.VR.Panel3D)

		IsVR = UserInputService.VREnabled
		OnCoreGuiChanged(backpackType, StarterGui:GetCoreGuiEnabled(backpackType))
		OnCoreGuiChanged(healthType, StarterGui:GetCoreGuiEnabled(healthType))

		if IsVR then
			local inventoryOpenStudSize = Vector2.new(6.25, 7.2)
			local inventoryClosedStudSize = Vector2.new(6.25, 2) -- Closed size is computed as numberOfHotbarSlots + 0.25
			local inventoryOpenPanelCF = CFrame.new(0, 4.603, 0.5)
			local inventoryClosedPanelCF = CFrame.new(0, 2, 0.5)
			local currentPanelLocalCF = inventoryClosedPanelCF

			local VRHub = require(RobloxGui.Modules.VR.VRHub)

			BackpackScript.ModuleName = "Backpack"
			BackpackScript.KeepVRTopbarOpen = true
			BackpackScript.VRIsExclusive = true
			BackpackScript.VRClosesNonExclusive = true
			VRHub:RegisterModule(BackpackScript)

			local BackpackPanel = Panel3D.Get(BackpackScript.ModuleName)
			BackpackPanel:ResizeStuds(inventoryClosedStudSize.x, inventoryClosedStudSize.y)
			BackpackPanel:SetType(Panel3D.Type.Fixed)
			BackpackPanel:SetVisible(EvaluateBackpackPanelVisibility(true))


			function BackpackPanel:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay)
				--the backpack panel needs to go in front of the user when they look at it.
				--if they aren't looking, we should be updating self.localCF

				local topbarPanel = Panel3D.Get("Topbar3D")
				local panelOriginCF = topbarPanel.localCF or CFrame.new()
				self.localCF = panelOriginCF * CFrame.Angles(math.rad(-25), 0, 0) * currentPanelLocalCF
			end

			function BackpackPanel:OnUpdate()
				local inventoryOpen = InventoryFrame.Visible
				if not inventoryOpen then
					BackpackPanel:ResizeStuds(FullHotbarSlots + 0.25, inventoryClosedStudSize.y)
				end

				-- Delink and relink backpack based on whether or not we are displaying it.
				if inventoryOpen or FullHotbarSlots ~= 0 or not isInventoryEmpty() then
					if not BackpackPanel.linkedTo then
						BackpackPanel:LinkTo("Topbar3D")
					end
				else
					if BackpackPanel.linkedTo then
						BackpackPanel:LinkTo(nil)
					end
				end

				-- Update transparency
				for i = 1, #Slots do
					local slot = Slots[i]
					if slot then
						slot:UpdateEquipView()
					end
				end
				OpenInventoryButton.ImageTransparency = BackpackPanel.transparency
				CloseInventoryButton.ImageTransparency = BackpackPanel.transparency
				LeftBumperButton.ImageTransparency = BackpackPanel.transparency
				RightBumperButton.ImageTransparency = BackpackPanel.transparency
			end

			BackpackPanel:LinkTo("Topbar3D")

			MainFrame.Parent = BackpackPanel:GetGUI()
			OpenInventoryButton.Parent = MainFrame
			CloseInventoryButton.Parent = InventoryFrame
			-- LeftBumperButton.Parent = HotbarFrame
			-- RightBumperButton.Parent = HotbarFrame

			ScrollUpInventoryButton.Parent = InventoryFrame
			ScrollDownInventoryButton.Parent = InventoryFrame
			-- Stop the ScrollingFrame from automatically scrolling when you hover over items
			ScrollingFrame.ScrollingEnabled = false

			BackpackStateChangedInVRConn = BackpackScript.StateChanged.Event:connect(function(isNowOpen)
				if isNowOpen then
					VRHub:FireModuleOpened(BackpackScript.ModuleName)
					BackpackPanel:ResizeStuds(inventoryOpenStudSize.x, inventoryOpenStudSize.y)
					BackpackPanel:SetCanFade(false)
					currentPanelLocalCF = inventoryOpenPanelCF
				else
					VRHub:FireModuleClosed(BackpackScript.ModuleName)
					BackpackPanel:ResizeStuds(inventoryClosedStudSize.x, inventoryClosedStudSize.y)
					BackpackPanel:SetCanFade(true)
					currentPanelLocalCF = inventoryClosedPanelCF
				end
			end)

			VRModuleOpenedConn = VRHub.ModuleOpened.Event:connect(function(moduleName)
				local openedModule = VRHub:GetModule(moduleName)
				if openedModule ~= BackpackScript and openedModule.VRIsExclusive then
					BackpackPanel:SetVisible(EvaluateBackpackPanelVisibility(false))
					if InventoryFrame.Visible then
						BackpackScript.OpenClose()
					end
				end
			end)
			VRModuleClosedConn = VRHub.ModuleClosed.Event:connect(function(moduleName)
				local openedModule = VRHub:GetModule(moduleName)
				if openedModule ~= BackpackScript then
					BackpackPanel:SetVisible(EvaluateBackpackPanelVisibility(true))
				end
			end)


			-- Turn off dragging when in VR
			for _, slot in pairs(Slots) do
				slot:SetClickability(false)
			end

			local Healthbar = require(RobloxGui.Modules.VR.Healthbar3D)
		else -- not IsVR (VR was turned off)
			local BackpackPanel = Panel3D.Get(BackpackScript.ModuleName)
			BackpackPanel:SetVisible(EvaluateBackpackPanelVisibility(false))
			BackpackPanel:LinkTo(nil)

			MainFrame.Parent = RobloxGui
			OpenInventoryButton.Parent = nil
			CloseInventoryButton.Parent = nil
			-- LeftBumperButton.Parent = nil
			-- RightBumperButton.Parent = nil

			ScrollUpInventoryButton.Parent = nil
			ScrollDownInventoryButton.Parent = nil
			ScrollingFrame.ScrollingEnabled = true

			-- Turn draggin back on
			for _, slot in pairs(Slots) do
				slot:SetClickability(true)
			end

			if BackpackStateChangedInVRConn then
				BackpackStateChangedInVRConn:disconnect()
				BackpackStateChangedInVRConn = nil
			end
			if VRModuleOpenedConn then
				VRModuleOpenedConn:disconnect()
				VRModuleOpenedConn = nil
			end
			if VRModuleClosedConn then
				VRModuleClosedConn:disconnect()
				VRModuleClosedConn = nil
			end
		end

		NumberOfInventoryRows = IsVR and INVENTORY_ROWS_VR or (IS_PHONE and INVENTORY_ROWS_MINI or INVENTORY_ROWS_FULL)
		local newSlotTotal = IsVR and HOTBAR_SLOTS_VR or (IS_PHONE and HOTBAR_SLOTS_MINI or HOTBAR_SLOTS_FULL)
		SetNumberOfHotbarSlots(newSlotTotal)
	end -- prop == "VREnabled"
end
UserInputService.Changed:connect(OnVREnabled)
if UserInputService.VREnabled then
	OnVREnabled("VREnabled")
end


return BackpackScript
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX761203F5AAEC45BFA0DF2399CA9D0E50">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GoogleAnalyticsUtils</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
  Filename: GoogleAnalyticsUtils.lua
  Written by: dbanks
  Description: Shared variables/work in reporting analytics.
--]]

local GoogleAnalyticsUtils = {}

-- Make sure these stay in sync with values in Analytics.h
GoogleAnalyticsUtils.CA_CATEGORY_GAME = "Game"
GoogleAnalyticsUtils.GA_CATEGORY_ACTION = "Action"
GoogleAnalyticsUtils.GA_CATEGORY_ERROR = "Error"
GoogleAnalyticsUtils.GA_CATEGORY_STUDIO = "Studio"
GoogleAnalyticsUtils.GA_CATEGORY_COUNTERS = "Counters"
GoogleAnalyticsUtils.GA_CATEGORY_RIBBONBAR = "RibbonBar"
GoogleAnalyticsUtils.GA_CATEGORY_SECURITY = "Security"
GoogleAnalyticsUtils.GA_CATEGORY_STUDIO_SETTINGS = "StudioSettings"

return GoogleAnalyticsUtils]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX097E657F70F844F69DC9A46F40707673">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerDropDown</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	// FileName: PlayerDropDown.lua
	// Written by: TheGamer101
	// Description: Code for the player drop down in the PlayerList and Chat
]]
local moduleApiTable = {}

--[[ Services ]]--
local CoreGui = game:GetService('CoreGui')
local HttpService = game:GetService('HttpService')
local HttpRbxApiService = game:GetService('HttpRbxApiService')
local PlayersService = game:GetService('Players')

local newBlockFunctionSuccess, newBlockFunctionValue = pcall(function() return settings():GetFFlag("UseNewBlockFunction") end)
local useNewBlockFunction = (newBlockFunctionSuccess == true and newBlockFunctionValue == true)

--[[ Script Variables ]]--
local LocalPlayer = PlayersService.LocalPlayer

--[[ Constants ]]--
local POPUP_ENTRY_SIZE_Y = 24
local ENTRY_PAD = 2
local BG_TRANSPARENCY = 0.5
local BG_COLOR = Color3.new(31/255, 31/255, 31/255)
local TEXT_STROKE_TRANSPARENCY = 0.75
local TEXT_COLOR = Color3.new(1, 1, 243/255)
local TEXT_STROKE_COLOR = Color3.new(34/255, 34/255, 34/255)
local MAX_FRIEND_COUNT = 200
local FRIEND_IMAGE = 'https://www.roblox.com/thumbs/avatar.ashx?userId='

--[[ Modules ]]--
local RobloxGui = CoreGui:WaitForChild('RobloxGui')
local reportAbuseMenu = require(RobloxGui.Modules.Settings.Pages.ReportAbuseMenu)

--[[ Bindables ]]--
local BindableEvent_SendNotification = nil
spawn(function()
	BindableEvent_SendNotification = RobloxGui:WaitForChild("SendNotification")
end)

--[[ Remotes ]]--
local RemoteEvent_NewFollower = nil

spawn(function()
	local RobloxReplicatedStorage = game:GetService('RobloxReplicatedStorage')
	RemoteEvent_NewFollower = RobloxReplicatedStorage:WaitForChild('NewFollower', 86400) or RobloxReplicatedStorage:WaitForChild('NewFollower')
end)

--[[ Utility Functions ]]--
local function createSignal()
	local sig = {}

	local mSignaler = Instance.new('BindableEvent')

	local mArgData = nil
	local mArgDataCount = nil

	function sig:fire(...)
		mArgData = {...}
		mArgDataCount = select('#', ...)
		mSignaler:Fire()
	end

	function sig:connect(f)
		if not f then error("connect(nil)", 2) end
		return mSignaler.Event:connect(function()
			f(unpack(mArgData, 1, mArgDataCount))
		end)
	end

	function sig:wait()
		mSignaler.Event:wait()
		assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
		return unpack(mArgData, 1, mArgDataCount)
	end

	return sig
end

--[[ Events ]]--
local BlockStatusChanged = createSignal()

--[[ Follower Notifications ]]--
local function sendNotification(title, text, image, duration, callback)
	if BindableEvent_SendNotification then
		BindableEvent_SendNotification:Fire(title, text, image, duration, callback)
	end
end

--[[ Friend Functions ]]--
local function getFriendStatus(selectedPlayer)
	if selectedPlayer == LocalPlayer then
		return Enum.FriendStatus.NotFriend
	else
		local success, result = pcall(function()
			-- NOTE: Core script only
			return LocalPlayer:GetFriendStatus(selectedPlayer)
		end)
		if success then
			return result
		else
			return Enum.FriendStatus.NotFriend
		end
	end
end

-- if userId = nil, then it will get count for local player
local function getFriendCountAsync(userId)
	local friendCount = nil
	local wasSuccess, result = pcall(function()
		local str = 'user/get-friendship-count'
		if userId then
			str = str..'?userId='..tostring(userId)
		end
		return HttpRbxApiService:GetAsync(str)
	end)
	if not wasSuccess then
		print("getFriendCountAsync() failed because", result)
		return nil
	end
	result = HttpService:JSONDecode(result)

	if result["success"] and result["count"] then
		friendCount = result["count"]
	end

	return friendCount
end

-- checks if we can send a friend request. Right now the only way we
-- can't is if one of the players is at the max friend limit
local function canSendFriendRequestAsync(otherPlayer)
	local theirFriendCount = getFriendCountAsync(otherPlayer.userId)
	local myFriendCount = getFriendCountAsync()

	-- assume max friends if web call fails
	if not myFriendCount or not theirFriendCount then
		return false
	end
	if myFriendCount < MAX_FRIEND_COUNT and theirFriendCount < MAX_FRIEND_COUNT then
		return true
	elseif myFriendCount >= MAX_FRIEND_COUNT then
		sendNotification("Cannot send friend request", "You are at the max friends limit.", "", 5, function() end)
		return false
	elseif theirFriendCount >= MAX_FRIEND_COUNT then
		sendNotification("Cannot send friend request", otherPlayer.Name.." is at the max friends limit.", "", 5, function() end)
		return false
	end
end

--[[ Follower Functions ]]--

-- Returns whether followerUserId is following userId
local function isFollowing(userId, followerUserId)
	local apiPath = "user/following-exists?userId="
	local params = userId.."&followerUserId="..followerUserId
	local success, result = pcall(function()
		return HttpRbxApiService:GetAsync(apiPath..params)
	end)
	if not success then
		print("isFollowing() failed because", result)
		return false
	end

	-- can now parse web response
	result = HttpService:JSONDecode(result)
	return result["success"] and result["isFollowing"]
end

--[[ Functions for Blocking users ]]--
local BlockedList = {}
local MutedList = {}

local function GetBlockedPlayersAsync()
	local userId = LocalPlayer.userId
	local apiPath = "userblock/getblockedusers" .. "?" .. "userId=" .. tostring(userId) .. "&" .. "page=" .. "1"
	if userId > 0 then
		local blockList = nil
		local success, msg = pcall(function()
			local request = HttpRbxApiService:GetAsync(apiPath)
			blockList = request and game:GetService('HttpService'):JSONDecode(request)
		end)
		if blockList and blockList['success'] == true and blockList['userList'] then
			local returnList = {}
			for i, v in pairs(blockList['userList']) do
				returnList[v] = true
			end
			return returnList
		end
	end
	return {}
end

spawn(function()
	BlockedList = GetBlockedPlayersAsync()
end)

local function isBlocked(userId)
	if (BlockedList[userId]) then
		return true
	end
	return false
end

local function isMuted(userId)
	if (MutedList[userId] ~= nil and MutedList[userId] == true) then
		return true	
	end
	return false
end

local function BlockPlayerAsync(playerToBlock)
	if playerToBlock and LocalPlayer ~= playerToBlock then
		local blockUserId = playerToBlock.UserId
		if blockUserId > 0 then
			if not isBlocked(blockUserId) then
				BlockedList[blockUserId] = true
				BlockStatusChanged:fire(blockUserId, true)
				if not useNewBlockFunction then
					pcall(function()
						local success = PlayersService:BlockUser(LocalPlayer.UserId, blockUserId)
					end)				
				else
					pcall(function()
						local success = LocalPlayer:BlockUser(playerToBlock)
					end)
				end
			end
		end
	end
end

local function UnblockPlayerAsync(playerToUnblock)
	if playerToUnblock then
		local unblockUserId = playerToUnblock.userId

		if isBlocked(unblockUserId) then
			BlockedList[unblockUserId] = nil
			BlockStatusChanged:fire(unblockUserId, false)
			if not useNewBlockFunction then
				pcall(function()
					local success = PlayersService:UnblockUser(LocalPlayer.UserId, unblockUserId)
				end)
			else
				pcall(function()
					local success = LocalPlayer:UnblockUser(playerToUnblock)
				end)
			end
		end
	end
end

local function MutePlayer(playerToMute)
	if playerToMute and LocalPlayer ~= playerToMute then
		local muteUserId = playerToMute.UserId
		if muteUserId > 0 then
			if not isMuted(muteUserId) then
				MutedList[muteUserId] = true
			end
		end
	end
end

local function UnmutePlayer(playerToUnmute)
	if playerToUnmute then
		local unmuteUserId = playerToUnmute.UserId
		MutedList[unmuteUserId] = nil
	end
end

--[[ Function to create DropDown class ]]--
function createPlayerDropDown()
	local playerDropDown = {}
	playerDropDown.Player = nil
	playerDropDown.PopupFrame = nil
	playerDropDown.HidePopupImmediately = false
	playerDropDown.PopupFrameOffScreenPosition = nil -- if this is set the popup frame tweens to a different offscreen position than the default
	
	playerDropDown.HiddenSignal = createSignal()
	
	--[[ Functions for when options in the dropdown are pressed ]]--
	local function onFriendButtonPressed()
		if playerDropDown.Player then
			local status = getFriendStatus(playerDropDown.Player)
			if status == Enum.FriendStatus.Friend then
				LocalPlayer:RevokeFriendship(playerDropDown.Player)
			elseif status == Enum.FriendStatus.Unknown or status == Enum.FriendStatus.NotFriend then
				-- cache and spawn
				local cachedLastSelectedPlayer = playerDropDown.Player
				spawn(function()
					-- check for max friends before letting them send the request
					if canSendFriendRequestAsync(cachedLastSelectedPlayer) then 	-- Yields
						if cachedLastSelectedPlayer and cachedLastSelectedPlayer.Parent == PlayersService then
							LocalPlayer:RequestFriendship(cachedLastSelectedPlayer)
						end
					end
				end)
			elseif status == Enum.FriendStatus.FriendRequestSent then
				LocalPlayer:RevokeFriendship(playerDropDown.Player)
			elseif status == Enum.FriendStatus.FriendRequestReceived then
				LocalPlayer:RequestFriendship(playerDropDown.Player)
			end

			playerDropDown:Hide()
		end
	end
	
	local function onDeclineFriendButonPressed()
		if playerDropDown.Player then
			LocalPlayer:RevokeFriendship(playerDropDown.Player)
			playerDropDown:Hide()
		end
	end
	
	-- Client unfollows followedUserId
	local function onUnfollowButtonPressed()
		if not playerDropDown.Player then return end
		--
		local apiPath = "user/unfollow"
		local params = "followedUserId="..tostring(playerDropDown.Player.userId)
		local success, result = pcall(function()
			return HttpRbxApiService:PostAsync(apiPath, params, Enum.ThrottlingPriority.Default, Enum.HttpContentType.ApplicationUrlEncoded)
		end)
		if not success then
			print("unfollowPlayer() failed because", result)
			playerDropDown:Hide()
			return
		end

		result = HttpService:JSONDecode(result)
		if result["success"] then
			if RemoteEvent_NewFollower then
				RemoteEvent_NewFollower:FireServer(playerDropDown.Player, false)
			end
			moduleApiTable.FollowerStatusChanged:fire()
		end

		playerDropDown:Hide()
		-- no need to send notification when someone unfollows
	end

	local function onBlockButtonPressed()
		if playerDropDown.Player then
			local cachedPlayer = playerDropDown.Player
			spawn(function()
				BlockPlayerAsync(cachedPlayer)
			end)
			playerDropDown:Hide()
		end
	end

	local function onUnblockButtonPressed()
		if playerDropDown.Player then
			local cachedPlayer = playerDropDown.Player
			spawn(function()
				UnblockPlayerAsync(cachedPlayer)
			end)
			playerDropDown:Hide()
		end
	end
	
	local function onReportButtonPressed()
		if playerDropDown.Player then
			reportAbuseMenu:ReportPlayer(playerDropDown.Player)
			playerDropDown:Hide()
		end
	end
	
	-- Client follows followedUserId
	local function onFollowButtonPressed()
		if not playerDropDown.Player then return end
		--
		local followedUserId = tostring(playerDropDown.Player.userId)
		local apiPath = "user/follow"
		local params = "followedUserId="..followedUserId
		local success, result = pcall(function()
			return HttpRbxApiService:PostAsync(apiPath, params, Enum.ThrottlingPriority.Default, Enum.HttpContentType.ApplicationUrlEncoded)
		end)
		if not success then
			print("followPlayer() failed because", result)
			playerDropDown:Hide()
			return
		end

		result = HttpService:JSONDecode(result)
		if result["success"] then
			sendNotification("You are", "now following "..playerDropDown.Player.Name, FRIEND_IMAGE..followedUserId.."&x=48&y=48", 5, function() end)
			if RemoteEvent_NewFollower then
				RemoteEvent_NewFollower:FireServer(playerDropDown.Player, true)
			end
			moduleApiTable.FollowerStatusChanged:fire()
		end

		playerDropDown:Hide()
	end
	
	local function createPopupFrame(buttons)
		local frame = Instance.new('Frame')
		frame.Name = "PopupFrame"
		frame.Size = UDim2.new(1, 0, 0, (POPUP_ENTRY_SIZE_Y * #buttons) + (#buttons - ENTRY_PAD))
		frame.Position = UDim2.new(1, 1, 0, 0)
		frame.BackgroundTransparency = 1

		for i,button in ipairs(buttons) do
			local btn = Instance.new('TextButton')
			btn.Name = button.Name
			btn.Size = UDim2.new(1, 0, 0, POPUP_ENTRY_SIZE_Y)
			btn.Position = UDim2.new(0, 0, 0, POPUP_ENTRY_SIZE_Y * (i - 1) + ((i - 1) * ENTRY_PAD))
			btn.BackgroundTransparency = BG_TRANSPARENCY
			btn.BackgroundColor3 = BG_COLOR
			btn.BorderSizePixel = 0
			btn.Text = button.Text
			btn.Font = Enum.Font.SourceSans
			btn.FontSize = Enum.FontSize.Size14
			btn.TextColor3 = TEXT_COLOR
			btn.TextStrokeTransparency = TEXT_STROKE_TRANSPARENCY
			btn.TextStrokeColor3 = TEXT_STROKE_COLOR
			btn.AutoButtonColor = true
			btn.Parent = frame

			btn.MouseButton1Click:connect(button.OnPress)
		end

		return frame
	end
	
	--[[ PlayerDropDown Functions ]]--
	function playerDropDown:Hide()
		if playerDropDown.PopupFrame then
			local offscreenPosition = (playerDropDown.PopupFrameOffScreenPosition ~= nil and playerDropDown.PopupFrameOffScreenPosition or UDim2.new(1, 1, 0, playerDropDown.PopupFrame.Position.Y.Offset))
			if not playerDropDown.HidePopupImmediately then
				playerDropDown.PopupFrame:TweenPosition(offscreenPosition, Enum.EasingDirection.InOut,
					Enum.EasingStyle.Quad, TWEEN_TIME, true, function()
						if playerDropDown.PopupFrame then
							playerDropDown.PopupFrame:Destroy()
							playerDropDown.PopupFrame = nil
						end
					end)
			else
				playerDropDown.PopupFrame:Destroy()
				playerDropDown.PopupFrame = nil
			end
		end
		if playerDropDown.Player then
			playerDropDown.Player = nil
		end
		playerDropDown.HiddenSignal:fire()
	end
	
	function playerDropDown:CreatePopup(Player)
		playerDropDown.Player = Player
		
		local buttons = {}

		local status = getFriendStatus(playerDropDown.Player)
		local friendText = ""
		local canDeclineFriend = false
		if status == Enum.FriendStatus.Friend then
			friendText = "Unfriend Player"
		elseif status == Enum.FriendStatus.Unknown or status == Enum.FriendStatus.NotFriend then
			friendText = "Send Friend Request"
		elseif status == Enum.FriendStatus.FriendRequestSent then
			friendText = "Revoke Friend Request"
		elseif status == Enum.FriendStatus.FriendRequestReceived then
			friendText = "Accept Friend Request"
			canDeclineFriend = true
		end

		local blocked = isBlocked(playerDropDown.Player.userId)

		if not blocked then
			table.insert(buttons, {
				Name = "FriendButton",
				Text = friendText,
				OnPress = onFriendButtonPressed,
				})
		end

		if canDeclineFriend and not blocked then
			table.insert(buttons, {
				Name = "DeclineFriend",
				Text = "Decline Friend Request",
				OnPress = onDeclineFriendButonPressed,
				})
		end
		-- following status
		local following = isFollowing(playerDropDown.Player.userId, LocalPlayer.userId)
		local followerText = following and "Unfollow Player" or "Follow Player"
		
		if not blocked then
			table.insert(buttons, {
				Name = "FollowerButton",
				Text = followerText,
				OnPress = following and onUnfollowButtonPressed or onFollowButtonPressed,
				})
		end

		local blockedText = blocked and "Unblock Player" or "Block Player"
		table.insert(buttons, {
			Name = "BlockButton",
			Text = blockedText,
			OnPress = blocked and onUnblockButtonPressed or onBlockButtonPressed,
			})
		table.insert(buttons, {
			Name = "ReportButton",
			Text = "Report Abuse",
			OnPress = onReportButtonPressed,
			})

		if playerDropDown.PopupFrame then
			playerDropDown.PopupFrame:Destroy()
		end
		playerDropDown.PopupFrame = createPopupFrame(buttons)
		return playerDropDown.PopupFrame
	end
	
	--[[ PlayerRemoving Connection ]]--
	PlayersService.PlayerRemoving:connect(function(leavingPlayer) 
		if playerDropDown.Player == leavingPlayer then
			playerDropDown:Hide()
		end
	end)
	
	return playerDropDown
end


do
	moduleApiTable.FollowerStatusChanged = createSignal()

	function moduleApiTable:CreatePlayerDropDown()
		return createPlayerDropDown()
	end

	function moduleApiTable:CreateBlockingUtility()
		local blockingUtility = {}
		
		function blockingUtility:BlockPlayerAsync(player)
			return BlockPlayerAsync(player)
		end
		
		function blockingUtility:UnblockPlayerAsync(player)
			return UnblockPlayerAsync(player)
		end
		
		function blockingUtility:MutePlayer(player)
			return MutePlayer(player)
		end
		
		function blockingUtility:UnmutePlayer(player)
			return UnmutePlayer(player)
		end
		
		function blockingUtility:IsPlayerBlockedByUserId(userId)
			return isBlocked(userId)
		end

		function blockingUtility:GetBlockedStatusChangedEvent()
			return BlockStatusChanged
		end
		
		function blockingUtility:IsPlayerMutedByUserId(userId)
			return isMuted(userId)
		end
		
		return blockingUtility
	end
end

return moduleApiTable
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA38287D6F37B418291FC7B1FD99E1914">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerlistModule</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
  // FileName: PlayerlistModule.lua
  // Version 1.3
  // Written by: jmargh
  // Description: Implementation of in game player list and leaderboard
]]

local CoreGui = game:GetService('CoreGui')
local GuiService = game:GetService('GuiService')	-- NOTE: Can only use in core scripts
local UserInputService = game:GetService('UserInputService')
local TeamsService = game:FindService('Teams')
local ContextActionService = game:GetService('ContextActionService')
local StarterGui = game:GetService('StarterGui')
local PlayersService = game:GetService('Players')
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

local RbxGuiLibrary = nil
if LoadLibrary then
  RbxGuiLibrary = LoadLibrary("RbxGui")
end

while not PlayersService.LocalPlayer do
  wait()
end
local Player = PlayersService.LocalPlayer
local RobloxGui = CoreGui:WaitForChild('RobloxGui')

local StatsUtils = require(RobloxGui.Modules.Stats.StatsUtils)

local TenFootInterface = require(RobloxGui.Modules.TenFootInterface)
local isTenFootInterface = TenFootInterface:IsEnabled()

local playerDropDownModule = require(RobloxGui.Modules.PlayerDropDown)
local blockingUtility = playerDropDownModule:CreateBlockingUtility()
local playerDropDown = playerDropDownModule:CreatePlayerDropDown()

local PlayerPermissionsModule = require(RobloxGui.Modules.PlayerPermissionsModule)

--[[ Remotes ]]--
local RemoveEvent_OnFollowRelationshipChanged = nil
local RemoteFunc_GetFollowRelationships = nil

--[[ Start Module ]]--
local Playerlist = {}

--[[ Public Event API ]]--
-- Parameters: Sorted Array - see GameStats below
Playerlist.OnLeaderstatsChanged = Instance.new('BindableEvent')
-- Parameters: nameOfStat(string), formatedStringOfStat(string)
Playerlist.OnStatChanged = Instance.new('BindableEvent')

--[[ Client Stat Table ]]--
-- Sorted Array of tables
local GameStats = {}
-- Fields
-- Name: String the developer has given the stat
-- Text: Formated string of the stat value
-- AddId: Child add order id
-- IsPrimary: Is this the primary stat
-- Priority: Sorting priority
-- NOTE: IsPrimary and Priority are unofficially supported. They are left over legacy from the old player list.
-- They can be un-supported at anytime. You should prefer using child add order to order your stats in the leader board.

--[[ Script Variables ]]--
local topbarEnabled = true
local playerlistCoreGuiEnabled = true
local MyPlayerEntryTopFrame = nil
local PlayerEntries = {}
local StatAddId = 0
local TeamEntries = {}
local TeamAddId = 0
local NeutralTeam = nil
local IsShowingNeutralFrame = false
local LastSelectedFrame = nil
local LastSelectedPlayer = nil
local MinContainerSize = UDim2.new(0, 165, 0.5, 0)
if isTenFootInterface then
  MinContainerSize = UDim2.new(0, 1000, 0, 720)
end
local TempHideKeys = {}

local PlayerEntrySizeY = 24
if isTenFootInterface then
  PlayerEntrySizeY = 80
end

local TeamEntrySizeY = 18

if isTenFootInterface then
  TeamEntrySizeY = 32
end

local NameEntrySizeX = 170
if isTenFootInterface then
  NameEntrySizeX = 350
end

local StatEntrySizeX = 75
if isTenFootInterface then
  StatEntrySizeX = 250
end

local IsSmallScreenDevice = UserInputService.TouchEnabled and GuiService:GetScreenResolution().Y <= 500

local BaseUrl = game:GetService('ContentProvider').BaseUrl:lower()
BaseUrl = string.gsub(BaseUrl, "/m.", "/www.")
AssetGameUrl = string.gsub(BaseUrl, 'www', 'assetgame')

--[[ Constants ]]--
local ENTRY_PAD = 2
local BG_TRANSPARENCY = 0.5
local BG_COLOR = Color3.new(31/255, 31/255, 31/255)
local BG_COLOR_TOP = Color3.new(106/255, 106/255, 106/255)
local TEXT_STROKE_TRANSPARENCY = 0.75
local TEXT_COLOR = Color3.new(1, 1, 243/255)
local TEXT_STROKE_COLOR = Color3.new(34/255, 34/255, 34/255)
local TWEEN_TIME = 0.15
local MAX_LEADERSTATS = 4
local MAX_STR_LEN = 12
local TILE_SPACING = 2
if isTenFootInterface then
  BG_COLOR_TOP = Color3.new(25/255, 25/255, 25/255)
  BG_COLOR = Color3.new(60/255, 60/255, 60/255)
  BG_TRANSPARENCY = 0.25
  TEXT_STROKE_TRANSPARENCY = 1
  TILE_SPACING = 5
end
local SHADOW_IMAGE = 'rbxasset://textures/ui/PlayerList/TileShadowMissingTop.png'--'http://www.roblox.com/asset?id=286965900'
local SHADOW_SLICE_SIZE = 5
local SHADOW_SLICE_RECT = Rect.new(SHADOW_SLICE_SIZE+1, SHADOW_SLICE_SIZE+1, SHADOW_SLICE_SIZE*2-1, SHADOW_SLICE_SIZE*2-1)

local CUSTOM_ICONS = {	-- Admins with special icons
  ['7210880'] = 'rbxassetid://134032333', -- Jeditkacheff
  ['13268404'] = 'rbxassetid://113059239', -- Sorcus
  ['261'] = 'rbxassetid://105897927', -- shedlestky
  ['20396599'] = 'rbxassetid://161078086', -- Robloxsai
}

local ABUSES = {
  "Swearing",
  "Bullying",
  "Scamming",
  "Dating",
  "Cheating/Exploiting",
  "Personal Questions",
  "Offsite Links",
  "Bad Username",
}

--[[ Images ]]--
local CHAT_ICON = 'rbxasset://textures/ui/chat_teamButton.png'
local ADMIN_ICON = 'rbxasset://textures/ui/icon_admin-16.png'
local INTERN_ICON = 'rbxasset://textures/ui/icon_intern-16.png'
local PLACE_OWNER_ICON = 'rbxasset://textures/ui/icon_placeowner.png'
local BC_ICON = 'rbxasset://textures/ui/icon_BC-16.png'
local TBC_ICON = 'rbxasset://textures/ui/icon_TBC-16.png'
local OBC_ICON = 'rbxasset://textures/ui/icon_OBC-16.png'
local BLOCKED_ICON = 'rbxasset://textures/ui/PlayerList/BlockedIcon.png'
local FRIEND_ICON = 'rbxasset://textures/ui/icon_friends_16.png'
local FRIEND_REQUEST_ICON = 'rbxasset://textures/ui/icon_friendrequestsent_16.png'
local FRIEND_RECEIVED_ICON = 'rbxasset://textures/ui/icon_friendrequestrecieved-16.png'

local FOLLOWER_ICON = 'rbxasset://textures/ui/icon_follower-16.png'
local FOLLOWING_ICON = 'rbxasset://textures/ui/icon_following-16.png'
local MUTUAL_FOLLOWING_ICON = 'rbxasset://textures/ui/icon_mutualfollowing-16.png'

local CHARACTER_BACKGROUND_IMAGE = 'rbxasset://textures/ui/PlayerList/CharacterBackgroundImage.png'

--[[ Helper Functions ]]--
local function clamp(value, min, max)
  if value < min then
    value = min
  elseif value > max then
    value = max
  end

  return value
end

local function getFriendStatusIcon(friendStatus)
  if friendStatus == Enum.FriendStatus.Unknown or friendStatus == Enum.FriendStatus.NotFriend then
    return nil
  elseif friendStatus == Enum.FriendStatus.Friend then
    return FRIEND_ICON
  elseif friendStatus == Enum.FriendStatus.FriendRequestSent then
    return FRIEND_REQUEST_ICON
  elseif friendStatus == Enum.FriendStatus.FriendRequestReceived then
    return FRIEND_RECEIVED_ICON
  else
    error("PlayerList: Unknown value for friendStatus: "..tostring(friendStatus))
  end
end

local function getCustomPlayerIcon(player)
  local userIdStr = tostring(player.userId)
  if CUSTOM_ICONS[userIdStr] then return nil end
  --

  if PlayerPermissionsModule.IsPlayerAdminAsync(player) then
    return ADMIN_ICON
  elseif PlayerPermissionsModule.IsPlayerInternAsync(player) then
    return INTERN_ICON
  end
end

local function setAvatarIconAsync(player, iconImage)
  -- this function is pretty much for xbox right now and makes use of modules that are part
  -- of the xbox app. Please see Kip or Jason if you have any questions
  local useSubdomainsFlagExists, useSubdomainsFlagValue = pcall(function() return settings():GetFFlag("UseNewSubdomainsInCoreScripts") end)
  local thumbsUrl = BaseUrl
  if(useSubdomainsFlagExists and useSubdomainsFlagValue and AssetGameUrl~=nil) then
    thumbsUrl = AssetGameUrl
  end

  local thumbnailLoader = nil
  pcall(function()
    thumbnailLoader = require(RobloxGui.Modules.Shell.ThumbnailLoader)
  end)

  local isFinalSuccess = false
  if thumbnailLoader then
    local loader = thumbnailLoader:Create(iconImage, player.userId,
      thumbnailLoader.Sizes.Small, thumbnailLoader.AssetType.Avatar, true)
    isFinalSuccess = loader:LoadAsync(false, true, nil)
  end

  if not isFinalSuccess then
    iconImage.Image = 'rbxasset://textures/ui/Shell/Icons/DefaultProfileIcon.png'
  end
end

local function getMembershipIcon(player)
  if isTenFootInterface then
    -- return nothing, we need to spawn off setAvatarIconAsync() as a later time to not block
    return ""
  else
    if blockingUtility:IsPlayerBlockedByUserId(player.userId) then
      return BLOCKED_ICON
    else
      local userIdStr = tostring(player.userId)
      local membershipType = player.MembershipType
      if CUSTOM_ICONS[userIdStr] then
        return CUSTOM_ICONS[userIdStr]
      elseif player.userId == game.CreatorId and game.CreatorType == Enum.CreatorType.User then
        return PLACE_OWNER_ICON
      elseif membershipType == Enum.MembershipType.None then
        return ""
      elseif membershipType == Enum.MembershipType.BuildersClub then
        return BC_ICON
      elseif membershipType == Enum.MembershipType.TurboBuildersClub then
        return TBC_ICON
      elseif membershipType == Enum.MembershipType.OutrageousBuildersClub then
        return OBC_ICON
      else
        return ""
      end
    end
  end

  return ""
end

local function isValidStat(obj)
  return obj:IsA('StringValue') or obj:IsA('IntValue') or obj:IsA('BoolValue') or obj:IsA('NumberValue') or
  obj:IsA('DoubleConstrainedValue') or obj:IsA('IntConstrainedValue')
end

local function sortPlayerEntries(a, b)
  if a.PrimaryStat == b.PrimaryStat then
    return a.Player.Name:upper() < b.Player.Name:upper()
  end
  if not a.PrimaryStat then return false end
  if not b.PrimaryStat then return true end
  local statA = a.PrimaryStat
  local statB = b.PrimaryStat
  statA = tonumber(statA) or statA
  statB = tonumber(statB) or statB
  if type(statA) ~= type(statB) then
    statA = tostring(statA)
    statB = tostring(statB)
  end
  return statA > statB
end

local function sortLeaderStats(a, b)
  if a.IsPrimary ~= b.IsPrimary then
    return a.IsPrimary
  end
  if a.Priority == b.Priority then
    return a.AddId < b.AddId
  end
  return a.Priority < b.Priority
end

local function sortTeams(a, b)
  if a.TeamScore == b.TeamScore then
    return a.Id < b.Id
  end
  if not a.TeamScore then return false end
  if not b.TeamScore then return true end
  return a.TeamScore < b.TeamScore
end

-- Start of Gui Creation
local Container = Instance.new('Frame')
Container.Name = "PlayerListContainer"
Container.Size = MinContainerSize

if isTenFootInterface then
  Container.Position = UDim2.new(0.5, -MinContainerSize.X.Offset/2, 0.25, 0)  
else
  Container.Position = UDim2.new(1, -167, 0, 2)
end

-- Every time Performance Stats toggles on/off we need to 
-- reposition the main Container, so things don't overlap.
-- Optimally I could just call an "UpdateContainerPosition" function 
-- that takes into account everything that affects Container position 
-- and recalculate things.
-- 
-- Unfortunately, the position of Container may be kind of hard to re-calculate
-- on the fly when it's been shaped based on current leader board state.
--
-- So instead we do this: 
-- We always track where we'd be putting the widget if there were no 
-- position stats in targetContainerYOffset.
-- Whenever we reposition Container, we first move it to the ignoring-stats
-- location, (updating targetContainerYOffset), then call the 
-- AdjustContainerPosition function to derive final position.
local targetContainerYOffset = Container.Position.Y.Offset

Container.BackgroundTransparency = 1
Container.Visible = false
Container.Parent = RobloxGui

local function AdjustContainerPosition()
  -- A function to position the Container in light of presence of performance stats.  
  if Container == nil then
    return
  end

  -- Account for presence/absence of performance stats buttons.
  local localPlayer = PlayersService.LocalPlayer  
  local isPerformanceStatsVisible = (GameSettings.PerformanceStatsVisible and localPlayer ~= nil)
  local yOffset = targetContainerYOffset      
  if isPerformanceStatsVisible then 
    yOffset = yOffset + StatsUtils.ButtonHeight
  end

  Container.Position = UDim2.new(Container.Position.X.Scale, 
    Container.Position.X.Offset, 
    Container.Position.Y.Scale, 
    yOffset)
end

-- When quick profiler button row visiblity changes, update position of 
-- Container.
GameSettings.PerformanceStatsVisibleChanged:connect(AdjustContainerPosition)
AdjustContainerPosition()    

-- Scrolling Frame
local noSelectionObject = Instance.new("Frame")
noSelectionObject.BackgroundTransparency = 1
noSelectionObject.BorderSizePixel = 0

local ScrollList = Instance.new('ScrollingFrame')
ScrollList.Name = "ScrollList"
ScrollList.Size = UDim2.new(1, -1, 0, 0)
if isTenFootInterface then
  ScrollList.Position = UDim2.new(0, 0, 0, PlayerEntrySizeY + TILE_SPACING)
  ScrollList.Size = UDim2.new(1, 19, 0, 0)
end
ScrollList.BackgroundTransparency = 1
ScrollList.BackgroundColor3 = Color3.new()
ScrollList.BorderSizePixel = 0
ScrollList.CanvasSize = UDim2.new(0, 0, 0, 0)	-- NOTE: Look into if x needs to be set to anything
ScrollList.ScrollBarThickness = 6
ScrollList.BottomImage = 'rbxasset://textures/ui/scroll-bottom.png'
ScrollList.MidImage = 'rbxasset://textures/ui/scroll-middle.png'
ScrollList.TopImage = 'rbxasset://textures/ui/scroll-top.png'
ScrollList.SelectionImageObject = noSelectionObject
ScrollList.Selectable = false
ScrollList.Parent = Container

-- PlayerDropDown clipping frame
local PopupClipFrame = Instance.new('Frame')
PopupClipFrame.Name = "PopupClipFrame"
PopupClipFrame.Size = UDim2.new(0, 150, 1.5, 0)
PopupClipFrame.Position = UDim2.new(0, -150 - ENTRY_PAD, 0, 0)
PopupClipFrame.BackgroundTransparency = 1
PopupClipFrame.ClipsDescendants = true
PopupClipFrame.Parent = Container


--[[ Creation Helper Functions ]]--
local function createEntryFrame(name, sizeYOffset, isTopStat)
  local containerFrame = Instance.new('Frame')
  containerFrame.Name = name
  containerFrame.Position = UDim2.new(0, 0, 0, 0)
  containerFrame.Size = UDim2.new(1, 0, 0, sizeYOffset)
  if isTenFootInterface then
    containerFrame.Position = UDim2.new(0, 10, 0, 0)
    containerFrame.Size = containerFrame.Size + UDim2.new(0, -20, 0, 0)
  end
  containerFrame.BackgroundTransparency = 1
  containerFrame.ZIndex = isTenFootInterface and 2 or 1

  local nameFrame = Instance.new('TextButton')
  nameFrame.Name = "BGFrame"
  nameFrame.Position = UDim2.new(0, 0, 0, 0)
  nameFrame.Size = UDim2.new(0, NameEntrySizeX, 0, sizeYOffset)
  nameFrame.BackgroundTransparency = isTopStat and 0 or BG_TRANSPARENCY
  nameFrame.BackgroundColor3 = isTopStat and BG_COLOR_TOP or BG_COLOR
  nameFrame.BorderSizePixel = 0
  nameFrame.AutoButtonColor = false
  nameFrame.Text = ""
  nameFrame.Parent = containerFrame
  nameFrame.ZIndex = isTenFootInterface and 2 or 1

  return containerFrame, nameFrame
end

local function createEntryNameText(name, text, sizeXOffset, posXOffset)
  local nameLabel = Instance.new('TextLabel')
  nameLabel.Name = name
  nameLabel.Size = UDim2.new(-0.01, sizeXOffset, 1, 0)
  nameLabel.Position = UDim2.new(0.01, posXOffset, 0, 0)
  nameLabel.BackgroundTransparency = 1
  nameLabel.Font = Enum.Font.SourceSans
  if isTenFootInterface then
    nameLabel.FontSize = Enum.FontSize.Size32
  else
    nameLabel.FontSize = Enum.FontSize.Size14
  end
  nameLabel.TextColor3 = TEXT_COLOR
  nameLabel.TextStrokeTransparency = TEXT_STROKE_TRANSPARENCY
  nameLabel.TextStrokeColor3 = TEXT_STROKE_COLOR
  nameLabel.TextXAlignment = Enum.TextXAlignment.Left
  nameLabel.ClipsDescendants = true
  nameLabel.Text = text
  nameLabel.ZIndex = isTenFootInterface and 2 or 1

  return nameLabel
end

local function createStatFrame(offset, parent, name, isTopStat)
  local statFrame = Instance.new('Frame')
  statFrame.Name = name
  statFrame.Size = UDim2.new(0, StatEntrySizeX, 1, 0)
  statFrame.Position = UDim2.new(0, offset + TILE_SPACING, 0, 0)
  statFrame.BackgroundTransparency = isTopStat and 0 or BG_TRANSPARENCY
  statFrame.BackgroundColor3 = isTopStat and BG_COLOR_TOP or BG_COLOR
  statFrame.BorderSizePixel = 0
  statFrame.Parent = parent

  if isTenFootInterface then
    statFrame.ZIndex = 2

    local shadow = Instance.new("ImageLabel")
    shadow.BackgroundTransparency = 1
    shadow.Name = 'Shadow'
    shadow.Image = SHADOW_IMAGE
    shadow.Position = UDim2.new(0, -SHADOW_SLICE_SIZE, 0, 0)
    shadow.Size = UDim2.new(1, SHADOW_SLICE_SIZE*2, 1, SHADOW_SLICE_SIZE)
    shadow.ScaleType = 'Slice'
    shadow.SliceCenter = SHADOW_SLICE_RECT
    shadow.Parent = statFrame
  end

  return statFrame
end

local function createStatText(parent, text, isTopStat, isTeamStat)
  local statText = Instance.new('TextLabel')
  statText.Name = "StatText"
  statText.Size = isTopStat and UDim2.new(1, 0, 0.5, 0) or UDim2.new(1, 0, 1, 0)
  statText.Position = isTopStat and UDim2.new(0, 0, 0.5, 0) or UDim2.new(0, 0, 0, 0)
  statText.BackgroundTransparency = 1
  statText.Font = isTopStat and Enum.Font.SourceSansBold or Enum.Font.SourceSans
  if isTenFootInterface then
    statText.FontSize = Enum.FontSize.Size32
  else
    statText.FontSize = Enum.FontSize.Size14
  end
  statText.TextColor3 = TEXT_COLOR
  statText.TextStrokeColor3 = TEXT_STROKE_COLOR
  statText.TextStrokeTransparency = TEXT_STROKE_TRANSPARENCY
  statText.Text = text
  statText.Active = true
  statText.Parent = parent
  if isTenFootInterface then
    statText.ZIndex = 2
  end

  if isTopStat then
    local statName = statText:Clone()
    statName.Name = "StatName"
    statName.Text = tostring(parent.Name)
    statName.Position = UDim2.new(0,0,0,0)
    statName.Font = Enum.Font.SourceSans
    statName.ClipsDescendants = true
    statName.Parent = parent
    if isTenFootInterface then
      statName.ZIndex = 2
    end
  end

  if isTeamStat then
    statText.Font = 'SourceSansBold'
  end

  return statText
end

local function createImageIcon(image, name, xOffset, parent)
  local imageLabel = Instance.new('ImageLabel')
  imageLabel.Name = name
  if isTenFootInterface then
    imageLabel.Size = UDim2.new(0, 64, 0, 64)
    imageLabel.ZIndex = 2

    local background = Instance.new("ImageLabel", imageLabel)
    background.Name = 'Background'
    background.BackgroundTransparency = 1
    background.Image = CHARACTER_BACKGROUND_IMAGE
    background.Size = UDim2.new(0, 66, 0, 66)
    background.Position = UDim2.new(0.5, -66/2, 0.5, -66/2)
    background.ZIndex = 2
  else
    imageLabel.Size = UDim2.new(0, 16, 0, 16)
  end
  imageLabel.Position = UDim2.new(0.01, xOffset, 0.5, -imageLabel.Size.Y.Offset/2)
  imageLabel.BackgroundTransparency = 1
  imageLabel.Image = image
  imageLabel.BorderSizePixel = 0
  imageLabel.Parent = parent

  return imageLabel
end

local function getScoreValue(statObject)
  if statObject:IsA('DoubleConstrainedValue') or statObject:IsA('IntConstrainedValue') then
    return statObject.ConstrainedValue
  elseif statObject:IsA('BoolValue') then
    if statObject.Value then return 1 else return 0 end
  else
    return statObject.Value
  end
end

local THIN_CHARS = "[^%[iIl\%.,']"
local function strWidth(str)
  return string.len(str) - math.floor(string.len(string.gsub(str, THIN_CHARS, "")) / 2)
end

local function formatNumber(value)
  local _,_,minusSign, int, fraction = tostring(value):find('([-]?)(%d+)([.]?%d*)')
  int = int:reverse():gsub("%d%d%d", "%1,")
  return minusSign..int:reverse():gsub("^,", "")..fraction
end

local function formatStatString(text)
  local numberValue = tonumber(text)
  if numberValue then
    text = formatNumber(numberValue)
  end

  if strWidth(text) <= MAX_STR_LEN then
    return text
  else
    return string.sub(text, 1, MAX_STR_LEN - 3).."..."
  end
end

--[[ Resize Functions ]]--
local LastMaxScrollSize = 0
local function setScrollListSize()
  local teamSize = #TeamEntries * TeamEntrySizeY
  local playerSize = #PlayerEntries * PlayerEntrySizeY
  local spacing = #PlayerEntries * ENTRY_PAD + #TeamEntries * ENTRY_PAD
  local canvasSize = teamSize + playerSize + spacing
  if #TeamEntries > 0 and NeutralTeam and IsShowingNeutralFrame then
    canvasSize = canvasSize + TeamEntrySizeY + ENTRY_PAD
  end
  ScrollList.CanvasSize = UDim2.new(0, 0, 0, canvasSize)
  local newScrollListSize = math.min(canvasSize, Container.AbsoluteSize.y)
  if ScrollList.Size.Y.Offset == LastMaxScrollSize then
    if isTenFootInterface then
      ScrollList.Size = UDim2.new(1, 20, 0, newScrollListSize)
    else
      ScrollList.Size = UDim2.new(1, 0, 0, newScrollListSize)
    end
  end
  LastMaxScrollSize = newScrollListSize
end

--[[ Re-position Functions ]]--
local function setPlayerEntryPositions()
  local position = 0
  for i = 1, #PlayerEntries do
    if isTenFootInterface and PlayerEntries[i].Frame ~= MyPlayerEntryTopFrame then
      PlayerEntries[i].Frame.Position = UDim2.new(0, 10, 0, position)
      position = position + PlayerEntrySizeY + TILE_SPACING
    elseif PlayerEntries[i].Frame ~= MyPlayerEntryTopFrame then
      PlayerEntries[i].Frame.Position = UDim2.new(0, 0, 0, position)
      position = position + PlayerEntrySizeY + TILE_SPACING
    end
  end
end

local function setTeamEntryPositions()
  local teams = {}
  for _,teamEntry in ipairs(TeamEntries) do
    local team = teamEntry.Team
    teams[tostring(team.TeamColor)] = {}
  end
  if NeutralTeam then
    teams.Neutral = {}
  end

  for _,playerEntry in ipairs(PlayerEntries) do
    if playerEntry.Frame ~= MyPlayerEntryTopFrame then
      local player = playerEntry.Player
      if player.Neutral then
        table.insert(teams.Neutral, playerEntry)
      elseif teams[tostring(player.TeamColor)] then
        table.insert(teams[tostring(player.TeamColor)], playerEntry)
      else
        table.insert(teams.Neutral, playerEntry)
      end
    end
  end

  local position = 0
  for _,teamEntry in ipairs(TeamEntries) do
    local team = teamEntry.Team
    teamEntry.Frame.Position = UDim2.new(0, isTenFootInterface and 10 or 0, 0, position)
    position = position + TeamEntrySizeY + TILE_SPACING
    local players = teams[tostring(team.TeamColor)]
    for _,playerEntry in ipairs(players) do
      playerEntry.Frame.Position = UDim2.new(0, isTenFootInterface and 10 or 0, 0, position)
      position = position + PlayerEntrySizeY + TILE_SPACING
    end
  end
  if NeutralTeam then
    NeutralTeam.Frame.Position = UDim2.new(0, isTenFootInterface and 10 or 0, 0, position)
    position = position + TeamEntrySizeY + TILE_SPACING
    if #teams.Neutral > 0 then
      IsShowingNeutralFrame = true
      local players = teams.Neutral
      for _,playerEntry in ipairs(players) do
        playerEntry.Frame.Position = UDim2.new(0, isTenFootInterface and 10 or 0, 0, position)
        position = position + PlayerEntrySizeY + TILE_SPACING
      end
    else
      IsShowingNeutralFrame = false
    end
  end
end

local function setEntryPositions()
  table.sort(PlayerEntries, sortPlayerEntries)
  if #TeamEntries > 0 then
    setTeamEntryPositions()
  else
    setPlayerEntryPositions()
  end
end

local function updateSocialIcon(newIcon, bgFrame)
  local socialIcon = bgFrame:FindFirstChild('SocialIcon')
  local nameFrame = bgFrame:FindFirstChild('PlayerName')
  local offset = 19
  if socialIcon then
    if newIcon then
      socialIcon.Image = newIcon
    else
      if nameFrame then
        local newSize = nameFrame.Size.X.Offset + socialIcon.Size.X.Offset + 2
        nameFrame.Size = UDim2.new(-0.01, newSize, 0.5, 0)
        nameFrame.Position = UDim2.new(0.01, offset, 0.245, 0)
      end
      socialIcon:Destroy()
    end
  elseif newIcon and bgFrame then
    socialIcon = createImageIcon(newIcon, "SocialIcon", offset, bgFrame)
    offset = offset + socialIcon.Size.X.Offset + 2
    if nameFrame then
      local newSize = bgFrame.Size.X.Offset - offset
      nameFrame.Size = UDim2.new(-0.01, newSize, 0.5, 0)
      nameFrame.Position = UDim2.new(0.01, offset, 0.245, 0)
    end
  end
end

local function getFriendStatus(selectedPlayer)
  if selectedPlayer == Player then
    return Enum.FriendStatus.NotFriend
  else
    local success, result = pcall(function()
        -- NOTE: Core script only
        return Player:GetFriendStatus(selectedPlayer)
      end)
    if success then
      return result
    else
      return Enum.FriendStatus.NotFriend
    end
  end
end

function popupHidden()
  if LastSelectedFrame then
    for _,childFrame in pairs(LastSelectedFrame:GetChildren()) do
      if childFrame:IsA('TextButton') or childFrame:IsA('Frame') then
        childFrame.BackgroundColor3 = BG_COLOR
      end
    end
  end
  ScrollList.ScrollingEnabled = true
  LastSelectedFrame = nil
  LastSelectedPlayer = nil
end
playerDropDown.HiddenSignal:connect(popupHidden)

local function openPlatformProfileUI(rbxUid)
  if not rbxUid or rbxUid < 1 then return end
  pcall(function()
      local platformService = game:GetService('PlatformService')
      local platformId = platformService:GetPlatformId(rbxUid)
      if platformId and #platformId > 0 then
        platformService:PopupProfileUI(Enum.UserInputType.Gamepad1, platformId)
      end
    end)
end

local function onEntryFrameSelected(selectedFrame, selectedPlayer)
  if isTenFootInterface then
    -- open the profile UI for the selected user. On console we allow user to select themselves
    -- they may want quick access to platform profile features
    openPlatformProfileUI(selectedPlayer.userId)
    return
  end

  if selectedPlayer ~= Player and selectedPlayer.userId > 1 and Player.userId > 1 then
    if LastSelectedFrame ~= selectedFrame then
      if LastSelectedFrame then
        for _,childFrame in pairs(LastSelectedFrame:GetChildren()) do
          if childFrame:IsA('TextButton') or childFrame:IsA('Frame') then
            childFrame.BackgroundColor3 = BG_COLOR
          end
        end
      end
      LastSelectedFrame = selectedFrame
      LastSelectedPlayer = selectedPlayer
      for _,childFrame in pairs(selectedFrame:GetChildren()) do
        if childFrame:IsA('TextButton') or childFrame:IsA('Frame') then
          childFrame.BackgroundColor3 = Color3.new(0, 1, 1)
        end
      end
      -- NOTE: Core script only
      ScrollList.ScrollingEnabled = false

      local PopupFrame = playerDropDown:CreatePopup(selectedPlayer)		
      PopupFrame.Position = UDim2.new(1, 1, 0, selectedFrame.Position.Y.Offset - ScrollList.CanvasPosition.y)
      PopupFrame.Parent = PopupClipFrame
      PopupFrame:TweenPosition(UDim2.new(0, 0, 0, selectedFrame.Position.Y.Offset - ScrollList.CanvasPosition.y), Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, TWEEN_TIME, true)
    else
      playerDropDown:Hide()
      LastSelectedFrame = nil
      LastSelectedPlayer = nil
    end
  end
end

local function onFriendshipChanged(otherPlayer, newFriendStatus)
  local entryToUpdate = nil
  for _,entry in ipairs(PlayerEntries) do
    if entry.Player == otherPlayer then
      entryToUpdate = entry
      break
    end
  end
  if not entryToUpdate then
    return
  end
  local newIcon = getFriendStatusIcon(newFriendStatus)
  local frame = entryToUpdate.Frame
  local bgFrame = frame:FindFirstChild('BGFrame')
  if bgFrame then
    --no longer friends, but might still be following
    -- TODO: We need to get follow relationship here; we currently don't have a way
    -- to get a single users result, so the server script will need to be updated
    -- issue will be when unfriending a user, but still following them, the icon
    -- will not show correctly.
    updateSocialIcon(newIcon, bgFrame)
  end
end

-- NOTE: Core script only. This fires when a player joins the game.
-- Don't listen/show rbx friends status on xbox
if not isTenFootInterface then
  Player.FriendStatusChanged:connect(onFriendshipChanged)
end

--[[ Begin New Server Followers ]]--
local function setFollowRelationshipsView(relationshipTable)
  if not relationshipTable then
    return
  end

  for i = 1, #PlayerEntries do
    local entry = PlayerEntries[i]
    local player = entry.Player
    local userId = tostring(player.userId)

    -- don't update icon if already friends
    local friendStatus = getFriendStatus(player)
    if friendStatus == Enum.FriendStatus.Friend then
      return
    end

    local icon = nil
    if relationshipTable[userId] then
      local relationship = relationshipTable[userId]
      if relationship.IsMutual == true then
        icon = MUTUAL_FOLLOWING_ICON
      elseif relationship.IsFollowing == true then
        icon = FOLLOWING_ICON
      elseif relationship.IsFollower == true then
        icon = FOLLOWER_ICON
      end
    end

    local frame = entry.Frame
    local bgFrame = frame:FindFirstChild('BGFrame')
    if bgFrame then
      updateSocialIcon(icon, bgFrame)
    end
  end
end

local function getFollowRelationships()
  local result = nil
  if RemoteFunc_GetFollowRelationships then
    result = RemoteFunc_GetFollowRelationships:InvokeServer()
  end
  return result
end

--[[ End New Server Followers ]]--

local function updateAllTeamScores()
  local teamScores = {}
  for _,playerEntry in ipairs(PlayerEntries) do
    local player = playerEntry.Player
    local leaderstats = player:FindFirstChild('leaderstats')
    local team = player.Neutral and 'Neutral' or tostring(player.TeamColor)
    local isInValidColor = true
    if team ~= 'Neutral' then
      for _,teamEntry in ipairs(TeamEntries) do
        local color = teamEntry.Team.TeamColor
        if team == tostring(color) then
          isInValidColor = false
          break
        end
      end
    end
    if isInValidColor then
      team = 'Neutral'
    end
    if not teamScores[team] then
      teamScores[team] = {}
    end
    if playerEntry.Frame ~= MyPlayerEntryTopFrame then
      if leaderstats then
        for _,stat in ipairs(GameStats) do
          local statObject = leaderstats:FindFirstChild(stat.Name)
          if statObject and not statObject:IsA('StringValue') then
            if not teamScores[team][stat.Name] then
              teamScores[team][stat.Name] = 0
            end
            teamScores[team][stat.Name] = teamScores[team][stat.Name] + getScoreValue(statObject)
          end
        end
      end
    end
  end

  for _,teamEntry in ipairs(TeamEntries) do
    local team = teamEntry.Team
    local frame = teamEntry.Frame
    local color = tostring(team.TeamColor)
    local stats = teamScores[color]
    if stats then
      for statName,statValue in pairs(stats) do
        local statFrame = frame:FindFirstChild(statName)
        if statFrame then
          local statText = statFrame:FindFirstChild('StatText')
          if statText then
            statText.Text = formatStatString(tostring(statValue))
          end
        end
      end
    else
      for _,childFrame in pairs(frame:GetChildren()) do
        local statText = childFrame:FindFirstChild('StatText')
        if statText then
          statText.Text = ''
        end
      end
    end
  end
  if NeutralTeam then
    local frame = NeutralTeam.Frame
    local stats = teamScores['Neutral']
    if stats then
      frame.Visible = true
      for statName,statValue in pairs(stats) do
        local statFrame = frame:FindFirstChild(statName)
        if statFrame then
          local statText = statFrame:FindFirstChild('StatText')
          if statText then
            statText.Text = formatStatString(tostring(statValue))
          end
        end
      end
    else
      frame.Visible = false
    end
  end
end

local function updateTeamEntry(entry)
  local frame = entry.Frame
  local team = entry.Team
  local color = team.TeamColor.Color
  local offset = NameEntrySizeX
  for _,stat in ipairs(GameStats) do
    local statFrame = frame:FindFirstChild(stat.Name)
    if not statFrame then
      statFrame = createStatFrame(offset, frame, stat.Name)
      statFrame.BackgroundColor3 = color
      createStatText(statFrame, "", false, true)
    end
    statFrame.Position = UDim2.new(0, offset + TILE_SPACING, 0, 0)
    offset = offset + statFrame.Size.X.Offset + TILE_SPACING
  end
end

local function updatePrimaryStats(statName)
  for _,entry in ipairs(PlayerEntries) do
    local player = entry.Player
    local leaderstats = player:FindFirstChild('leaderstats')
    entry.PrimaryStat = nil
    if leaderstats then
      local statObject = leaderstats:FindFirstChild(statName)
      if statObject then
        local scoreValue = getScoreValue(statObject)
        entry.PrimaryStat = scoreValue
      end
    end
  end
end

local updateLeaderstatFrames = nil
-- TODO: fire event to top bar?
local function initializeStatText(stat, statObject, entry, statFrame, index, isTopStat)
  local player = entry.Player
  local statValue = getScoreValue(statObject)
  if statObject.Name == GameStats[1].Name then
    entry.PrimaryStat = statValue
  end
  local statText = createStatText(statFrame, formatStatString(tostring(statValue)), isTopStat)
  -- Top Bar insertion
  if player == Player then
    stat.Text = statText.Text
  end

  statObject.Changed:connect(function(newValue)
      local scoreValue = getScoreValue(statObject)
      statText.Text = formatStatString(tostring(scoreValue))
      if statObject.Name == GameStats[1].Name then
        entry.PrimaryStat = scoreValue
      end
      -- Top bar changed event
      if player == Player then
        stat.Text = statText.Text
        Playerlist.OnStatChanged:Fire(stat.Name, stat.Text)
      end
      updateAllTeamScores()
      setEntryPositions()
    end)
  statObject.ChildAdded:connect(function(child)
      if child.Name == "IsPrimary" then
        GameStats[1].IsPrimary = false
        stat.IsPrimary = true
        updatePrimaryStats(stat.Name)
        if updateLeaderstatFrames then updateLeaderstatFrames() end
        Playerlist.OnLeaderstatsChanged:Fire(GameStats)
      end
    end)
end

updateLeaderstatFrames = function()
  table.sort(GameStats, sortLeaderStats)
  if #TeamEntries > 0 then
    for _,entry in ipairs(TeamEntries) do
      updateTeamEntry(entry)
    end
    if NeutralTeam then
      updateTeamEntry(NeutralTeam)
    end
  end

  for _,entry in ipairs(PlayerEntries) do
    local player = entry.Player
    local mainFrame = entry.Frame
    local offset = NameEntrySizeX
    local leaderstats = player:FindFirstChild('leaderstats')
    local isTopStat = (entry.Frame == MyPlayerEntryTopFrame)

    if leaderstats then
      for _,stat in ipairs(GameStats) do
        local statObject = leaderstats:FindFirstChild(stat.Name)
        local statFrame = mainFrame:FindFirstChild(stat.Name)

        if not statFrame then
          statFrame = createStatFrame(offset, mainFrame, stat.Name, isTopStat)
          if statObject then
            initializeStatText(stat, statObject, entry, statFrame, _, isTopStat)
          end
        elseif statObject then
          local statText = statFrame:FindFirstChild('StatText')
          if not statText then
            initializeStatText(stat, statObject, entry, statFrame, _, isTopStat)
          end
        end
        statFrame.Position = UDim2.new(0, offset + TILE_SPACING, 0, 0)
        offset = offset + statFrame.Size.X.Offset + TILE_SPACING
      end
    else
      for _,stat in ipairs(GameStats) do
        local statFrame = mainFrame:FindFirstChild(stat.Name)
        if not statFrame then
          statFrame = createStatFrame(offset, mainFrame, stat.Name, isTopStat)
        end
        offset = offset + statFrame.Size.X.Offset + TILE_SPACING
      end
    end

    if entry.Frame ~= MyPlayerEntryTopFrame then
      if isTenFootInterface then
        Container.Position = UDim2.new(0.5, -offset/2, 0, 110)
        Container.Size = UDim2.new(0, offset, 0.8, 0)
      else
        Container.Position = UDim2.new(1, -offset, 0, 2)
        Container.Size = UDim2.new(0, offset, 0.5, 0)
      end
      targetContainerYOffset = Container.Position.Y.Offset
      AdjustContainerPosition()

      local newMinContainerOffset = offset
      MinContainerSize = UDim2.new(0, newMinContainerOffset, 0.5, 0)
    end
  end
  updateAllTeamScores()
  setEntryPositions()
  Playerlist.OnLeaderstatsChanged:Fire(GameStats)
end

local function addNewStats(leaderstats)
  for i,stat in ipairs(leaderstats:GetChildren()) do
    if isValidStat(stat) and #GameStats < MAX_LEADERSTATS then
      local gameHasStat = false
      for _,gStat in ipairs(GameStats) do
        if stat.Name == gStat.Name then
          gameHasStat = true
          break
        end
      end

      if not gameHasStat then
        local newStat = {}
        newStat.Name = stat.Name
        newStat.Text = "-"
        newStat.Priority = 0
        local priority = stat:FindFirstChild('Priority')
        if priority then newStat.Priority = priority end
        newStat.IsPrimary = false
        local isPrimary = stat:FindFirstChild('IsPrimary')
        if isPrimary then
          newStat.IsPrimary = true
        end
        newStat.AddId = StatAddId
        StatAddId = StatAddId + 1
        table.insert(GameStats, newStat)
        table.sort(GameStats, sortLeaderStats)
        if #GameStats == 1 then
          setScrollListSize()
          setEntryPositions()
        end
      end
    end
  end
end

local function removeStatFrameFromEntry(stat, frame)
  local statFrame = frame:FindFirstChild(stat.Name)
  if statFrame then
    statFrame:Destroy()
  end
end

local function doesStatExists(stat)
  local doesExists = false
  for _,entry in ipairs(PlayerEntries) do
    local player = entry.Player
    if player then
      local leaderstats = player:FindFirstChild('leaderstats')
      if leaderstats and leaderstats:FindFirstChild(stat.Name) then
        doesExists = true
        break
      end
    end
  end

  return doesExists
end

local function onStatRemoved(oldStat, entry)
  if isValidStat(oldStat) then
    removeStatFrameFromEntry(oldStat, entry.Frame)
    local statExists = doesStatExists(oldStat)
    --
    local toRemove = nil
    for i, stat in ipairs(GameStats) do
      if stat.Name == oldStat.Name then
        toRemove = i
        break
      end
    end
    -- removed from player but not from game; another player still has this stat
    if statExists then
      if toRemove and entry.Player == Player then
        GameStats[toRemove].Text = "-"
        Playerlist.OnStatChanged:Fire(GameStats[toRemove].Name, GameStats[toRemove].Text)
      end
      -- removed from game
    else
      for _,playerEntry in ipairs(PlayerEntries) do
        removeStatFrameFromEntry(oldStat, playerEntry.Frame)
      end
      for _,teamEntry in ipairs(TeamEntries) do
        removeStatFrameFromEntry(oldStat, teamEntry.Frame)
      end
      if toRemove then
        table.remove(GameStats, toRemove)
        table.sort(GameStats, sortLeaderStats)
      end
    end
    if GameStats[1] then
      updatePrimaryStats(GameStats[1].Name)
    end
    updateLeaderstatFrames()
  end
end

local function onStatAdded(leaderstats, entry)
  leaderstats.ChildAdded:connect(function(newStat)
      if isValidStat(newStat) then
        addNewStats(newStat.Parent)
        updateLeaderstatFrames()
      end
    end)
  leaderstats.ChildRemoved:connect(function(child)
      onStatRemoved(child, entry)
    end)
  addNewStats(leaderstats)
  updateLeaderstatFrames()
end

local function setLeaderStats(entry)
  local player = entry.Player
  local leaderstats = player:FindFirstChild('leaderstats')

  if leaderstats then
    onStatAdded(leaderstats, entry)
  end

  local function onPlayerChildChanged(property, child)
    if property == 'Name' and child.Name == 'leaderstats' then
      onStatAdded(child, entry)
    end
  end

  player.ChildAdded:connect(function(child)
      if child.Name == 'leaderstats' then
        onStatAdded(child, entry)
      end
      child.Changed:connect(function(property) onPlayerChildChanged(property, child) end)
    end)
  for _,child in pairs(player:GetChildren()) do
    child.Changed:connect(function(property) onPlayerChildChanged(property, child) end)
  end

  player.ChildRemoved:connect(function(child)
      if child.Name == 'leaderstats' then
        for i,stat in ipairs(child:GetChildren()) do
          onStatRemoved(stat, entry)
        end
        updateLeaderstatFrames()
      end
    end)
end

local offsetSize = 18
if isTenFootInterface then offsetSize = 32 end

local function createPlayerEntry(player, isTopStat)
  local playerEntry = {}
  local name = player.Name

  local containerFrame, entryFrame = createEntryFrame(name, PlayerEntrySizeY, isTopStat)
  entryFrame.Active = true

  entryFrame.MouseButton1Click:connect(function()
      onEntryFrameSelected(containerFrame, player)
    end)

  local currentXOffset = 1

  -- check membership
  local membershipIconImage = getMembershipIcon(player)
  local membershipIcon = nil
  if membershipIconImage then
    membershipIcon = createImageIcon(membershipIconImage, "MembershipIcon", currentXOffset, entryFrame)
    currentXOffset = currentXOffset + membershipIcon.Size.X.Offset + 2
  else
    currentXOffset = currentXOffset + offsetSize
  end

  spawn(function()
      if isTenFootInterface and membershipIcon then
        setAvatarIconAsync(player, membershipIcon)
      end
    end)

  -- Some functions yield, so we need to spawn off in order to not cause a race condition with other events like PlayersService.ChildRemoved
  spawn(function()
      local success, result = pcall(function()
          return player:GetRankInGroup(game.CreatorId) == 255
        end)
      if success then
        if game.CreatorType == Enum.CreatorType.Group and result then
          membershipIconImage = PLACE_OWNER_ICON
          if not membershipIcon then
            membershipIcon = createImageIcon(membershipIconImage, "MembershipIcon", 1, entryFrame)
          else
            membershipIcon.Image = membershipIconImage
          end
        end
      else
        print("PlayerList: GetRankInGroup failed because", result)
      end
      local iconImage = getCustomPlayerIcon(player)
      if iconImage then
        if not membershipIcon then
          membershipIcon = createImageIcon(iconImage, "MembershipIcon", 1, entryFrame)
        else
          membershipIcon.Image = iconImage
        end
      end
      -- Friendship and Follower status is checked by onFriendshipChanged, which is called by the FriendStatusChanged
      -- event. This event is fired when any player joins the game. onFriendshipChanged will check Follower status in
      -- the case that we are not friends with the new player who is joining.
    end)

  local playerNameXSize = entryFrame.Size.X.Offset - currentXOffset
  local playerName = createEntryNameText("PlayerName", name, playerNameXSize, currentXOffset)
  playerName.Parent = entryFrame
  playerEntry.Player = player
  playerEntry.Frame = containerFrame

  if isTenFootInterface then
    local shadow = Instance.new("ImageLabel")
    shadow.BackgroundTransparency = 1
    shadow.Name = 'Shadow'
    shadow.Image = SHADOW_IMAGE
    shadow.Position = UDim2.new(0, -SHADOW_SLICE_SIZE, 0, 0)
    shadow.Size = UDim2.new(1, SHADOW_SLICE_SIZE*2, 1, SHADOW_SLICE_SIZE)
    shadow.ScaleType = 'Slice'
    shadow.SliceCenter = SHADOW_SLICE_RECT
    shadow.Parent = entryFrame
  end

  if isTopStat then
    playerName.Font = 'SourceSansBold'
  end

  return playerEntry
end

local function createTeamEntry(team)
  local teamEntry = {}
  teamEntry.Team = team
  teamEntry.TeamScore = 0

  local containerFrame, entryFrame = createEntryFrame(team.Name, TeamEntrySizeY)
  entryFrame.Selectable = false	-- dont allow gamepad selection of team frames
  entryFrame.BackgroundColor3 = team.TeamColor.Color

  local teamName = createEntryNameText("TeamName", team.Name, entryFrame.AbsoluteSize.x, 1)
  teamName.Parent = entryFrame

  teamEntry.Frame = containerFrame

  if isTenFootInterface then
    local shadow = Instance.new("ImageLabel")
    shadow.BackgroundTransparency = 1
    shadow.Name = 'Shadow'
    shadow.Image = SHADOW_IMAGE
    shadow.Position = UDim2.new(0, -SHADOW_SLICE_SIZE, 0, 0)
    shadow.Size = UDim2.new(1, SHADOW_SLICE_SIZE*2, 1, SHADOW_SLICE_SIZE)
    shadow.ScaleType = 'Slice'
    shadow.SliceCenter = SHADOW_SLICE_RECT
    shadow.Parent = entryFrame
  end

  -- connections
  team.Changed:connect(function(property)
      if property == 'Name' then
        teamName.Text = team.Name
      elseif property == 'TeamColor' then
        for _,childFrame in pairs(containerFrame:GetChildren()) do
          if childFrame:IsA('GuiObject') then
            childFrame.BackgroundColor3 = team.TeamColor.Color
          end
        end

        setTeamEntryPositions()
        updateAllTeamScores()
        setEntryPositions()
        setScrollListSize()
      end
    end)

  return teamEntry
end

local function createNeutralTeam()
  if not NeutralTeam then
    local team = Instance.new('Team')
    team.Name = 'Neutral'
    team.TeamColor = BrickColor.new('White')
    NeutralTeam = createTeamEntry(team)
    NeutralTeam.Frame.Parent = ScrollList
  end
end

--[[ Insert/Remove Player Functions ]]--
local function setupEntry(player, newEntry, isTopStat)
  setLeaderStats(newEntry)

  if isTopStat then
    newEntry.Frame.Parent = Container
    table.insert(PlayerEntries, newEntry)
  else
    newEntry.Frame.Parent = ScrollList
    table.insert(PlayerEntries, newEntry)
    setScrollListSize()
  end

  updateLeaderstatFrames()

  player.Changed:connect(function(property)
      if #TeamEntries > 0 and (property == 'Neutral' or property == 'TeamColor') then
        setTeamEntryPositions()
        updateAllTeamScores()
        setEntryPositions()
        setScrollListSize()
      end
    end)
end

local function insertPlayerEntry(player)
  local entry = createPlayerEntry(player)
  setupEntry(player, entry)

  -- create an entry on the top of the playerlist
  if player == Player and isTenFootInterface then
    local localEntry = createPlayerEntry(player, true)
    MyPlayerEntryTopFrame = localEntry.Frame
    MyPlayerEntryTopFrame.BackgroundTransparency = 1
    MyPlayerEntryTopFrame.BorderSizePixel = 0
    setupEntry(player, localEntry, true)
  end
end

local function removePlayerEntry(player)
  for i = 1, #PlayerEntries do
    if PlayerEntries[i].Player == player then
      PlayerEntries[i].Frame:Destroy()
      table.remove(PlayerEntries, i)
      break
    end
  end
  setEntryPositions()
  setScrollListSize()
end

--[[ Team Functions ]]--
local function onTeamAdded(team)
  for i = 1, #TeamEntries do
    if TeamEntries[i].Team.TeamColor == team.TeamColor then
      TeamEntries[i].Frame:Destroy()
      table.remove(TeamEntries, i)
      break
    end
  end
  local entry = createTeamEntry(team)
  entry.Id = TeamAddId
  TeamAddId = TeamAddId + 1
  if not NeutralTeam then
    createNeutralTeam()
  end
  table.insert(TeamEntries, entry)
  table.sort(TeamEntries, sortTeams)
  setTeamEntryPositions()
  updateLeaderstatFrames()
  setScrollListSize()
  entry.Frame.Parent = ScrollList
end

local function onTeamRemoved(removedTeam)
  for i = 1, #TeamEntries do
    local team = TeamEntries[i].Team
    if team.Name == removedTeam.Name then
      TeamEntries[i].Frame:Destroy()
      table.remove(TeamEntries, i)
      break
    end
  end
  if #TeamEntries == 0 then
    if NeutralTeam then
      NeutralTeam.Frame:Destroy()
      NeutralTeam.Team:Destroy()
      NeutralTeam = nil
      IsShowingNeutralFrame = false
    end
  end
  setEntryPositions()
  updateLeaderstatFrames()
  setScrollListSize()
end

--[[ Resize/Position Functions ]]--
local function clampCanvasPosition()
  local maxCanvasPosition = ScrollList.CanvasSize.Y.Offset - ScrollList.Size.Y.Offset
  if maxCanvasPosition >= 0 and ScrollList.CanvasPosition.y > maxCanvasPosition then
    ScrollList.CanvasPosition = Vector2.new(0, maxCanvasPosition)
  end
end

local function resizePlayerList()
  setScrollListSize()
  clampCanvasPosition()
end

RobloxGui.Changed:connect(function(property)
    if property == 'AbsoluteSize' then
      spawn(function()	-- must spawn because F11 delays when abs size is set
          resizePlayerList()
        end)
    end
  end)

UserInputService.InputBegan:connect(function(inputObject, isProcessed)
    if isProcessed then return end
    local inputType = inputObject.UserInputType
    if (inputType == Enum.UserInputType.Touch and  inputObject.UserInputState == Enum.UserInputState.Begin) or
    inputType == Enum.UserInputType.MouseButton1 then
      if LastSelectedFrame then
        playerDropDown:Hide()
      end
    end
  end)

-- NOTE: Core script only

--[[ Player Add/Remove Connections ]]--
PlayersService.PlayerAdded:connect(function(child)
  insertPlayerEntry(child)
end)

for _, player in ipairs(PlayersService:GetPlayers()) do
  insertPlayerEntry(player)
end

--[[ Begin new Server Followers ]]--
-- Don't listen/show rbx followers status on console
if not isTenFootInterface then
  -- spawn so we don't block script
  spawn(function()
    local RobloxReplicatedStorage = game:GetService('RobloxReplicatedStorage')
    RemoveEvent_OnFollowRelationshipChanged = RobloxReplicatedStorage:WaitForChild('FollowRelationshipChanged', 86400) or RobloxReplicatedStorage:WaitForChild('FollowRelationshipChanged')
    RemoteFunc_GetFollowRelationships = RobloxReplicatedStorage:WaitForChild('GetFollowRelationships')

    RemoveEvent_OnFollowRelationshipChanged.OnClientEvent:connect(function(result)
      setFollowRelationshipsView(result)
    end)

    local result = getFollowRelationships()
    setFollowRelationshipsView(result)
  end)
end

PlayersService.ChildRemoved:connect(function(child)
  if child:IsA("Player") then
    if LastSelectedPlayer and child == LastSelectedPlayer then
      playerDropDown:Hide()
    end
    removePlayerEntry(child)
  end
end)

--[[ Teams ]]--
local function initializeTeams(teams)
  for _,team in pairs(teams:GetTeams()) do
    onTeamAdded(team)
  end

  teams.ChildAdded:connect(function(team)
      if team:IsA('Team') then
        onTeamAdded(team)
      end
    end)

  teams.ChildRemoved:connect(function(team)
      if team:IsA('Team') then
        onTeamRemoved(team)
      end
    end)
end

TeamsService = game:FindService('Teams')
if TeamsService then
  initializeTeams(TeamsService)
end

game.ChildAdded:connect(function(child)
    if child:IsA('Teams') then
      initializeTeams(child)
    end
  end)

--[[ Public API ]]--
Playerlist.GetStats = function()
  return GameStats
end

local noOpFunc = function ( )
end

local isOpen = not isTenFootInterface

local closeListFunc = function(name, state, input)
  if state ~= Enum.UserInputState.Begin then return end

  isOpen = false
  Container.Visible = false
  spawn(function() GuiService:SetMenuIsOpen(false) end)
  ContextActionService:UnbindCoreAction("CloseList")
  ContextActionService:UnbindCoreAction("StopAction")
  GuiService:RemoveSelectionGroup("PlayerlistGuiSelection")
  GuiService.SelectedCoreObject = nil
  UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.None
end

local setVisible = function(state, fromTemp)
  Container.Visible = state

  if state then
    local children = ScrollList:GetChildren()
    if children and #children > 0 then
      local frame = children[1]
      local frameChildren = frame:GetChildren()
      for i = 1, #frameChildren do
        if frameChildren[i]:IsA("TextButton") then
          local lastInputType = UserInputService:GetLastInputType()
          local isUsingGamepad = (lastInputType == Enum.UserInputType.Gamepad1 or lastInputType == Enum.UserInputType.Gamepad2 or
            lastInputType == Enum.UserInputType.Gamepad3 or lastInputType == Enum.UserInputType.Gamepad4)

          if isUsingGamepad and not fromTemp then
            GuiService.SelectedCoreObject = frameChildren[i]
            GuiService:AddSelectionParent("PlayerlistGuiSelection", ScrollList)
            UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.ForceHide
            ContextActionService:BindCoreAction("StopAction", noOpFunc, false, Enum.UserInputType.Gamepad1)
            ContextActionService:BindCoreAction("CloseList", closeListFunc, false, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonStart)
          end
          break
        end
      end
    end
  else
    if isUsingGamepad then
      UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.None
    end

    ContextActionService:UnbindCoreAction("CloseList")
    ContextActionService:UnbindCoreAction("StopAction")

    if GuiService.SelectedCoreObject and GuiService.SelectedCoreObject:IsDescendantOf(Container) then
      GuiService.SelectedCoreObject = nil
      GuiService:RemoveSelectionGroup("PlayerlistGuiSelection")
    end
  end
end

Playerlist.ToggleVisibility = function(name, inputState, inputObject)
  if inputState and inputState ~= Enum.UserInputState.Begin then return end
  if IsSmallScreenDevice then return end
  if not playerlistCoreGuiEnabled then return end

  isOpen = not isOpen

  if next(TempHideKeys) == nil then
    setVisible(isOpen)
  end
end

Playerlist.IsOpen = function()
  return isOpen
end

Playerlist.HideTemp = function(self, key, hidden)
  if not playerlistCoreGuiEnabled then return end
  if IsSmallScreenDevice then return end

  TempHideKeys[key] = hidden and true or nil

  if next(TempHideKeys) == nil then
    if isOpen then
      setVisible(true, true)
    end
  else
    if isOpen then
      setVisible(false, true)
    end
  end
end
local topStat = nil
if isTenFootInterface then
  topStat = TenFootInterface:SetupTopStat()
end

--[[ Core Gui Changed events ]]--
-- NOTE: Core script only
local function onCoreGuiChanged(coreGuiType, enabled)
  if coreGuiType == Enum.CoreGuiType.All or coreGuiType == Enum.CoreGuiType.PlayerList then
    -- on console we can always toggle on/off, ignore change
    if isTenFootInterface then
      playerlistCoreGuiEnabled = true
      return
    end

    playerlistCoreGuiEnabled = enabled and topbarEnabled

    -- not visible on small screen devices
    if IsSmallScreenDevice then
      Container.Visible = false
      return
    end

    setVisible(playerlistCoreGuiEnabled and isOpen and next(TempHideKeys) == nil, true)

    if isTenFootInterface and topStat then
      topStat:SetTopStatEnabled(playerlistCoreGuiEnabled)
    end

    if playerlistCoreGuiEnabled then
      ContextActionService:BindCoreAction("RbxPlayerListToggle", Playerlist.ToggleVisibility, false, Enum.KeyCode.Tab)
    else
      ContextActionService:UnbindCoreAction("RbxPlayerListToggle")
    end
  end
end

Playerlist.TopbarEnabledChanged = function(enabled)
  topbarEnabled = enabled
  -- Update coregui to reflect new topbar status
  onCoreGuiChanged(Enum.CoreGuiType.PlayerList, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList))
end

onCoreGuiChanged(Enum.CoreGuiType.PlayerList, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList))
StarterGui.CoreGuiChangedSignal:connect(onCoreGuiChanged)

resizePlayerList()

local blockStatusChanged = function(userId, isBlocked)
  if userId < 0 then return end

  for _,playerEntry in ipairs(PlayerEntries) do
    if playerEntry.Player.UserId == userId then
      playerEntry.Frame.BGFrame.MembershipIcon.Image = getMembershipIcon(playerEntry.Player)
      return
    end
  end
end

blockingUtility:GetBlockedStatusChangedEvent():connect(blockStatusChanged)

return Playerlist
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX507488A58C3E425B99E5339086A367D2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BackpackScript3D</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--BackpackScript3D: VR port of backpack interface using a 3D panel
--written by 0xBAADF00D
local ICON_SIZE = 48
local ICON_SPACING = 52
local PIXELS_PER_STUD = 64

local SLOT_BORDER_SIZE = 0
local SLOT_BORDER_SELECTED_SIZE = 4
local SLOT_BORDER_COLOR = Color3.new(90/255, 142/255, 233/255)
local SLOT_BACKGROUND_COLOR = Color3.new(0.2, 0.2, 0.2)
local SLOT_HOVER_BACKGROUND_COLOR = Color3.new(90/255, 90/255, 90/255)

local HOPPERBIN_ANGLE = math.rad(-45)
local HOPPERBIN_ROTATION = CFrame.Angles(HOPPERBIN_ANGLE, 0, 0)
local HOPPERBIN_OFFSET = Vector3.new(0, 0, -5)

local HEALTHBAR_SPACE = 12
local HEALTHBAR_WIDTH = 82
local HEALTHBAR_HEIGHT = 5

local NAME_SPACE = 14

local Tools = {}
local ToolsList = {}
local slotIcons = {}

local BackpackScript = {}
local topbarEnabled = false

local player = game.Players.LocalPlayer
local currentHumanoid = nil
local CoreGui = game:GetService('CoreGui')
local RobloxGui = CoreGui:WaitForChild("RobloxGui")
local Panel3D = require(RobloxGui.Modules.VR.Panel3D)
local Util = require(RobloxGui.Modules.Settings.Utility)

local ContextActionService = game:GetService("ContextActionService")

local BackpackPanel = Panel3D.Get("Backpack")
BackpackPanel:ResizeStuds(5, 2)
BackpackPanel:SetType(Panel3D.Type.Fixed, { CFrame = CFrame.new(0, 0, -5) })
BackpackPanel:SetVisible(true)

local toolsFrame = Instance.new("TextButton", BackpackPanel:GetGUI()) --prevent clicks falling through in case you have a rocket launcher and blow yourself up
toolsFrame.Text = ""
toolsFrame.Size = UDim2.new(1, 0, 0, ICON_SIZE)
toolsFrame.BackgroundTransparency = 1
toolsFrame.Selectable = false
local insetAdjustY = toolsFrame.AbsolutePosition.Y
toolsFrame.Position = UDim2.new(0, 0, 0, HEALTHBAR_SPACE + NAME_SPACE)

--Healthbar color function stolen from Topbar.lua
local HEALTH_BACKGROUND_COLOR = Color3.new(228/255, 236/255, 246/255)
local HEALTH_RED_COLOR = Color3.new(255/255, 28/255, 0/255)
local HEALTH_YELLOW_COLOR = Color3.new(250/255, 235/255, 0)
local HEALTH_GREEN_COLOR = Color3.new(27/255, 252/255, 107/255)

local healthbarBack = Instance.new("ImageLabel", BackpackPanel:GetGUI())
healthbarBack.ImageColor3 = HEALTH_BACKGROUND_COLOR
healthbarBack.BackgroundTransparency = 1
healthbarBack.ScaleType = Enum.ScaleType.Slice
healthbarBack.SliceCenter = Rect.new(10, 10, 10, 10)
healthbarBack.Name = "HealthbarContainer"
healthbarBack.Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png"
local healthbarFront = Instance.new("ImageLabel", healthbarBack)
healthbarFront.ImageColor3 = HEALTH_GREEN_COLOR
healthbarFront.BackgroundTransparency = 1
healthbarFront.ScaleType = Enum.ScaleType.Slice
healthbarFront.SliceCenter = Rect.new(10, 10, 10, 10)
healthbarFront.Size = UDim2.new(1, 0, 1, 0)
healthbarFront.Position = UDim2.new(0, 0, 0, 0)
healthbarFront.Name = "HealthbarFill"
healthbarFront.Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png"

local playerName = Instance.new("TextLabel", BackpackPanel:GetGUI())
playerName.Name = "PlayerName"
playerName.BackgroundTransparency = 1
playerName.TextColor3 = Color3.new(1, 1, 1)
playerName.Text = player.Name
playerName.Font = Enum.Font.SourceSansBold
playerName.FontSize = Enum.FontSize.Size12
playerName.TextXAlignment = Enum.TextXAlignment.Left
playerName.Size = UDim2.new(1, 0, 0, NAME_SPACE)


BackpackScript.ToolAddedEvent = Instance.new("BindableEvent")


local healthColorToPosition = {
	[Vector3.new(HEALTH_RED_COLOR.r, HEALTH_RED_COLOR.g, HEALTH_RED_COLOR.b)] = 0.1;
	[Vector3.new(HEALTH_YELLOW_COLOR.r, HEALTH_YELLOW_COLOR.g, HEALTH_YELLOW_COLOR.b)] = 0.5;
	[Vector3.new(HEALTH_GREEN_COLOR.r, HEALTH_GREEN_COLOR.g, HEALTH_GREEN_COLOR.b)] = 0.8;
}
local min = 0.1
local minColor = HEALTH_RED_COLOR
local max = 0.8
local maxColor = HEALTH_GREEN_COLOR

local function HealthbarColorTransferFunction(healthPercent)
	if healthPercent < min then
		return minColor
	elseif healthPercent > max then
		return maxColor
	end

	-- Shepard's Interpolation
	local numeratorSum = Vector3.new(0,0,0)
	local denominatorSum = 0
	for colorSampleValue, samplePoint in pairs(healthColorToPosition) do
		local distance = healthPercent - samplePoint
		if distance == 0 then
			-- If we are exactly on an existing sample value then we don't need to interpolate
			return Color3.new(colorSampleValue.x, colorSampleValue.y, colorSampleValue.z)
		else
			local wi = 1 / (distance*distance)
			numeratorSum = numeratorSum + wi * colorSampleValue
			denominatorSum = denominatorSum + wi
		end
	end
	local result = numeratorSum / denominatorSum
	return Color3.new(result.x, result.y, result.z)
end
---

local backpackEnabled = true
local healthbarEnabled = true

local function UpdateLayout()
	local width, height = 100, 100
	local borderSize = (ICON_SPACING - ICON_SIZE) / 2	
	
	local x = borderSize
	local y = 0
	for _, tool in ipairs(ToolsList) do
		local slot = Tools[tool]
		if slot then
			slot.icon.Position = UDim2.new(0, x, 0, y)
			x = x + ICON_SPACING
		end
	end
	
	if #ToolsList == 0 then
		width = HEALTHBAR_WIDTH
		height = HEALTHBAR_SPACE + NAME_SPACE
		BackpackPanel.showCursor = false
	else
		width = #ToolsList * ICON_SPACING
		height = ICON_SIZE + HEALTHBAR_SPACE + NAME_SPACE
		BackpackPanel.showCursor = true
	end
	
	BackpackPanel:ResizePixels(width, height)

	playerName.Position = UDim2.new(0, borderSize, 0, 0)

	healthbarBack.Position = UDim2.new(0, borderSize, 0, NAME_SPACE + (HEALTHBAR_SPACE - HEALTHBAR_HEIGHT) / 2)
	healthbarBack.Size = UDim2.new(0, HEALTHBAR_WIDTH, 0, HEALTHBAR_HEIGHT)
end

local function UpdateHealth(humanoid)
	local percentHealth = humanoid.Health / humanoid.MaxHealth
	if percentHealth ~= percentHealth then
		percentHealth = 1
	end
	healthbarFront.BackgroundColor3 = HealthbarColorTransferFunction(percentHealth)
	healthbarFront.Size = UDim2.new(percentHealth, 0, 1, 0)
end

local function SetTransparency(transparency)
	for i, v in pairs(Tools) do
		v.bg.ImageTransparency = transparency
		v.image.ImageTransparency = transparency
		v.text.TextTransparency = transparency
	end

	playerName.TextTransparency = transparency
	healthbarBack.ImageTransparency = transparency
	healthbarFront.ImageTransparency = transparency
end

local function OnHotbarEquipPrimary(actionName, state, obj)
	if state ~= Enum.UserInputState.Begin then
		return
	end
	for tool, slot in pairs(Tools) do
		if slot.hovered then
			slot.OnClick()
			return
		end
	end
end

local function EnableHotbarInput(enable)
	if not backpackEnabled then
		enable = false
	end
	if not currentHumanoid then
		return
	end
	if enable then
		ContextActionService:BindCoreAction("HotbarEquipPrimary", OnHotbarEquipPrimary, false, Enum.KeyCode.ButtonA, Enum.KeyCode.ButtonR2, Enum.UserInputType.MouseButton1)
	else
		ContextActionService:UnbindCoreAction("HotbarEquipPrimary")
	end
end

local function AddTool(tool)
	if Tools[tool] then
		return
	end

	local slot = {}
	Tools[tool] = slot
	table.insert(ToolsList, tool)

	slot.hovered = false
	slot.tool = tool

	slot.icon = Instance.new("TextButton", toolsFrame)
	slot.icon.Text = ""
	slot.icon.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
	slot.icon.BackgroundColor3 = Color3.new(0, 0, 0)
	slot.icon.Selectable = true
	slot.icon.BackgroundTransparency = 1
	slotIcons[tool] = slot.icon

	slot.bg = Instance.new("ImageLabel", slot.icon)
	slot.bg.Position = UDim2.new(0, -1, 0, -1)
	slot.bg.Size = UDim2.new(1, 2, 1, 2)
	slot.bg.Image = "rbxasset://textures/ui/VR/rectBackground.png"
	slot.bg.ScaleType = Enum.ScaleType.Slice
	slot.bg.SliceCenter = Rect.new(10, 10, 10, 10)
	slot.bg.BackgroundTransparency = 1

	slot.image = Instance.new("ImageLabel", slot.icon)
	slot.image.Position = UDim2.new(0, 1, 0, 1)
	slot.image.Size = UDim2.new(1, -2, 1, -2)
	slot.image.BackgroundTransparency = 1
	slot.image.Selectable = false

	slot.text = Instance.new("TextLabel", slot.icon)
	slot.text.Position = UDim2.new(0, 1, 0, 1)
	slot.text.Size = UDim2.new(1, -2, 1, -2)
	slot.text.BackgroundTransparency = 1
	slot.text.TextColor3 = Color3.new(1, 1, 1)
	slot.text.Font = Enum.Font.SourceSans
	slot.text.FontSize = Enum.FontSize.Size12
	slot.text.ClipsDescendants = true
	slot.text.Selectable = false

	local selectionObject = Util:Create'ImageLabel'
	{
		Name = 'SelectionObject';
		Size = UDim2.new(1,0,1,0);
		BackgroundTransparency = 1;
		Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png";
		ImageTransparency = 0;
		ScaleType = Enum.ScaleType.Slice;
		SliceCenter = Rect.new(12,12,52,52);
		BorderSizePixel = 0;
	}
	slot.icon.SelectionImageObject = selectionObject

	local function updateToolData()
		slot.image.Image = tool.TextureId
		slot.text.Text = tool.TextureId == "" and tool.Name or ""
	end
	updateToolData()

	slot.OnClick = function()
		if not player.Character then return end
		local humanoid = player.Character:FindFirstChild("Humanoid")
		if not humanoid then return end
		
		local inBackpack = tool.Parent == player.Backpack
		humanoid:UnequipTools()
		if inBackpack then
			humanoid:EquipTool(tool)
		end
	end
	
	slot.icon.MouseButton1Click:connect(slot.OnClick)
	slot.OnEnter = function()
		slot.hovered = true
	end
	slot.OnLeave = function()
		slot.hovered = false
	end
--	slot.icon.MouseEnter:connect(slot.OnEnter)
--	slot.icon.MouseLeave:connect(slot.OnLeave)

	tool.Changed:connect(function(prop)
		if prop == "Parent" then
			if tool.Parent == player:FindFirstChild("Backpack") then
				slot.bg.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE) --temporary hold-over until new backpack design comes along (can't use border with this antialiased frame stand-in)
				slot.bg.Position = UDim2.new(0, 0, 0, 0)
			elseif tool.Parent == player.Character then
				slot.bg.Size = UDim2.new(0, ICON_SIZE + 8, 0, ICON_SIZE + 8)
				slot.bg.Position = UDim2.new(0, -4, 0, -4)				
			end
		elseif prop == "TextureId" or prop == "Name" then
			updateToolData()
		end
	end)
	
	UpdateLayout()

	BackpackScript.ToolAddedEvent:Fire(tool)
end

local humanoidChangedEvent = nil
local humanoidAncestryChangedEvent = nil
local function RegisterHumanoid(humanoid)
	currentHumanoid = humanoid
	if humanoidChangedEvent then
		humanoidChangedEvent:disconnect()
		humanoidChangedEvent = nil
	end
	if humanoidAncestryChangedEvent then
		humanoidAncestryChangedEvent:disconnect()
		humanoidAncestryChangedEvent = nil
	end
	if humanoid then
		humanoidChangedEvent = humanoid.HealthChanged:connect(function() UpdateHealth(humanoid) end)
		humanoidAncestryChangedEvent = humanoid.AncestryChanged:connect(function(child, parent) 
			if child == humanoid and parent ~= player.Character then
				RegisterHumanoid(nil)
			end
		end)
		UpdateHealth(humanoid)
	end
end

local function OnChildAdded(child)
	if child:IsA("Tool") or child:IsA("HopperBin") then
		AddTool(child)
	end
	if child:IsA("Humanoid") and child.Parent == player.Character then
		RegisterHumanoid(child)
	end
end

local function RemoveTool(tool)
	if not Tools[tool] then
		return
	end
	Tools[tool].icon:Destroy()
	for i, v in ipairs(ToolsList) do
		if v == tool then
			table.remove(ToolsList, i)
			break
		end
	end
	Tools[tool] = nil
	slotIcons[tool] = nil
	UpdateLayout()
end

local function OnChildRemoved(child)
	if child:IsA("Tool") or child:IsA("HopperBin") then
		if Tools[child] then
			if child.Parent ~= player:FindFirstChild("Backpack") and child.Parent ~= player.Character then
				RemoveTool(child)
			end
		end
	end
end

local function OnCharacterAdded(character)
	local backpack = player:WaitForChild("Backpack")

	for i, v in ipairs(character:GetChildren()) do
		if v:IsA("Humanoid") then
			RegisterHumanoid(v)
			break
		end
	end

	for tool, v in pairs(Tools) do
		RemoveTool(tool)
	end
	Tools = {}
	ToolsList = {}
	
	character.ChildAdded:connect(OnChildAdded)
	character.ChildRemoved:connect(OnChildRemoved)
	
	for i, v in ipairs(backpack:GetChildren()) do
		OnChildAdded(v)
	end
	
	backpack.ChildAdded:connect(OnChildAdded)
	backpack.ChildRemoved:connect(OnChildRemoved)
end

player.CharacterAdded:connect(OnCharacterAdded)
if player.Character then
	spawn(function() OnCharacterAdded(player.Character) end)
end

local function OnHotbarEquip(actionName, state, obj)
	if not backpackEnabled then
		return
	end
	local character = player.Character
	if not character then
		return
	end
	if not currentHumanoid then
		return
	end
	if state ~= Enum.UserInputState.Begin then
		return
	end
	if #ToolsList == 0 then
		return
	end
	local current = 0
	for i, v in pairs(ToolsList) do
		if v.Parent == character then
			current = i
		end
	end
	currentHumanoid:UnequipTools()
	if obj.KeyCode == Enum.KeyCode.ButtonR1 then
		current = current + 1
		if current > #ToolsList then
			current = 1
		end
	else
		current = current - 1
		if current < 1 then
			current = #ToolsList
		end
	end
	currentHumanoid:EquipTool(ToolsList[current])
end

local function OnCoreGuiChanged(coreGuiType, enabled)
	-- Check for enabling/disabling the whole thing
	if coreGuiType == Enum.CoreGuiType.Backpack or coreGuiType == Enum.CoreGuiType.All then
		backpackEnabled = enabled
		UpdateLayout()
		if enabled then
			ContextActionService:BindCoreAction("HotbarEquip2", OnHotbarEquip, false, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1)
			toolsFrame.Parent = BackpackPanel:GetGUI()
		else
			ContextActionService:UnbindCoreAction("HotbarEquip2")
			toolsFrame.Parent = nil
		end
	end

	if coreGuiType == Enum.CoreGuiType.Health or coreGuiType == Enum.CoreGuiType.All then
		healthbarEnabled = enabled
		UpdateLayout()
		if enabled then
			healthbarBack.Parent = BackpackPanel:GetGUI()
		else
			healthbarBack.Parent = nil
		end
	end
end

local StarterGui = game:GetService("StarterGui")
StarterGui.CoreGuiChangedSignal:connect(OnCoreGuiChanged)
OnCoreGuiChanged(Enum.CoreGuiType.Backpack, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Backpack))
OnCoreGuiChanged(Enum.CoreGuiType.Backpack, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.All))

OnCoreGuiChanged(Enum.CoreGuiType.Health, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Health))
OnCoreGuiChanged(Enum.CoreGuiType.Health, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.All))

local panelLocalCF = CFrame.Angles(math.rad(-5), 0, 0) * CFrame.new(0, 1.75, 0) * CFrame.Angles(math.rad(-5), 0, 0)

function BackpackPanel:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay)
	--the backpack panel needs to go in front of the user when they look at it.
	--if they aren't looking, we should be updating self.localCF

	local topbarPanel = Panel3D.Get("Topbar3D")
	local panelOriginCF = topbarPanel.localCF or CFrame.new()
	self.localCF = panelOriginCF * panelLocalCF
end

function BackpackPanel:OnUpdate()
	SetTransparency(self.transparency)

	local hovered, tool = BackpackPanel:FindHoveredGuiElement(slotIcons)
	if hovered and tool then
		local slot = Tools[tool]
		if not slot.hovered then
			slot.OnEnter()
		end
		for i, v in pairs(Tools) do
			if v.hovered and v ~= slot then
				v.OnLeave()
			end
		end
	end
end

function BackpackPanel:OnMouseEnter(x, y)
	EnableHotbarInput(true)
end
function BackpackPanel:OnMouseLeave(x, y)
	EnableHotbarInput(false)
end

local VRHub = require(RobloxGui.Modules.VR.VRHub)
VRHub.ModuleOpened.Event:connect(function(moduleName)
	local module = VRHub:GetModule(moduleName)
	if module.VRIsExclusive then
		BackpackPanel:SetVisible(false)
	end
end)
VRHub.ModuleClosed.Event:connect(function(moduleName)
	BackpackPanel:SetVisible(true)
end)


BackpackPanel:LinkTo("Topbar3D")

return BackpackScript]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF5C6C09B5FDF4D9E96DBC9DB8C0E0C17">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Chat</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	// FileName: Chat.lua
	// Written by: SolarCrane
	// Description: Code for lua side chat on ROBLOX.
]]

--[[ CONSTANTS ]]

-- NOTE: IF YOU WANT TO USE THIS CHAT SCRIPT IN YOUR OWN GAME:
-- 1) COPY THE CONTENTS OF THIS FILE INTO A MODULE
-- 2) CREATE A LOCALSCRIPT AND PARENT IT TO StarterGui
-- 3) IN THE LOCALSCRIPT require() THE CHAT MODULE YOU MADE IN STEP 1
-- 4) CONFIGURE YOUR PLACE ON THE WEBSITE TO USE BUBBLE-CHAT
-- 5) SET THE FOLLOWING TWO VARIABLES TO TRUE
local FORCE_CHAT_GUI = false
local NON_CORESCRIPT_MODE = false
-- 6) (OPTIONAL) PUT THE FOLLOWING LINE IN A SERVER SCRIPT TO MAKE CHAT PERSIST THROUGH RESPAWNING
--  game:GetService('StarterGui').ResetPlayerGuiOnSpawn = false
---------------------------------

local MESSAGES_FADE_OUT_TIME = 30
local MAX_UDIM_SIZE = 2^15 - 1

local CHAT_WINDOW_Y_OFFSET = 2

local PHONE_SCREEN_WIDTH = 640
local TABLET_SCREEN_WIDTH = 1024

local FLOOD_CHECK_MESSAGE_COUNT = 7
local FLOOD_CHECK_MESSAGE_INTERVAL = 15 -- This is in seconds

local VR_CHAT_CLICK_DEBOUNCE = 0.25

local SCROLLBAR_THICKNESS = 7
local CHAT_COLORS =
{
  Color3.new(253/255, 41/255, 67/255), -- BrickColor.new("Bright red").Color,
  Color3.new(1/255, 162/255, 255/255), -- BrickColor.new("Bright blue").Color,
  Color3.new(2/255, 184/255, 87/255), -- BrickColor.new("Earth green").Color,
  BrickColor.new("Bright violet").Color,
  BrickColor.new("Bright orange").Color,
  BrickColor.new("Bright yellow").Color,
  BrickColor.new("Light reddish violet").Color,
  BrickColor.new("Brick yellow").Color,
}

local thisModuleName = "Chat"

local emptySelectionImage = Instance.new("ImageLabel")
emptySelectionImage.ImageTransparency = 1
emptySelectionImage.BackgroundTransparency = 1

--[[ END OF CONSTANTS ]]

--[[ SERVICES ]]
local RunService = game:GetService('RunService')
local CoreGuiService = game:GetService('CoreGui')
local PlayersService = game:GetService('Players')
local DebrisService = game:GetService('Debris')
local GuiService = game:GetService('GuiService')
local InputService = game:GetService('UserInputService')
local StarterGui = game:GetService('StarterGui')
local ContextActionService = game:GetService('ContextActionService')
local Settings = UserSettings()
local GameSettings = Settings.GameSettings
--[[ END OF SERVICES ]]

--[[ Fast Flags ]]--
local playerDropDownEnabledSuccess, playerDropDownEnabledFlagValue = pcall(function() return settings():GetFFlag("PlayerDropDownEnabled") end)
local IsPlayerDropDownEnabled = playerDropDownEnabledSuccess and playerDropDownEnabledFlagValue

local getMoveChatSuccess, moveChatActiveValue = pcall(function() return settings():GetFFlag("SetCoreMoveChat") end)
local allowMoveChat = getMoveChatSuccess and moveChatActiveValue

local getDisableChatBarSuccess, disableChatBarValue = pcall(function() return settings():GetFFlag("SetCoreDisableChatBar") end)
local allowDisableChatBar = getDisableChatBarSuccess and disableChatBarValue

local chatLayoutChangeSuccess,chatLayoutChangeValue = pcall(function() return settings():GetFFlag("ChatLayoutChange") end) -- remember to make a new fflag
local allowChatLayoutChange = chatLayoutChangeSuccess and chatLayoutChangeValue

--[[ SCRIPT VARIABLES ]]
local RobloxGui = CoreGuiService:WaitForChild("RobloxGui")
local VRHub = require(RobloxGui.Modules.VR.VRHub)
local PlayerPermissionsModule = require(RobloxGui.Modules.PlayerPermissionsModule)
local StatsUtils = require(RobloxGui.Modules.Stats.StatsUtils)

-- I am not fond of waiting at the top of the script here...
while PlayersService.LocalPlayer == nil do PlayersService.ChildAdded:wait() end
local Player = PlayersService.LocalPlayer
-- GuiRoot will act as the top-node for parenting GUIs
local GuiRoot = Instance.new('Frame')
GuiRoot.Name = 'GuiRoot';
GuiRoot.Size = UDim2.new(1,0,1,0);
GuiRoot.BackgroundTransparency = 1;



local chatRepositioned = false
local chatBarDisabled = false

local lastSelectedPlayer = nil
local lastSelectedButton = nil

local playerDropDownModule = nil
local playerDropDown = nil
local blockingUtility = nil

local topbarEnabled = true

if not NON_CORESCRIPT_MODE and not InputService.VREnabled then
  playerDropDownModule = require(RobloxGui.Modules:WaitForChild("PlayerDropDown"))
  playerDropDown = playerDropDownModule:CreatePlayerDropDown()
  blockingUtility = playerDropDownModule:CreateBlockingUtility()
end

--[[ END OF SCRIPT VARIABLES ]]

local function GetLuaChatFilteringFlag()
  return true
end

local Util = {}
do
  -- Check if we are running on a touch device
  function Util.IsTouchDevice()
    local touchEnabled = false
    pcall(function() touchEnabled = InputService.TouchEnabled end)
    return touchEnabled
  end

  function Util.IsSmallScreenSize()
    return GuiRoot.AbsoluteSize.X <= PHONE_SCREEN_WIDTH
  end

  function Util.Create(instanceType)
    return function(data)
      local obj = Instance.new(instanceType)
      for k, v in pairs(data) do
        if type(k) == 'number' then
          v.Parent = obj
        else
          obj[k] = v
        end
      end
      return obj
    end
  end

  function Util.Clamp(low, high, input)
    return math.max(low, math.min(high, input))
  end

  function Util.Linear(t, b, c, d)
    if t >= d then return b + c end

    return c*t/d + b
  end

  function Util.EaseOutQuad(t, b, c, d)
    if t >= d then return b + c end

    t = t/d;
    return -c * t*(t-2) + b
  end

  function Util.EaseInOutQuad(t, b, c, d)
    if t >= d then
      return b + c
    end

    t = t / (d/2);
    if (t < 1) then
      return c/2*t*t + b
    end;
    t = t - 1;
    return -c/2 * (t*(t-2) - 1) + b;
  end

    function Util.PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
    local this = {}
    this.StartTime = tick()
    this.EndTime = this.StartTime + duration
    this.Cancelled = false

    local finished = false
    local percentComplete = 0
    spawn(function()
        local now = tick()
        while now < this.EndTime and instance do
          if this.Cancelled then
            return
          end
          instance[prop] = easingFunc(now - this.StartTime, start, final - start, duration)
          percentComplete = Util.Clamp(0, 1, (now - this.StartTime) / duration)
          RunService.RenderStepped:wait()
          now = tick()
        end
        if this.Cancelled == false and instance then
          instance[prop] = final
          finished = true
          percentComplete = 1
          if cbFunc then
            cbFunc()
          end
        end
      end)

    function this:GetPercentComplete()
      return percentComplete
    end

    function this:IsFinished()
      return finished
    end

    function this:Cancel()
      this.Cancelled = true
    end

    return this
  end

  function Util.Signal()
    local sig = {}

    local mSignaler = Instance.new('BindableEvent')

    local mArgData = nil
    local mArgDataCount = nil

    function sig:fire(...)
      mArgData = {...}
      mArgDataCount = select('#', ...)
      mSignaler:Fire()
    end

    function sig:connect(f)
      if not f then error("connect(nil)", 2) end
      return mSignaler.Event:connect(function()
          f(unpack(mArgData, 1, mArgDataCount))
        end)
    end

    function sig:wait()
      mSignaler.Event:wait()
      assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
      return unpack(mArgData, 1, mArgDataCount)
    end

    return sig
  end

  function Util.DisconnectEvent(conn)
    if conn then
      conn:disconnect()
    end
    return nil
  end

  function Util.SetGUIInsetBounds(x, y)
    local success, _ = pcall(function() GuiService:SetGlobalGuiInset(0, x, 0, y) end)
    if not success then
      pcall(function() GuiService:SetGlobalSizeOffsetPixel(-x, -y) end) -- Legacy GUI-offset function
    end
  end

  local baseUrl = game:GetService("ContentProvider").BaseUrl:lower()
  baseUrl = string.gsub(baseUrl,"/m.","/www.") --mobile site does not work for this stuff!
  function Util.GetSecureApiBaseUrl()
    local secureApiUrl = baseUrl
    secureApiUrl = string.gsub(secureApiUrl,"http://","https://")
    secureApiUrl = string.gsub(secureApiUrl,"www","api")
    return secureApiUrl
  end

  function Util.GetPlayerByName(playerName)
    -- O(n), may be faster if I store a reverse hash from the players list; can't trust FindFirstChild in PlayersService because anything can be parented to there.
    local lowerName = string.lower(playerName)
    for _, player in pairs(PlayersService:GetPlayers()) do
      if string.lower(player.Name) == lowerName then
        return player
      end
    end
    return nil -- Found no player
  end

  local function MakeIsInGroup(groupId, requiredRank)
    assert(type(requiredRank) == "nil" or type(requiredRank) == "number", "requiredRank must be a number or nil")

    local inGroupCache = {}
    return function(player)
      if player and player.userId then
        local userId = player.userId

        if inGroupCache[userId] == nil then
          local inGroup = false
          pcall(function() -- Many things can error is the IsInGroup check
              if requiredRank then
                inGroup = player:GetRankInGroup(groupId) > requiredRank
              else
                inGroup = player:IsInGroup(groupId)
              end
            end)
          inGroupCache[userId] = inGroup
        end

        return inGroupCache[userId]
      end

      return false
    end
  end
  Util.IsPlayerAdminAsync = MakeIsInGroup(1200769)
  Util.IsPlayerInternAsync = MakeIsInGroup(2868472, 100)

  local function GetNameValue(pName)
    local value = 0
    for index = 1, #pName do
      local cValue = string.byte(string.sub(pName, index, index))
      local reverseIndex = #pName - index + 1
      if #pName%2 == 1 then
        reverseIndex = reverseIndex - 1
      end
      if reverseIndex%4 >= 2 then
        cValue = -cValue
      end
      value = value + cValue
    end
    return value
  end

  function Util.ComputeChatColor(pName)
    return CHAT_COLORS[(GetNameValue(pName) % #CHAT_COLORS) + 1]
  end

  -- This is a memo-izing function
  local testLabel = Instance.new('TextLabel')
  testLabel.TextWrapped = true;
  testLabel.Position = UDim2.new(1,0,1,0)
  testLabel.Parent = GuiRoot -- Note: We have to parent it to check TextBounds
  -- The TextSizeCache table looks like this Text->Font->sizeBounds->FontSize
  local TextSizeCache = {}
  function Util.GetStringTextBounds(text, font, fontSize, sizeBounds)
    -- If no sizeBounds are specified use some huge number
    sizeBounds = sizeBounds or false
    if not TextSizeCache[text] then
      TextSizeCache[text] = {}
    end
    if not TextSizeCache[text][font] then
      TextSizeCache[text][font] = {}
    end
    if not TextSizeCache[text][font][sizeBounds] then
      TextSizeCache[text][font][sizeBounds] = {}
    end
    if not TextSizeCache[text][font][sizeBounds][fontSize] then
      testLabel.Text = text
      testLabel.Font = font
      testLabel.FontSize = fontSize
      if sizeBounds then
        testLabel.TextWrapped = true;
        testLabel.Size = sizeBounds
      else
        testLabel.TextWrapped = false;
      end
      TextSizeCache[text][font][sizeBounds][fontSize] = testLabel.TextBounds
    end
    return TextSizeCache[text][font][sizeBounds][fontSize]
  end

  local PRINTABLE_CHARS = '[^' .. string.char(32) .. '-' ..  string.char(126) .. ']'
  local WHITESPACE_CHARS = '(' .. string.rep('%s', 7) .. ')%s+'
  function Util.FilterUnprintableCharacters(str)
    if not GetLuaChatFilteringFlag() then
      return str
    end

    local result = str:gsub(PRINTABLE_CHARS, '');
    result = str:gsub(WHITESPACE_CHARS, '%1');
    return result
  end
end

local SelectChatModeEvent = Util.Signal()
local SelectPlayerEvent = Util.Signal()

local function CreateChatMessage()
  local this = {}
  this.FadeRoutines = {}

  function this:GetMessageFontSize(settings)
    return Util.IsSmallScreenSize() and settings.SmallScreenFontSize or settings.FontSize
  end

  function this:OnResize()
    -- Nothing!
  end

  function this:FadeIn()
    local gui = this:GetGui()
    if gui then
      gui.Visible = true
    end
  end

  function this:FadeOut()
    local gui = this:GetGui()
    if gui then
      gui.Visible = false
    end
  end

  function this:GetGui()
    return this.Container
  end

  function this:Destroy()
    if this.Container ~= nil then
      this.Container:Destroy()
      this.Container = nil
    end
    if this.FadeRoutines then
      for _, routine in pairs(this.FadeRoutines) do
        routine:Cancel()
      end
      this.FadeRoutines = {}
    end
  end

  return this
end

local function CreateSystemChatMessage(settings, chattedMessage)
  local this = CreateChatMessage()

  this.Settings = settings
  this.rawChatString = chattedMessage

  function this:OnResize(containerSize)
    if this.Container and this.ChatMessage then

      if InputService.VREnabled then
        this.ChatMessage.Position = UDim2.new(0, 4, 0, 0)
        this.ChatMessage.Size = UDim2.new(1, 0, 1, 0)
      end

      this.Container.Size = UDim2.new(1,0,0,1000)
      local textHeight = this.ChatMessage.TextBounds.Y

      local newContainerHeight = textHeight + 5
      this.Container.Size = UDim2.new(1,0,0,newContainerHeight)
      return newContainerHeight
    end
  end

  function this:FadeIn()
    local gui = this:GetGui()
    if gui then
      gui.Visible = true
      for _, routine in pairs(this.FadeRoutines) do
        routine:Cancel()
      end
      this.FadeRoutines = {}
      local tweenableObjects = {
        this.ChatMessage;
      }
      for _, object in pairs(tweenableObjects) do
        object.TextTransparency = 0;
        object.TextStrokeTransparency = this.Settings.TextStrokeTransparency;
      end

      if this.MessageBackgroundImage then
        this.MessageBackgroundImage.Visible = InputService.VREnabled
      end
    end
  end

  function this:FadeOut(instant)
    local gui = this:GetGui()
    if gui then
      if instant then
        gui.Visible = false
      else
        local tweenableObjects = {
          this.ChatMessage;
        }
        for _, object in pairs(tweenableObjects) do
          table.insert(this.FadeRoutines, Util.PropertyTweener(object, 'TextTransparency', object.TextTransparency, 1, 1, Util.Linear))
          table.insert(this.FadeRoutines, Util.PropertyTweener(object, 'TextStrokeTransparency', object.TextStrokeTransparency, 1, 0.85, Util.Linear))
        end
      end
      if this.MessageBackgroundImage then
        this.MessageBackgroundImage.Visible = false
      end
    end
  end

  local function CreateMessageGuiElement()
    local fontSize = this:GetMessageFontSize(this.Settings)

    local systemMessageDisplayText = this.rawChatString or ""
    local systemMessageSize = Util.GetStringTextBounds(systemMessageDisplayText, this.Settings.Font, fontSize, UDim2.new(0, 400, 0, 1000))

    local container = Util.Create'Frame'
    {
      Name = 'MessageContainer';
      Position = UDim2.new(0, 0, 0, 0);
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 1;
    };
    this.MessageBackgroundImage = Util.Create'ImageLabel'
    {
      Name = 'TextEntryBackground';
      Size = UDim2.new(1,0,1,-2);
      Position = UDim2.new(0,0,0,1);
      Image = 'rbxasset://textures/ui/Chat/VRChatBackground.png';
      ScaleType = Enum.ScaleType.Slice;
      SliceCenter = Rect.new(8,8,56,56);
      BackgroundTransparency = 1;
      ImageTransparency = 0.3;
      BorderSizePixel = 0;
      ZIndex = 1;
      Visible = InputService.VREnabled;
      Parent = container;
    }

    local chatMessage = Util.Create'TextLabel'
    {
      Name = 'SystemChatMessage';
      Position = UDim2.new(0, 0, 0, 0);
      Size = UDim2.new(1, 0, 1, 0);
      Text = systemMessageDisplayText;
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 1;
      TextXAlignment = Enum.TextXAlignment.Left;
      TextYAlignment = Enum.TextYAlignment.Top;
      TextWrapped = true;
      TextColor3 = this.Settings.DefaultMessageTextColor;
      FontSize = fontSize;
      Font = this.Settings.Font;
      TextStrokeColor3 = this.Settings.TextStrokeColor;
      TextStrokeTransparency = this.Settings.TextStrokeTransparency;
      Parent = container;
    };
    if InputService.VREnabled then
      chatMessage.Position = UDim2.new(0, 4, 0, 0)
      chatMessage.Size = UDim2.new(1, 0, 1, 0)
    end

    container.Size = UDim2.new(1, 0, 0, systemMessageSize.Y + 1);
    this.Container = container
    this.ChatMessage = chatMessage
  end

  CreateMessageGuiElement()

  return this
end

--[[ Popup Handling ]]--
function createPopupFrame(selectedPlayer, selectedButton)
  if selectedPlayer and selectedPlayer.Parent == PlayersService then
    if lastSelectedButton ~= selectedButton then
      if lastSelectedButton ~= nil then
        lastSelectedButton.BackgroundTransparency = 1
        lastSelectedButton = nil
      end
      lastSelectedButton = selectedButton
      lastSelectedPlayer = selectedPlayer
      selectedButton.BackgroundTransparency = 0.5

      if IsPlayerDropDownEnabled then
        playerDropDown.HidePopupImmediately = true
        local PopupFrame = playerDropDown:CreatePopup(selectedPlayer)
        PopupFrame.Position = UDim2.new(0, selectedButton.AbsolutePosition.X + selectedButton.AbsoluteSize.X + 2, 0, selectedButton.AbsolutePosition.Y)
        PopupFrame.Size = UDim2.new(0, 150, PopupFrame.Size.Y.Scale, PopupFrame.Size.Y.Offset)
        PopupFrame.ZIndex = 5
        PopupFrame.Parent = GuiRoot
      end

      for _, button in pairs(PopupFrame:GetChildren()) do
        button.BackgroundTransparency = 0
        button.ZIndex = 6
      end
    else
      if IsPlayerDropDownEnabled then
        playerDropDown:Hide()
      end
      lastSelectedPlayer = nil
    end
  end
end

function popupHidden()
  if lastSelectedButton then
    lastSelectedPlayer = nil
    lastSelectedButton.BackgroundTransparency = 1
    lastSelectedButton = nil
  end
end

if IsPlayerDropDownEnabled and playerDropDown then
  playerDropDown.HiddenSignal:connect(popupHidden)
end

InputService.InputBegan:connect(function(inputObject, isProcessed)
    if isProcessed then return end
    local inputType = inputObject.UserInputType
    if ((inputType == Enum.UserInputType.Touch and
        inputObject.UserInputState == Enum.UserInputState.Begin) or
      inputType == Enum.UserInputType.MouseButton1) then
      if lastSelectedButton and IsPlayerDropDownEnabled then
        playerDropDown:Hide()
      end
    end
  end)

--[[ End of popup handling ]]--

local function CreatePlayerChatMessage(settings, playerChatType, sendingPlayer, chattedMessage, receivingPlayer)
  local this = CreateChatMessage()

  this.Settings = settings
  this.PlayerChatType = playerChatType
  this.SendingPlayer = sendingPlayer
  this.RawMessageContent = chattedMessage
  this.ReceivingPlayer = receivingPlayer
  this.ReceivedTime = tick()

  this.Neutral = this.SendingPlayer and this.SendingPlayer.Neutral or true
  this.TeamColor = this.SendingPlayer and this.SendingPlayer.TeamColor or BrickColor.new("White")

  function this:OnResize(containerSize)
    if this.Container and this.ChatMessage then
      this.Container.Size = UDim2.new(1,0,0,1000)
      local textHeight = this.ChatMessage.TextBounds.Y
      local newContainerHeight = textHeight + 5
      this.Container.Size = UDim2.new(1,0,0,newContainerHeight)
      return newContainerHeight
    end
  end

  function this:FormatMessage()
    local result = ""
    if this.RawMessageContent then
      local message = this.RawMessageContent
      result = message
    end
    return result
  end

  function this:FormatChatType()
    if this.PlayerChatType then
      if this.PlayerChatType == Enum.PlayerChatType.All then
        --return "[All]"
      elseif this.PlayerChatType == Enum.PlayerChatType.Team then
        return "[Team]"
      elseif this.PlayerChatType == Enum.PlayerChatType.Whisper then
        -- nothing!
      end
    end
  end

  function this:FormatPlayerNameText()
    local playerName = ""
    -- If we are sending a whisper to someone, then we should show their name
    if this.PlayerChatType == Enum.PlayerChatType.Whisper and this.SendingPlayer and this.SendingPlayer == Player then
      playerName = (this.ReceivingPlayer and this.ReceivingPlayer.Name or "")
    else
      playerName = (this.SendingPlayer and this.SendingPlayer.Name or "")
    end
    return "[" ..  playerName .. "]:"
  end

  function this:FadeIn()
    local gui = this:GetGui()
    if gui then
      gui.Visible = true
      for _, routine in pairs(this.FadeRoutines) do
        routine:Cancel()
      end
      this.FadeRoutines = {}
      local tweenableObjects = {
        this.WhisperToText;
        this.WhisperFromText;
        this.ChatModeButton;
        this.UserNameButton;
        this.ChatMessage;
      }
      for _, object in pairs(tweenableObjects) do
        object.TextTransparency = 0;
        object.TextStrokeTransparency = this.Settings.TextStrokeTransparency;
        object.Active = true
      end
      if this.UserNameDot then
        this.UserNameDot.ImageTransparency = 0
      end

      if this.MessageBackgroundImage then
        this.MessageBackgroundImage.Visible = InputService.VREnabled
      end
    end
  end

  function this:FadeOut(instant)
    local gui = this:GetGui()
    if gui then
      if instant then
        gui.Visible = false
      else
        local tweenableObjects = {
          this.WhisperToText;
          this.WhisperFromText;
          this.ChatModeButton;
          this.UserNameButton;
          this.ChatMessage;
        }
        for _, object in pairs(tweenableObjects) do
          table.insert(this.FadeRoutines, Util.PropertyTweener(object, 'TextTransparency', object.TextTransparency, 1, 1, Util.Linear))
          table.insert(this.FadeRoutines, Util.PropertyTweener(object, 'TextStrokeTransparency', object.TextStrokeTransparency, 1, 0.85, Util.Linear))
          object.Active = false
        end
        if this.UserNameDot then
          table.insert(this.FadeRoutines, Util.PropertyTweener(this.UserNameDot, 'ImageTransparency', this.UserNameDot.ImageTransparency, 1, 1, Util.Linear))
        end
      end
      if this.MessageBackgroundImage then
        this.MessageBackgroundImage.Visible = false
      end
    end
  end

  function this:Destroy()
    if this.Container ~= nil then
      this.Container:Destroy()
      this.Container = nil
    end
    this.ClickedOnModeConn = Util.DisconnectEvent(this.ClickedOnModeConn)
    this.ClickedOnPlayerConn = Util.DisconnectEvent(this.ClickedOnPlayerConn)
    this.RightClickedOnPlayerConn = Util.DisconnectEvent(this.RightClickedOnPlayerConn)
  end

  local function CreateMessageGuiElement()
    local fontSize = this:GetMessageFontSize(this.Settings)

    local toMesasgeDisplayText = "To "
    local toMessageSize = Util.GetStringTextBounds(toMesasgeDisplayText, this.Settings.Font, fontSize)
    local fromMesasgeDisplayText = "From "
    local fromMessageSize = Util.GetStringTextBounds(fromMesasgeDisplayText, this.Settings.Font, fontSize)
    local chatTypeDisplayText = this:FormatChatType()
    local chatTypeSize = chatTypeDisplayText and Util.GetStringTextBounds(chatTypeDisplayText, this.Settings.Font, fontSize) or Vector2.new(0,0)
    local playerNameDisplayText = this:FormatPlayerNameText()
    local playerNameSize = Util.GetStringTextBounds(playerNameDisplayText, this.Settings.Font, fontSize)

    local singleSpaceSize = Util.GetStringTextBounds(" ", this.Settings.Font, fontSize)
    local numNeededSpaces = math.ceil(playerNameSize.X / singleSpaceSize.X) + 1
    local chatMessageDisplayText = string.rep(" ", numNeededSpaces) .. this:FormatMessage()
    local chatMessageSize = Util.GetStringTextBounds(chatMessageDisplayText, this.Settings.Font, fontSize, UDim2.new(0, 400 - 5 - playerNameSize.X, 0, 1000))


    local playerColor = this.Settings.DefaultMessageTextColor
    if this.SendingPlayer then
      if this.PlayerChatType == Enum.PlayerChatType.Whisper then
        if this.SendingPlayer == Player and this.ReceivingPlayer then
          playerColor = Util.ComputeChatColor(this.ReceivingPlayer.Name)
        else
          playerColor = Util.ComputeChatColor(this.SendingPlayer.Name)
        end
      else
        if this.SendingPlayer.Neutral then
          playerColor = Util.ComputeChatColor(this.SendingPlayer.Name)
        else
          playerColor = this.SendingPlayer.TeamColor.Color
        end
      end
    end

    local container = Util.Create'Frame'
    {
      Name = 'MessageContainer';
      Position = UDim2.new(0, 0, 0, 0);
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 1;
    };
    this.MessageBackgroundImage = Util.Create'ImageLabel'
    {
      Name = 'TextEntryBackground';
      Size = UDim2.new(1,0,1,-2);
      Position = UDim2.new(0,0,0,1);
      Image = 'rbxasset://textures/ui/Chat/VRChatBackground.png';
      ScaleType = Enum.ScaleType.Slice;
      SliceCenter = Rect.new(8,8,56,56);
      BackgroundTransparency = 1;
      ImageTransparency = 0.3;
      BorderSizePixel = 0;
      ZIndex = 1;
      Visible = InputService.VREnabled;
      Parent = container;
    }

    local xOffset = InputService.VREnabled and 4 or 0

    if this.SendingPlayer and this.SendingPlayer == Player and this.PlayerChatType == Enum.PlayerChatType.Whisper then
      local whisperToText = Util.Create'TextLabel'
      {
        Name = 'WhisperTo';
        Position = UDim2.new(0, 0, 0, 0);
        Size = UDim2.new(0, toMessageSize.X, 0, toMessageSize.Y);
        Text = toMesasgeDisplayText;
        ZIndex = 1;
        BackgroundColor3 = Color3.new(0, 0, 0);
        BackgroundTransparency = 1;
        TextXAlignment = Enum.TextXAlignment.Left;
        TextYAlignment = Enum.TextYAlignment.Top;
        TextWrapped = true;
        TextColor3 = this.Settings.DefaultMessageTextColor;
        FontSize = fontSize;
        Font = this.Settings.Font;
        TextStrokeColor3 = this.Settings.TextStrokeColor;
        TextStrokeTransparency = this.Settings.TextStrokeTransparency;
        Parent = container;
      };
      xOffset = xOffset + toMessageSize.X
      this.WhisperToText = whisperToText
    elseif this.SendingPlayer and this.SendingPlayer ~= Player and this.PlayerChatType == Enum.PlayerChatType.Whisper then
      local whisperFromText = Util.Create'TextLabel'
      {
        Name = 'WhisperFromText';
        Position = UDim2.new(0, 0, 0, 0);
        Size = UDim2.new(0, fromMessageSize.X, 0, fromMessageSize.Y);
        Text = fromMesasgeDisplayText;
        ZIndex = 1;
        BackgroundColor3 = Color3.new(0, 0, 0);
        BackgroundTransparency = 1;
        TextXAlignment = Enum.TextXAlignment.Left;
        TextYAlignment = Enum.TextYAlignment.Top;
        TextWrapped = true;
        TextColor3 = this.Settings.DefaultMessageTextColor;
        FontSize = fontSize;
        Font = this.Settings.Font;
        TextStrokeColor3 = this.Settings.TextStrokeColor;
        TextStrokeTransparency = this.Settings.TextStrokeTransparency;
        Parent = container;
      };
      xOffset = xOffset + fromMessageSize.X
      this.WhisperFromText = whisperFromText
    end
    if chatTypeDisplayText then
      local chatModeButton = Util.Create(Util.IsTouchDevice() and 'TextLabel' or 'TextButton')
      {
        Name = 'ChatMode';
        BackgroundTransparency = 1;
        ZIndex = 2;
        Text = chatTypeDisplayText;
        TextColor3 = this.Settings.DefaultMessageTextColor;
        Position = UDim2.new(0, xOffset, 0, 0);
        TextXAlignment = Enum.TextXAlignment.Left;
        TextYAlignment = Enum.TextYAlignment.Top;
        FontSize = fontSize;
        Font = this.Settings.Font;
        Size = UDim2.new(0, chatTypeSize.X, 0, chatTypeSize.Y);
        TextStrokeColor3 = this.Settings.TextStrokeColor;
        TextStrokeTransparency = this.Settings.TextStrokeTransparency;
        Parent = container
      }
      if chatModeButton:IsA('TextButton') then
        this.ClickedOnModeConn = chatModeButton.MouseButton1Click:connect(function()
            SelectChatModeEvent:fire(this.PlayerChatType)
          end)
      end
      if this.PlayerChatType == Enum.PlayerChatType.Team then
        chatModeButton.TextColor3 = playerColor
      end
      xOffset = xOffset + chatTypeSize.X + 1
      this.ChatModeButton = chatModeButton
    end
    local userNameButton = Util.Create(Util.IsTouchDevice() and 'TextLabel' or 'TextButton')
    {
      Name = 'PlayerName';
      BackgroundTransparency = 1;
      BackgroundColor3 = Color3.new(0, 1, 1);
      BorderSizePixel = 0;
      ZIndex = 2;
      Text = playerNameDisplayText;
      TextColor3 = playerColor;
      Position = UDim2.new(0, xOffset, 0, 0);
      TextXAlignment = Enum.TextXAlignment.Left;
      TextYAlignment = Enum.TextYAlignment.Top;
      FontSize = fontSize;
      Font = this.Settings.Font;
      Size = UDim2.new(0, playerNameSize.X, 0, playerNameSize.Y);
      TextStrokeColor3 = this.Settings.TextStrokeColor;
      TextStrokeTransparency = this.Settings.TextStrokeTransparency;
      Parent = container
    }
    if userNameButton:IsA('TextButton') then
      this.ClickedOnPlayerConn = userNameButton.MouseButton1Click:connect(function()
          local gui = this:GetGui()
          if gui and gui.Visible then
            if this.PlayerChatType == Enum.PlayerChatType.Whisper and this.SendingPlayer == Player and this.ReceivingPlayer then
              SelectPlayerEvent:fire(this.ReceivingPlayer)
            else
              SelectPlayerEvent:fire(this.SendingPlayer)
            end
          end
        end)
      this.RightClickedOnPlayerConn = userNameButton.MouseButton2Click:connect(function()
          local gui = this:GetGui()
          if gui and gui.Visible then
            if IsPlayerDropDownEnabled and playerDropDown then
              if this.SendingPlayer and this.SendingPlayer ~= Player then
                createPopupFrame(this.SendingPlayer, userNameButton)
              end
            end
          end
        end)
    end

    local chatMessage = Util.Create'TextLabel'
    {
      Name = 'ChatMessage';
      Position = UDim2.new(0, xOffset, 0, 0);
      Size = UDim2.new(1, -xOffset, 1, 0);
      Text = chatMessageDisplayText;
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 1;
      TextXAlignment = Enum.TextXAlignment.Left;
      TextYAlignment = Enum.TextYAlignment.Top;
      TextWrapped = true;
      TextColor3 = this.Settings.DefaultMessageTextColor;
      FontSize = fontSize;
      Font = this.Settings.Font;
      TextStrokeColor3 = this.Settings.TextStrokeColor;
      TextStrokeTransparency = this.Settings.TextStrokeTransparency;
      Parent = container;
    };
    if InputService.VREnabled then
      chatMessage.Size = chatMessage.Size - UDim2.new(0,4,0,0)
    end
    -- Check if they got moderated and put up a real message instead of Label
    if chatMessage.Text == 'Label' and chatMessageDisplayText ~= 'Label' then
      chatMessage.Text = string.rep(" ", numNeededSpaces) .. '[Content Deleted]'
    end
    if this.SendingPlayer then
      if PlayerPermissionsModule.IsPlayerAdminAsync(this.SendingPlayer) then
        chatMessage.TextColor3 = this.Settings.AdminTextColor
      elseif PlayerPermissionsModule.IsPlayerInternAsync(this.SendingPlayer) then
        chatMessage.TextColor3 = this.Settings.InternTextColor
      end
    end
    chatMessage.Size = chatMessage.Size + UDim2.new(0, 0, 0, chatMessage.TextBounds.Y);

    container.Size = UDim2.new(1, 0, 0, math.max(chatMessageSize.Y + 1, userNameButton.Size.Y.Offset + 1));
    this.Container = container
    this.ChatMessage = chatMessage
    this.UserNameButton = userNameButton
  end

  CreateMessageGuiElement()

  return this
end

local function CreateChatBarWidget(settings)
  local this = {}

  -- MessageModes: {All, Team, Whisper}
  this.MessageMode = 'All'
  this.TargetWhisperPlayer = nil
  this.Settings = settings

  this.WidgetVisible = false
  this.FadedIn = true

  this.ChatBarGainedFocusEvent = Util.Signal()
  this.ChatBarLostFocusEvent = Util.Signal()
  this.ChatCommandEvent = Util.Signal() -- Signal Signatue: success, actionType, [captures]
  this.ChatErrorEvent = Util.Signal() -- Signal Signatue: success, actionType, [captures]
  this.ChatBarFloodEvent = Util.Signal()

  this.unfocusedAt = 0

  local chatCoreGuiEnabled = true

  -- This function while lets string.find work case-insensitively without clobbering the case of the captures
  local function nocase(s)
    s = string.gsub(s, "%a", function (c)
        return string.format("[%s%s]", string.lower(c),
          string.upper(c))
      end)
    return s
  end

  this.ChatMatchingRegex =
  {
    [function(chatBarText) return string.find(chatBarText, nocase("^/w ") .. "(%w+_?%w+)") end] = "Whisper";
    [function(chatBarText) return string.find(chatBarText, nocase("^/whisper ") .. "(%w+_?%w+)") end] = "Whisper";

    [function(chatBarText) return string.find(chatBarText, "^%%") end] = "Team";
    [function(chatBarText) return string.find(chatBarText, "^%(TEAM%)") end] = "Team";
    [function(chatBarText) return string.find(chatBarText, nocase("^/t")) end] = "Team";
    [function(chatBarText) return string.find(chatBarText, nocase("^/team")) end] = "Team";

    [function(chatBarText) return string.find(chatBarText, nocase("^/a")) end] = "All";
    [function(chatBarText) return string.find(chatBarText, nocase("^/all")) end] = "All";
    [function(chatBarText) return string.find(chatBarText, nocase("^/s")) end] = "All";
    [function(chatBarText) return string.find(chatBarText, nocase("^/say")) end] = "All";

    [function(chatBarText) return string.find(chatBarText, nocase("^/e")) end] = "Emote";
    [function(chatBarText) return string.find(chatBarText, nocase("^/emote")) end] = "Emote";

    [function(chatBarText) return string.find(chatBarText, "^/%?") end] = "Help";
    [function(chatBarText) return string.find(chatBarText, nocase("^/help")) end] = "Help";

    [function(chatBarText) return string.find(chatBarText, nocase("^/block ") .. "(%w+_?%w+)") end] = "Block";

    [function(chatBarText) return string.find(chatBarText, nocase("^/unblock ") .. "(%w+_?%w+)") end] = "Unblock";

    [function(chatBarText) return string.find(chatBarText, nocase("^/mute ") .. "(%w+_?%w+)") end] = "Mute";

    [function(chatBarText) return string.find(chatBarText, nocase("^/unmute ") .. "(%w+_?%w+)") end] = "Unmute";
  }

  local ChatModesDict =
  {
    ['Whisper'] = 'Whisper';
    ['Team'] = 'Team';
    ['All'] = 'All';
    [Enum.PlayerChatType.Whisper] = 'Whisper';
    [Enum.PlayerChatType.Team] = 'Team';
    [Enum.PlayerChatType.All] = 'All';
  }

  local function TearDownEvents()
    this.ClickToChatButtonConn = Util.DisconnectEvent(this.ClickToChatButtonConn)
    this.ChatBarFocusLostConn = Util.DisconnectEvent(this.ChatBarFocusLostConn)
    this.ChatBarLostFocusConn = Util.DisconnectEvent(this.ChatBarLostFocusConn)
    this.SelectChatModeConn = Util.DisconnectEvent(this.SelectChatModeConn)
    this.SelectPlayerConn = Util.DisconnectEvent(this.SelectPlayerConn)
    this.FocusChatBarInputBeganConn = Util.DisconnectEvent(this.FocusChatBarInputBeganConn)
    this.InputBeganConn = Util.DisconnectEvent(this.InputBeganConn)
    this.ChatBarChangedConn = Util.DisconnectEvent(this.ChatBarChangedConn)
  end

  local function HookUpEvents()
    TearDownEvents() -- Cleanup old events

    if this.ClickToChatButton then this.ClickToChatButtonConn = this.ClickToChatButton.MouseButton1Click:connect(function() this:FocusChatBar() end) end

    if this.ChatBar then
      -- Use a count to check for double backspace out of a chatmode
      local count = 0
      if not Util.IsTouchDevice() then
        this.FocusChatBarInputBeganConn = Util.DisconnectEvent(this.FocusChatBarInputBeganConn)
        this.FocusChatBarInputBeganConn = InputService.InputBegan:connect(function(inputObj)
            if inputObj.KeyCode == Enum.KeyCode.Backspace and this:GetChatBarText() == "" then
              if count == 0 then
                count = count + 1
              else
                this:SetMessageMode('All')
              end
            else
              count = 0
            end
          end)
      end

      this.ChatBarFocusLostConn = this.ChatBar.FocusLost:connect(function(...)
          count = 0
          this.unfocusedAt = tick()
          this.ChatBarLostFocusEvent:fire(...)
        end)
      this.ChatBarChangedConn = this.ChatBar.Changed:connect(function(prop)
          if prop == "Text" then
            this:OnChatBarTextChanged()
          elseif prop == 'TextFits' or prop == 'TextBounds' or prop == 'Visible' then
            this:OnChatBarBoundsChanged()
          end
        end)
    end

    if this.ChatBarLostFocusEvent then this.ChatBarLostFocusConn = this.ChatBarLostFocusEvent:connect(function(...) this:OnChatBarFocusLost(...) end) end

    this.SelectChatModeConn = SelectChatModeEvent:connect(function(chatType)
        this:SetMessageMode(chatType)
        this:FocusChatBar()
      end)

    this.SelectPlayerConn = SelectPlayerEvent:connect(function(chatPlayer)
        this.TargetWhisperPlayer = chatPlayer
        this:SetMessageMode("Whisper")
        this:FocusChatBar()
      end)

    this.InputBeganConn = InputService.InputBegan:connect(function(inputObject)
        if inputObject.KeyCode == Enum.KeyCode.Escape then
          -- Clear text when they press escape
          this:SetChatBarText("")
        end
      end)
  end

  function this:CalculateVisibility()
    if this.ChatBarContainer then
      local enabled = self.WidgetVisible and chatCoreGuiEnabled and not NON_CORESCRIPT_MODE
      if enabled then
        HookUpEvents()
      else
        TearDownEvents()
      end
      this.ChatBarContainer.Visible = enabled and self.FadedIn and (not chatBarDisabled)
    end
  end

  function this:ToggleVisibility(visible)
    if visible ~= self.WidgetVisible then
      self.WidgetVisible = visible
      self:CalculateVisibility()
    end
    if NON_CORESCRIPT_MODE or chatBarDisabled then
      this.ChatBarContainer.Visible = false
    end
  end

  function this:FadeIn()
    self.FadedIn = true
    self:CalculateVisibility()
  end

  function this:FadeOut()
    self.FadedIn = false
    self:CalculateVisibility()
  end

  function this:CoreGuiChanged(coreGuiType, enabled)
    if coreGuiType == Enum.CoreGuiType.Chat or coreGuiType == Enum.CoreGuiType.All then
      chatCoreGuiEnabled = enabled
      self:CalculateVisibility()
    end
  end

  function this:IsAChatMode(mode)
    return ChatModesDict[mode] ~= nil
  end

  function this:ProcessChatBarModes(requireWhitespaceAfterChatMode)
    local matchedAChatCommand = false
    if this.ChatBar then
      local chatBarText = this:SanitizeInput(this:GetChatBarText())
      for regexFunc, actionType in pairs(this.ChatMatchingRegex) do
        local start, finish, capture = regexFunc(chatBarText)
        if start and finish then
          -- The following line is for whether or not to try setting the chatmode as-you-type
          -- versus when you press enter.
          local whitespaceAfterSlashCommand = string.find(string.sub(chatBarText, finish+1, finish+1), "%s")
          if (not requireWhitespaceAfterChatMode and finish == #chatBarText) or whitespaceAfterSlashCommand then
            if this:IsAChatMode(actionType) then
              if actionType == "Whisper" then
                local targetPlayer = capture and Util.GetPlayerByName(capture)
                if targetPlayer then --and targetPlayer ~= Player then
                  this.TargetWhisperPlayer = targetPlayer
                  -- start from two over to eat the space or tab character after the slash command
                  this:SetChatBarText(string.sub(chatBarText, finish + 2))
                  this:SetMessageMode(actionType)
                  this.ChatCommandEvent:fire(true, actionType, capture)
                else
                  -- This is an indirect way of detecting if they used enter to close submit this chat
                  if not requireWhitespaceAfterChatMode then
                    this:SetChatBarText("")
                    this.ChatCommandEvent:fire(false, actionType, capture)
                  end
                end
              else
                -- start from two over to eat the space or tab character after the slash command
                this:SetChatBarText(string.sub(chatBarText, finish + 2))
                this:SetMessageMode(actionType)
                this.ChatCommandEvent:fire(true, actionType, capture)
              end
            elseif actionType == "Emote" then
              -- You can only emote to everyone.
              this:SetMessageMode('All')
            elseif not requireWhitespaceAfterChatMode then -- Some non-chat related command
              if actionType == "Help" then
                this:SetChatBarText("") -- Clear the chat so we don't send /? to everyone
              end
              this.ChatCommandEvent:fire(true, actionType, capture)
            end
            -- should we break here since we already matched a slash command or keep going?
            matchedAChatCommand = true
          end
        end
      end
    end
    return matchedAChatCommand
  end

  local previousText = ""
  function this:OnChatBarTextChanged()
    if not Util.IsTouchDevice() then
      this:ProcessChatBarModes(true)
      local originalText = this:GetChatBarText()
      local newText = Util.FilterUnprintableCharacters(originalText)
      if newText ~= originalText then
        previousText = newText
      end

      local fixedText = newText
      if #newText > this.Settings.MaxCharactersInMessage or originalText ~= newText then
        -- This is a hack to deal with the bug that holding down a key for repeated input doesn't trigger the textChanged event
        if #newText == #previousText + 1 then
          fixedText = string.sub(previousText, 1, this.Settings.MaxCharactersInMessage)
        else
          fixedText = string.sub(newText, 1, this.Settings.MaxCharactersInMessage)
        end
      end
      this:SetChatBarText(fixedText)
      previousText = fixedText
    end
  end

  function this:OnChatBarBoundsChanged()
    if this.ChatBarContainer and this.ChatBar then
      local currSize = this.ChatBarContainer.Size
      if this.ChatBar.Visible and not this.ChatBar.TextFits then
        local textBounds = Util.GetStringTextBounds(this.ChatBar.Text, this.ChatBar.Font, this.ChatBar.FontSize, UDim2.new(0, this.ChatBar.AbsoluteSize.X, 0, 1000))
        if textBounds.Y <= 36 then
          this.ChatBarContainer.Size = UDim2.new(currSize.X.Scale, currSize.X.Offset, currSize.Y.Scale, 58)
        else --if currSize.Y.Offset <= 54 then
          this.ChatBarContainer.Size = UDim2.new(currSize.X.Scale, currSize.X.Offset, currSize.Y.Scale, 76)
        end
      elseif this.ChatBar.Visible == false or this.ChatBar.TextBounds.Y <= 18 then
        if currSize.Y.Offset ~= 40 then
          this.ChatBarContainer.Size = UDim2.new(currSize.X.Scale, currSize.X.Offset, currSize.Y.Scale, 40)
        end
      elseif this.ChatBar.TextBounds.Y <= 36 then
        this.ChatBarContainer.Size = UDim2.new(currSize.X.Scale, currSize.X.Offset, currSize.Y.Scale, 58)
      end
    end
  end

  function this:GetChatBarText()
    return this.ChatBar and this.ChatBar.Text or ""
  end

  function this:SetChatBarText(newText)
    if this.ChatBar and newText ~= this.ChatBar.Text then
      this.ChatBar.Text = newText
    end
  end

  function this:GetMessageMode()
    return this.MessageMode
  end

  function this:SetMessageMode(newMessageMode)
    newMessageMode = ChatModesDict[newMessageMode]

    local chatRecipientText = "[" .. (this.TargetWhisperPlayer and this.TargetWhisperPlayer.Name or "") .. "]"
    if this.MessageMode ~= newMessageMode or (newMessageMode == 'Whisper' and this.ChatModeText and chatRecipientText ~= this.ChatModeText.Text) then
      if this.ChatModeText then
        this.MessageMode = newMessageMode
        if newMessageMode == 'Whisper' then
          local chatRecipientTextBounds = Util.GetStringTextBounds(chatRecipientText, this.ChatModeText.Font, this.ChatModeText.FontSize)

          this.ChatModeText.TextColor3 = this.Settings.WhisperTextColor
          this.ChatModeText.Text = chatRecipientText
          this.ChatModeText.Size = UDim2.new(0, chatRecipientTextBounds.X, 1, 0)
        elseif newMessageMode == 'Team' then
          local chatTeamText = '[Team]'
          local chatTeamTextBounds = Util.GetStringTextBounds(chatTeamText, this.ChatModeText.Font, this.ChatModeText.FontSize)

          this.ChatModeText.TextColor3 = this.Settings.TeamTextColor
          this.ChatModeText.Text = "[Team]"
          this.ChatModeText.Size = UDim2.new(0, chatTeamTextBounds.X, 1, 0)
        else
          this.ChatModeText.Text = ""
          this.ChatModeText.Size = UDim2.new(0, 0, 1, 0)
        end
        if this.ChatBar then
          local offset = this.ChatModeText.Size.X.Offset + this.ChatModeText.Position.X.Offset
          this.ChatBar.Size = UDim2.new(1, -14 - offset, 1, 0)
          this.ChatBar.Position = UDim2.new(0, 7 + offset, 0, 0)
        end
      end
    end
  end

  function this:FocusChatBar()
    if this.ChatBar and not chatBarDisabled then
      this.ChatBar.Visible = true
      this.ChatBar:CaptureFocus()
      if self.ClickToChatButton then
        self.ClickToChatButton.Visible = false
      end
      if this.ChatModeText then
        this.ChatModeText.Visible = true
      end
      if Util.IsTouchDevice() or InputService.VREnabled then
        this:SetMessageMode('All') -- Don't remember message mode on mobile devices or VR
      end
      -- Update chatbar properties when chatbar is focused
      this:OnChatBarBoundsChanged()
      if this.ChatBarContainer then
        if self.ChatBarInnerBackground then
          self.ChatBarInnerBackground.BackgroundTransparency = 0
        end
      end
      this.ChatBarGainedFocusEvent:fire()
    end
  end

  function this:RemoveFocus()
    if self:IsFocused() then
      self.ChatBar:ReleaseFocus()
    end
  end

  function this:IsFocused()
    return self.ChatBar and self.ChatBar == InputService:GetFocusedTextBox()
  end

  function this:WasFocused()
    return (tick() - this.unfocusedAt) < VR_CHAT_CLICK_DEBOUNCE
  end

  function this:SanitizeInput(input)
    local sanitizedInput = input
    -- Chomp the whitespace at the front and end of the string
    -- TODO: maybe only chop off the front space if there are more than a few?
    local _, _, capture = string.find(sanitizedInput, "^%s*(.*)%s*$")
    sanitizedInput = capture or ""

    return sanitizedInput
  end


  local sentMessageTimeQueue = {}
  function this:FloodCheck()
    if not GetLuaChatFilteringFlag() then
      return false
    end

    while sentMessageTimeQueue[1] and tick() - sentMessageTimeQueue[1] > FLOOD_CHECK_MESSAGE_INTERVAL do
      table.remove(sentMessageTimeQueue, 1)
    end
    if #sentMessageTimeQueue > FLOOD_CHECK_MESSAGE_COUNT then
      return true
    end
    return false
  end

  function this:OnChatBarFocusLost(enterPressed)
    if self.ChatBar then
      self.ChatBar.Visible = false
      if enterPressed then
        local didMatchSlashCommand = self:ProcessChatBarModes(false)
        local cText = self:SanitizeInput(self:GetChatBarText())
        if cText ~= "" then
          if self:FloodCheck() then -- and not didMatchSlashCommand then
            self.ChatBarFloodEvent:fire()
          else
            -- For now we will let any slash command go through, NOTE: these will show up in bubble-chat
            --if not didMatchSlashCommand and string.sub(cText,1,1) == "/" then
            --	self.ChatCommandEvent:fire(false, "Unknown", cText)
            --else
            local currentMessageMode = self:GetMessageMode()
            -- {All, Team, Whisper}
            if currentMessageMode == 'Team' then
              if Player and Player.Neutral == true then
                self.ChatErrorEvent:fire("You're not on a team.")
              else
                pcall(function() PlayersService:TeamChat(cText) end)
              end
            elseif currentMessageMode == 'Whisper' then
              if self.TargetWhisperPlayer then
                if self.TargetWhisperPlayer == Player then
                  self.ChatErrorEvent:fire("You cannot send a whisper to yourself.")
                else
                  pcall(function() PlayersService:WhisperChat(cText, self.TargetWhisperPlayer) end)
                end
              else
                self.ChatErrorEvent:fire("Invalid whisper target.")
              end
            elseif currentMessageMode == 'All' then
              pcall(function() PlayersService:Chat(cText) end)
            else
              spawn(function() error("ChatScript: Unknown Message Mode of " .. tostring(currentMessageMode)) end)
            end
            table.insert(sentMessageTimeQueue, tick())
            --end
            self:SetChatBarText("")
          end
        end
      end
    end
    if self.ClickToChatButton then
      self.ClickToChatButton.Visible = true
      -- Fade-back in the text so it doesn't abruptly appear
      -- Normally I would like to cancel the old tween but it is so short that it doesn't matter
      self.ClickToChatButton.TextTransparency = 1
      Util.PropertyTweener(self.ClickToChatButton, 'TextTransparency', 1, 0, 0.25, Util.Linear)
    end
    if self.ChatModeText then
      self.ChatModeText.Visible = false
    end
    if this.ChatBarContainer then
      local currSize = this.ChatBarContainer.Size
      this.ChatBarContainer.Size = UDim2.new(currSize.X.Scale, currSize.X.Offset, currSize.Y.Scale, 32)
      if self.ChatBarInnerBackground then
        self.ChatBarInnerBackground.BackgroundTransparency = 0.5
      end
    end
    this.ChatBarChangedConn = Util.DisconnectEvent(this.ChatBarChangedConn)
    this.FocusChatBarInputBeganConn = Util.DisconnectEvent(this.FocusChatBarInputBeganConn)
  end

  local function CreateChatBar()
    local chatBarContainer = Util.Create'Frame'
    {
      Name = 'ChatBarContainer';
      Position = UDim2.new(0, 0, 1, 0);
      Size = UDim2.new(1, 0, 0, 20);
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 0.25;
      BorderSizePixel = 0;
    };
    chatBarContainer.BackgroundColor3 = Color3.new(31/255, 31/255, 31/255);
    chatBarContainer.BackgroundTransparency = 0.5;
    local chatBarInnerBackground = Util.Create'Frame'
    {
      Name = 'InnerBackground';
      Position = UDim2.new(0, 7, 0, 5);
      Size = UDim2.new(1, -14, 1, -10);
      ZIndex = 1;
      BackgroundColor3 = Color3.new(209/255, 216/255, 221/255);
      BackgroundTransparency = 0.5;
      BorderSizePixel = 0;
    };
    local clickToChatButton = Util.Create'TextButton'
    {
      Name = 'ClickToChat';
      Position = UDim2.new(0,9,0,0);
      Size = UDim2.new(1, -9, 1, 0);
      BackgroundTransparency = 1;
      AutoButtonColor = false;
      ZIndex = 3;
      Text = 'To chat click here or press "/" key';
      TextColor3 = this.Settings.GlobalTextColor;
      TextXAlignment = Enum.TextXAlignment.Left;
      TextYAlignment = Enum.TextYAlignment.Top;
      Font = Enum.Font.SourceSansBold;
      FontSize = Enum.FontSize.Size18;
      Parent = chatBarContainer;
    }
    clickToChatButton.TextWrapped = true;
    clickToChatButton.Position = UDim2.new(0, 7, 0, 0);
    clickToChatButton.Size = UDim2.new(1, -14, 1, 0);
    clickToChatButton.TextYAlignment = Enum.TextYAlignment.Center;
    if Util.IsTouchDevice() then
      clickToChatButton.Text = "Tap here to chat"
    end

    local chatBar = Util.Create'TextBox'
    {
      Name = 'ChatBar';
      Position = UDim2.new(0, 9, 0, 0);
      Size = UDim2.new(1, -9, 1, 0);
      Text = "";
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      Active = false;
      BackgroundTransparency = 1;
      TextXAlignment = Enum.TextXAlignment.Left;
      TextYAlignment = Enum.TextYAlignment.Top;
      TextColor3 = this.Settings.GlobalTextColor;
      Font = Enum.Font.SourceSansBold;
      FontSize = Enum.FontSize.Size18;
      ClearTextOnFocus = false;
      Visible = not Util.IsTouchDevice();
      Parent = chatBarContainer;
      SelectionImageObject = emptySelectionImage;
    }
    chatBar.TextWrapped = true;
    chatBar.Position = UDim2.new(0, 7, 0, 0);
    chatBar.Size = UDim2.new(1, -14, 1, 0);
    chatBar.TextYAlignment = Enum.TextYAlignment.Center;
    chatBar.Visible = false;

    local chatModeText = Util.Create'TextButton'
    {
      Name = 'ChatModeText';
      Position = UDim2.new(0, 9, 0, 0);
      Size = UDim2.new(1, -9, 1, 0);
      AutoButtonColor = false;
      BackgroundTransparency = 1;
      ZIndex = 2;
      Text = '';
      TextColor3 = this.Settings.WhisperTextColor;
      TextXAlignment = Enum.TextXAlignment.Left;
      TextYAlignment = Enum.TextYAlignment.Top;
      Font = Enum.Font.SourceSansBold;
      FontSize = Enum.FontSize.Size18;
      Parent = chatBarContainer;
    }
    chatModeText.Position = UDim2.new(0, 7, 0, 0);
    chatModeText.Size = UDim2.new(1, -14, 1, 0);
    chatModeText.TextYAlignment = Enum.TextYAlignment.Center;
    -- Create grey background for text
    chatBarInnerBackground.Parent = chatBarContainer;
    clickToChatButton.Parent = chatBarInnerBackground;
    chatBar.Parent = chatBarInnerBackground;
    chatModeText.Parent = chatBarInnerBackground;

    this.ChatBarContainer = chatBarContainer
    this.ChatBarInnerBackground = chatBarInnerBackground
    this.ClickToChatButton = clickToChatButton
    this.ChatBar = chatBar
    this.ChatModeText = chatModeText
    this.ChatBarContainer.Parent = GuiRoot

    local function UpdateChatBarContainerLayout(newSize)
      if chatBarContainer then
        local chatbarVisible = this.ChatBar and this.ChatBar.Visible
        local bubbleChatIsOn = not PlayersService.ClassicChat and PlayersService.BubbleChat
        -- Phone
        if newSize.X <= PHONE_SCREEN_WIDTH then
          chatBarContainer.Size = UDim2.new(0.5, 0,0, chatbarVisible and 40 or 32)
          if bubbleChatIsOn then
            chatBarContainer.Position = UDim2.new(0, 0, 0, 2)
          else
            chatBarContainer.Position = UDim2.new(0, 0, 0.5, 2)
          end
          -- Tablet
        elseif newSize.X <= TABLET_SCREEN_WIDTH then
          chatBarContainer.Size = UDim2.new(0.4, 0,0, chatbarVisible and 40 or 32)
          if bubbleChatIsOn then
            chatBarContainer.Position = UDim2.new(0, 0, 0, 2)
          else
            chatBarContainer.Position = UDim2.new(0, 0, 0.3, 2)
          end
          -- Desktop
        else
          chatBarContainer.Size = UDim2.new(0.3, 0,0, chatbarVisible and 40 or 32)
          if bubbleChatIsOn then
            chatBarContainer.Position = UDim2.new(0, 0, 0, 2)
          else
            chatBarContainer.Position = UDim2.new(0,0,0.25, 2)
          end
        end

        if Util.IsTouchDevice() or InputService.VREnabled then
          -- Hide the chatbar on mobile and in VR so they can't see it.
          chatBarContainer.Position = UDim2.new(0,0,1,20);
        end
      end
    end

    GuiRoot.Changed:connect(function(prop)
        if (prop == "AbsoluteSize" and not chatRepositioned) then
          UpdateChatBarContainerLayout(GuiRoot.AbsoluteSize)
        end
      end)
    UpdateChatBarContainerLayout(GuiRoot.AbsoluteSize)
  end


  CreateChatBar()
  return this
end

local function CreateChatWindowWidget(settings)
  local this = {}
  this.Settings = settings
  this.Chats = {}
  this.BackgroundVisible = false
  this.ChatsVisible = false
  this.WidgetVisible = false
  this.NewUnreadMessage = false
  this.MessageCount = 0

  this.MessageCountChanged = Util.Signal()
  this.FadeInSignal = Util.Signal()
  this.FadeOutSignal = Util.Signal()

  this.ChatWindowPagingConn = nil

  local lastMoveTime = tick()
  local lastEnterTime = tick()
  local lastLeaveTime = tick()

  local lastFadeOutTime = 0
  local lastFadeInTime = 0
  local lastChatActivity = 0

  local FadeLock = false

  local chatCoreGuiEnabled = true

  local function PointInChatWindow(pt)
    local point0 = this.ChatContainer.AbsolutePosition
    local point1 = point0 + this.ChatContainer.AbsoluteSize
    -- HACK, this is so the "ChatWindow" includes the chatbar box, TODO: refactor the fadeing code to include the chatbar
    point1 = point1 + Vector2.new(0, 34)
    return (point0.X <= pt.X and
      point1.X >= pt.X and
      point0.Y <= pt.Y and
      point1.Y >= pt.Y)
  end

  function this:IsHovering()
    if this.ChatContainer and this.LastMousePosition and self:CalculateVisibility() then
      return PointInChatWindow(this.LastMousePosition)
    end
    return false
  end

  function this:SetFadeLock(lock)
    FadeLock = lock
  end

  function this:GetFadeLock()
    return FadeLock
  end

  function this:SetCanvasPosition(newCanvasPosition)
    if this.ScrollingFrame then
      local maxSize = Vector2.new(math.max(0, this.ScrollingFrame.CanvasSize.X.Offset - this.ScrollingFrame.AbsoluteWindowSize.X),
        math.max(0, this.ScrollingFrame.CanvasSize.Y.Offset - this.ScrollingFrame.AbsoluteWindowSize.Y))
      this.ScrollingFrame.CanvasPosition = Vector2.new(Util.Clamp(0, maxSize.X, newCanvasPosition.X),
        Util.Clamp(0, maxSize.Y, newCanvasPosition.Y))
    end
  end

  function this:ScrollToBottom()
    if this.ScrollingFrame then
      this:SetCanvasPosition(Vector2.new(this.ScrollingFrame.CanvasPosition.X, this.ScrollingFrame.CanvasSize.Y.Offset))
    end
  end

  function this:FadeIn(duration, lockFade)
    if not FadeLock then
      duration = duration or 0.75
      local backgroundTransparency = InputService.VREnabled and 1 or 0.5
      -- fade in
      if this.BackgroundTweener then
        this.BackgroundTweener:Cancel()
      end
      lastFadeInTime = tick()
      lastChatActivity = tick()
      this.ScrollingFrame.ScrollingEnabled = true
      this.ScrollingFrame.ScrollBarThickness = SCROLLBAR_THICKNESS
      this.BackgroundTweener = Util.PropertyTweener(this.ChatContainer, 'BackgroundTransparency', this.ChatContainer.BackgroundTransparency, backgroundTransparency, duration, Util.Linear)
      this.BackgroundVisible = true
      this:FadeInChats()

      this.ChatWindowPagingConn = Util.DisconnectEvent(this.ChatWindowPagingConn)
      this.ChatWindowPagingConn = InputService.InputBegan:connect(function(inputObject)
          local key = inputObject.KeyCode
          if key == Enum.KeyCode.PageUp then
            this:SetCanvasPosition(this.ScrollingFrame.CanvasPosition - Vector2.new(0, this.ScrollingFrame.AbsoluteWindowSize.Y))
          elseif key == Enum.KeyCode.PageDown then
            this:SetCanvasPosition(this.ScrollingFrame.CanvasPosition + Vector2.new(0, this.ScrollingFrame.AbsoluteWindowSize.Y))
          elseif key == Enum.KeyCode.Home then
            this:SetCanvasPosition(Vector2.new(0, 0))
          elseif key == Enum.KeyCode.End then
            this:ScrollToBottom()
          end
        end)
      if this.FadeInSignal then
        this.FadeInSignal:fire()
      end
    end
  end

  function this:FadeOut(duration, unlockFade)
    if not FadeLock then
      duration = duration or 0.75
      -- fade out
      if this.BackgroundTweener then
        this.BackgroundTweener:Cancel()
      end
      lastFadeOutTime = tick()
      lastChatActivity = tick()
      this.ScrollingFrame.ScrollingEnabled = false
      this.ScrollingFrame.ScrollBarThickness = 0
      this.BackgroundTweener = Util.PropertyTweener(this.ChatContainer, 'BackgroundTransparency', this.ChatContainer.BackgroundTransparency, 1, duration, Util.Linear)
      this.BackgroundVisible = false

      this.ChatWindowPagingConn = Util.DisconnectEvent(this.ChatWindowPagingConn)
      if this.FadeOutSignal then
        this.FadeOutSignal:fire()
      end
    end
  end

  function this:FadeInChats()
    if this.ChatsVisible == true then return end
    this.ChatsVisible = true
    for index, message in pairs(this.Chats) do
      message:FadeIn()
    end
  end

  function this:FadeOutChats()
    if InputService.VREnabled then return end
    if this.ChatsVisible == false then return end
    this.ChatsVisible = false
    if IsPlayerDropDownEnabled and playerDropDown then
      playerDropDown:Hide()
    end
    for index, message in pairs(this.Chats) do
      local messageGui = message:GetGui()
      local instant = false
      if messageGui and this.ScrollingFrame then
        -- If the chat is not in the visible frame then don't waste cpu cycles fading it out
        if (messageGui.AbsolutePosition.Y > (this.ScrollingFrame.AbsolutePosition + this.ScrollingFrame.AbsoluteWindowSize).Y or
          messageGui.AbsolutePosition.Y + messageGui.AbsoluteSize.Y < this.ScrollingFrame.AbsolutePosition.Y) then
          instant = true
        end
      end
      message:FadeOut(instant)
    end
  end

  local ResizeCount = 0
  function this:OnResize()
    ResizeCount = ResizeCount + 1
    local currentResizeCount = ResizeCount
    local isScrolledDown = this:IsScrolledDown()
    -- Unfortunately there is a race condition so we need this wait here.
    wait()
    if this.ScrollingFrame then
      if currentResizeCount ~= ResizeCount then return end
      local scrollingFrameAbsoluteSize = this.ScrollingFrame.AbsoluteWindowSize
      if scrollingFrameAbsoluteSize ~= nil and scrollingFrameAbsoluteSize.X > 0 and scrollingFrameAbsoluteSize.Y > 0 then
        local ySize = 0

        if this.ScrollingFrame then
          for _, message in pairs(this.Chats) do
            local newHeight = message:OnResize(scrollingFrameAbsoluteSize)
            if newHeight then
              local chatMessageElement = message:GetGui()
              if chatMessageElement then
                local chatMessageElementYSize = chatMessageElement.Size.Y.Offset
                chatMessageElement.Position = UDim2.new(0, 0, 0, ySize)
                ySize = ySize + chatMessageElementYSize
              end
            end
          end
        end
        if this.MessageContainer and this.ScrollingFrame then
          this.MessageContainer.Size = UDim2.new(
            this.MessageContainer.Size.X.Scale,
            this.MessageContainer.Size.X.Offset,
            0,
            ySize)
          if not allowChatLayoutChange then
            this.MessageContainer.Position = UDim2.new(0, 0, 1, -this.MessageContainer.Size.Y.Offset)
          end
          this.ScrollingFrame.CanvasSize = UDim2.new(this.ScrollingFrame.CanvasSize.X.Scale, this.ScrollingFrame.CanvasSize.X.Offset, this.ScrollingFrame.CanvasSize.Y.Scale, ySize)
        end
      end
      this:ScrollToBottom()
    end
  end

  function this:FilterMessage(playerChatType, sendingPlayer, chattedMessage, receivingPlayer)
    if chattedMessage and string.sub(chattedMessage, 1, 1) ~= '/' then
      return true
    end
    return false
  end

  function this:PushMessageIntoQueue(chatMessage, silently)
    table.insert(this.Chats, chatMessage)

    local isScrolledDown = this:IsScrolledDown()

    local chatMessageElement = chatMessage:GetGui()

    chatMessageElement.Parent = this.MessageContainer
    local chatMessageHeight = chatMessage:OnResize() or 10
    local ySize = this.MessageContainer.Size.Y.Offset
    local chatMessageElementYSize = UDim2.new(0, 0, 0, chatMessageHeight)

    if not silently then
      this.MessageCount = this.MessageCount + 1
    end

    chatMessageElement.Position = chatMessageElement.Position + UDim2.new(0, 0, 0, ySize)
    this.MessageContainer.Size = this.MessageContainer.Size + chatMessageElementYSize
    this.ScrollingFrame.CanvasSize = this.ScrollingFrame.CanvasSize + chatMessageElementYSize

    if this.Settings.MaxWindowChatMessages < #this.Chats then
      this:RemoveOldestMessage()
    end
    if isScrolledDown then
      this:ScrollToBottom()
    elseif not silently then
      -- Raise unread message alert!
      this.NewUnreadMessage = true
    end

    if silently then
      if this.ChatsVisible == false then
        chatMessage:FadeOut(true)
      end
    else
      this:FadeInChats()
      lastChatActivity = tick()
      this.MessageCountChanged:fire(this.MessageCount)
    end

    -- NOTE: Sort of hacky, but if we are approaching the max 16 bit size
    -- we need to rebase y back to 0 which can be done with the resize function
    if ySize > (MAX_UDIM_SIZE / 2) then
      self:OnResize()
    end
  end

  function this:AddSystemChatMessage(chattedMessage, silently)
    local chatMessage = CreateSystemChatMessage(this.Settings, chattedMessage)
    this:PushMessageIntoQueue(chatMessage, silently)
  end

  local function checkEnum(enumItems, value)
    for _, enum in pairs(enumItems) do
      if enum.Value == value then
        return enum
      end
    end
    return nil
  end

  -- We only need to copy the top level for the settings table
  local function shallowCopy(tableToCopy)
    local newTable = {}
    for key, value in pairs(tableToCopy) do
      newTable[key] = value
    end
    return newTable
  end

  function this:AddDeveloperSystemChatMessage(informationTable)
    local settings = shallowCopy(this.Settings)

    if informationTable["Text"] and type(informationTable["Text"]) == "string" then
      if informationTable["Color"] and pcall(function() Color3.new(informationTable["Color"].r, informationTable["Color"].g, informationTable["Color"].b) end) then
        settings.DefaultMessageTextColor = informationTable["Color"]
      end
      if informationTable["Font"] then
        local success, value = pcall(function() return checkEnum(Enum.Font:GetEnumItems(), informationTable["Font"].Value) end)
        if success and value ~= nil then
          settings.Font = value
        end
      end
      if informationTable["FontSize"] then
        local success, value = pcall(function() return checkEnum(Enum.FontSize:GetEnumItems(), informationTable["FontSize"].Value) end)
        if success and value ~= nil then
          settings.FontSize = value
        end
      end
      local chatMessage = CreateSystemChatMessage(settings, informationTable["Text"])
      this:PushMessageIntoQueue(chatMessage, false)
    end
  end

  function this:AddChatMessage(playerChatType, sendingPlayer, chattedMessage, receivingPlayer, silently)
    local fixedChattedMessage = Util.FilterUnprintableCharacters(chattedMessage)
    if this:FilterMessage(playerChatType, sendingPlayer, fixedChattedMessage, receivingPlayer) then
      local chatMessage = CreatePlayerChatMessage(this.Settings, playerChatType, sendingPlayer, fixedChattedMessage, receivingPlayer)
      this:PushMessageIntoQueue(chatMessage, silently)
    end
  end

  function this:RemoveOldestMessage()
    local oldestChat = this.Chats[1]
    if oldestChat then
      return this:RemoveChatMessage(oldestChat)
    end
  end

  function this:RemoveChatMessage(chatMessage)
    if chatMessage then
      for index, message in pairs(this.Chats) do
        if chatMessage == message then
          local guiObj = chatMessage:GetGui()
          if guiObj then
            local ySize = guiObj.Size.Y.Offset
            this.ScrollingFrame.CanvasSize = this.ScrollingFrame.CanvasSize - UDim2.new(0,0,0,ySize)
            if allowChatLayoutChange then
              this.MessageContainer.Position = this.MessageContainer.Position - UDim2.new(0,0,0,ySize)
            end
            -- Clamp the canvasposition
            this:SetCanvasPosition(this.ScrollingFrame.CanvasPosition)
            guiObj.Parent = nil
          end
          message:Destroy()
          return table.remove(this.Chats, index)
        end
      end
    end
  end

  function this:IsScrolledDown()
    if this.ScrollingFrame then
      local yCanvasSize = this.ScrollingFrame.CanvasSize.Y.Offset
      local yContainerSize = this.ScrollingFrame.AbsoluteWindowSize.Y
      local yScrolledPosition = this.ScrollingFrame.CanvasPosition.Y
      -- Check if the messages are at the bottom
      return yCanvasSize < yContainerSize or
      yCanvasSize - yScrolledPosition <= yContainerSize + 5 -- a little wiggle room
    end
    return false
  end

  function this:GetMessageCount()
    return this.MessageCount
  end

  function this:CalculateVisibility()
    return this.WidgetVisible and ((chatCoreGuiEnabled and PlayersService.ClassicChat) or NON_CORESCRIPT_MODE)
  end

  function this:ToggleVisibility(visible)
    if visible ~= self.WidgetVisible then
      self.WidgetVisible = visible
      if this.ChatContainer then
        this.ChatContainer.Visible = self:CalculateVisibility()
      end
    end
    if NON_CORESCRIPT_MODE then
      this.ChatContainer.Visible = true
    end
  end

  function this:CoreGuiChanged(coreGuiType, enabled)
    if coreGuiType == Enum.CoreGuiType.Chat or coreGuiType == Enum.CoreGuiType.All then
      chatCoreGuiEnabled = enabled
      if this.ChatContainer then
        this.ChatContainer.Visible = self:CalculateVisibility()
      end
    end
  end

  local function CreateChatWindow()
    -- This really shouldn't be a button, but it is currently needed for VR.
    local container = Util.Create 'TextButton'
    {
      Name = 'ChatWindowContainer';
      Size = UDim2.new(0.3, 0, 0.25, 0);
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 1;
      BorderSizePixel = 0;
      SelectionImageObject = emptySelectionImage;
      Active = false;
      Text = ""
    };

    container.BackgroundColor3 = Color3.new(31/255, 31/255, 31/255);
    local scrollingFrame = Util.Create'ScrollingFrame'
    {
      Name = 'ChatWindow';
      Size = UDim2.new(1, -4 - 10, 1, -20);
      CanvasSize = UDim2.new(1, -4 - 10, 0, 0);
      Position = UDim2.new(0, 10, 0, 10);
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 1;
      BottomImage = "rbxasset://textures/ui/scroll-bottom.png";
      MidImage = "rbxasset://textures/ui/scroll-middle.png";
      TopImage = "rbxasset://textures/ui/scroll-top.png";
      ScrollBarThickness = 0;
      BorderSizePixel = 0;
      ScrollingEnabled = false;
      Parent = container;
    };
    local messageContainer = Util.Create'Frame'
    {
      Name = 'MessageContainer';
      Size = UDim2.new(1, -SCROLLBAR_THICKNESS - 1, 0, 0);
      Position = allowChatLayoutChange and UDim2.new(0, 0, 0, 0) or UDim2.new(0, 0, 1, 0);
      ZIndex = 1;
      BackgroundColor3 = Color3.new(0, 0, 0);
      BackgroundTransparency = 1;
      Parent = scrollingFrame
    };

    local function OnChatWindowResize(prop)
      if not allowChatLayoutChange then
        if prop == 'AbsoluteSize' then
          messageContainer.Position = UDim2.new(0, 0, 1, -messageContainer.Size.Y.Offset)
        end
      end
      if prop == 'CanvasPosition' then
        if this.ScrollingFrame then
          if this:IsScrolledDown() then
            this.NewUnreadMessage = false
          end
        end
      end
    end

    container.Changed:connect(function(prop)
        if prop == 'AbsoluteSize' then
          this:OnResize()
        end
      end)

    local function UpdateChatWindowLayout(newSize)
      -- A function to position the chat window in light of various factors
      -- (platform, container window size, presence of performance stats).
      if container == nil then
        return
      end

      -- Account for presence/absence of performance stats buttons.
      local localPlayer = PlayersService.LocalPlayer
      local isPerformanceStatsVisible = (GameSettings.PerformanceStatsVisible and localPlayer ~= nil)
      local yOffset = CHAT_WINDOW_Y_OFFSET
      if isPerformanceStatsVisible then
        yOffset = yOffset + StatsUtils.ButtonHeight
      end
      container.Position = UDim2.new(0, 0, 0, yOffset);

      -- Account for new screen size, if applicable.
      if (newSize == nil) then
        return
      end

      if InputService.VREnabled then
        container.Size = UDim2.new(1,0,1,0)
        -- Phone
      elseif newSize.X <= 640 then
        container.Size = UDim2.new(0.5,0,0.5,0) - container.Position
        -- Tablet
      elseif newSize.X <= 1024 then
        container.Size = UDim2.new(0.4,0,0.3,0) - container.Position
        -- Desktop
      else
        container.Size = UDim2.new(0.3,0,0.25,0) - container.Position
      end
    end

    -- When quick profiler button row visiblity changes, update position of chat window.
    GameSettings.PerformanceStatsVisibleChanged:connect(function()
        if not chatRepositioned then
          UpdateChatWindowLayout(nil)
        end
      end)

    GuiRoot.Changed:connect(function(prop)
        if (prop == "AbsoluteSize" and not chatRepositioned) then
          UpdateChatWindowLayout(GuiRoot.AbsoluteSize)
        end
      end)

    UpdateChatWindowLayout()

    messageContainer.Changed:connect(OnChatWindowResize)
    scrollingFrame.Changed:connect(OnChatWindowResize)

    this.ChatContainer = container
    this.ScrollingFrame = scrollingFrame
    this.MessageContainer = messageContainer
    this.ChatContainer.Parent = GuiRoot


    -- It is important to set this to true in NON_CORESCRIPT_MODE because normally the topbar sets
    -- the chat window to visible
    if NON_CORESCRIPT_MODE then
      this:ToggleVisibility(true)
    end

    --- BACKGROUND FADING CODE ---
    -- This is so we don't accidentally fade out when we are scrolling and mess with the scrollbar.
    local dontFadeOutOnMouseLeave = false

    if Util:IsTouchDevice() then
      local touchCount = 0
      this.InputBeganConn = InputService.InputBegan:connect(function(inputObject)
          if inputObject.UserInputType == Enum.UserInputType.Touch and inputObject.UserInputState == Enum.UserInputState.Begin then
            if PointInChatWindow(Vector2.new(inputObject.Position.X, inputObject.Position.Y)) then
              touchCount = touchCount + 1
              dontFadeOutOnMouseLeave = true
            end
          end
        end)

      this.InputEndedConn = InputService.InputEnded:connect(function(inputObject)
          if inputObject.UserInputType == Enum.UserInputType.Touch and inputObject.UserInputState == Enum.UserInputState.End then
            local endedCount = touchCount
            wait(2)
            if touchCount == endedCount then
              dontFadeOutOnMouseLeave = false
            end
          end
        end)

      spawn(function()
          local now = tick()
          while true do
            wait()
            now = tick()
            if this.BackgroundVisible then
              if not dontFadeOutOnMouseLeave then
                this:FadeOut(0.25)
              end
              -- If background is not visible/in-focus
            elseif this.ChatsVisible and now > lastChatActivity + MESSAGES_FADE_OUT_TIME then
              this:FadeOutChats()
            end
          end
        end)
    else
      this.LastMousePosition = Vector2.new()

      this.MouseEnterFrameConn = this.ChatContainer.MouseEnter:connect(function()
          lastEnterTime = tick()
          if this.BackgroundTweener and not this.BackgroundTweener:IsFinished() and not this.BackgroundVisible then
            this:FadeIn()
          end
        end)

      this.MouseMoveConn = InputService.InputChanged:connect(function(inputObject)
          if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
            lastMoveTime = tick()
            this.LastMousePosition = Vector2.new(inputObject.Position.X, inputObject.Position.Y)
            if this.BackgroundTweener and this.BackgroundTweener:GetPercentComplete() < 0.5 and this.BackgroundVisible then
              if not dontFadeOutOnMouseLeave then
                this:FadeOut()
              end
            end
          end
        end)

      local clickCount = 0
      this.InputBeganConn = InputService.InputBegan:connect(function(inputObject)
          if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and inputObject.UserInputState == Enum.UserInputState.Begin then
            if PointInChatWindow(Vector2.new(inputObject.Position.X, inputObject.Position.Y)) then
              clickCount = clickCount + 1
              dontFadeOutOnMouseLeave = true
            end
          end
        end)

      this.InputEndedConn = InputService.InputEnded:connect(function(inputObject)
          if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and inputObject.UserInputState == Enum.UserInputState.End then
            local nowCount = clickCount
            wait(1.3)
            if nowCount == clickCount then
              dontFadeOutOnMouseLeave = false
            end
          end
        end)

      this.MouseLeaveFrameConn = this.ChatContainer.MouseLeave:connect(function()
          lastLeaveTime = tick()
          if this.BackgroundTweener and not this.BackgroundTweener:IsFinished() and this.BackgroundVisible then
            if not dontFadeOutOnMouseLeave then
              this:FadeOut()
            end
          end
        end)

      spawn(function()
          while true do
            wait()
            local now = tick()
            if this:IsHovering() then
              if now - lastMoveTime > 1.3 and not this.BackgroundVisible then
                this:FadeIn()
              end
            else -- not this:IsHovering()
              if this.BackgroundVisible then
                if not dontFadeOutOnMouseLeave then
                  this:FadeOut(0.25)
                end
                -- If background is not visible/in-focus
              elseif this.ChatsVisible and now > lastChatActivity + MESSAGES_FADE_OUT_TIME then
                this:FadeOutChats()
              end
            end
          end
        end)
    end
    --- END OF BACKGROUND FADING CODE ---
  end

  CreateChatWindow()

  return this
end


local function CreateChat()
  local this = {}

  this.Settings =
  {
    GlobalTextColor = Color3.new(112/255, 110/255, 106/255);
    WhisperTextColor = Color3.new(77/255, 139/255, 255/255);
    TeamTextColor = Color3.new(230/255, 207/255, 0);
    DefaultMessageTextColor = Color3.new(255/255, 255/255, 243/255);
    AdminTextColor = Color3.new(1, 215/255, 0);
    InternTextColor = Color3.new(175/255, 221/255, 1);
    TextStrokeTransparency = 0.75;
    TextStrokeColor = Color3.new(34/255,34/255,34/255);
    Font = Enum.Font.SourceSansBold;
    SmallScreenFontSize = Enum.FontSize.Size14;
    FontSize = Enum.FontSize.Size18;
    MaxWindowChatMessages = 50;
    MaxCharactersInMessage = 140;
  }

  this.CurrentWindowMessageCountChanged = nil
  this.VisibilityStateChanged = Util.Signal()
  this.ChatBarFocusChanged = Util.Signal()
  this.Visible = false

  function this:CoreGuiChanged(coreGuiType, enabled)
    enabled = enabled and (topbarEnabled or InputService.VREnabled)
    if coreGuiType == Enum.CoreGuiType.Chat or coreGuiType == Enum.CoreGuiType.All then
      if enabled then
        pcall(function()
            self.SpecialKeyPressedConn = Util.DisconnectEvent(self.SpecialKeyPressedConn)
            GuiService:AddSpecialKey(Enum.SpecialKey.ChatHotkey)
            self.SpecialKeyPressedConn = GuiService.SpecialKeyPressed:connect(function(key)
                if key == Enum.SpecialKey.ChatHotkey then
                  if self.Visible == false then
                    self:ToggleVisibility()
                  end
                  if self.ChatBarWidget then
                    self.ChatBarWidget:FocusChatBar()
                  end
                end
              end)
          end)
      else
        pcall(function() GuiService:RemoveSpecialKey(Enum.SpecialKey.ChatHotkey) end)
        self.SpecialKeyPressedConn = Util.DisconnectEvent(self.SpecialKeyPressedConn)
      end
      if this.MobileChatButton then
        if enabled == true then
          this.MobileChatButton.Parent = GuiRoot
          -- we need to set it to be visible in-case we missed a lost focus event while chat was turned off.
          this.MobileChatButton.Visible = true
        else
          this.MobileChatButton.Parent = nil
        end
      end
    end
    if this.ChatWindowWidget then
      this.ChatWindowWidget:CoreGuiChanged(coreGuiType, enabled)
    end
    if this.ChatBarWidget then
      this.ChatBarWidget:CoreGuiChanged(coreGuiType, enabled)
    end
  end

  -- This event has 4 callback arguments
  -- Enum.PlayerChatType.{All|Team|Whisper}, chatPlayer, message, targetPlayer
  function this:OnPlayerChatted(playerChatType, sendingPlayer, chattedMessage, receivingPlayer)
    if this.ChatWindowWidget then
      -- Don't add messages from blocked players, don't show message if is a debug command
      local isDebugCommand = false
      pcall(function()
          if not NON_CORESCRIPT_MODE and sendingPlayer == PlayersService.LocalPlayer then
            isDebugCommand = game:GetService("GuiService"):ShowStatsBasedOnInputString(chattedMessage)

            -- allows dev console to be opened on mobile
            -- NOTE: Removed ToggleDevConsole bindable event, so engine no longer handles this
            if string.lower(chattedMessage) == "/console" then
              local devConsoleModule = require(RobloxGui.Modules.DeveloperConsoleModule)
              if devConsoleModule then
                local devConsoleVisible = devConsoleModule:GetVisibility()
                devConsoleModule:SetVisibility(not devConsoleVisible)
              end
            end
          end
        end)
      if not (this:IsPlayerBlocked(sendingPlayer) or this:IsPlayerMuted(sendingPlayer) or isDebugCommand) then
        this.ChatWindowWidget:AddChatMessage(playerChatType, sendingPlayer, chattedMessage, receivingPlayer)
      end
    end
  end

  function this:OnPlayerAdded(newPlayer)
    if newPlayer then
      assert(coroutine.resume(coroutine.create(function() PlayerPermissionsModule.IsPlayerAdminAsync(newPlayer) end)))
    end
    if NON_CORESCRIPT_MODE then
      newPlayer.Chatted:connect(function(msg, recipient)
          this:OnPlayerChatted(Enum.PlayerChatType.All, newPlayer, msg, recipient)
        end)
    else
      this.PlayerChattedConn = Util.DisconnectEvent(this.PlayerChattedConn)
      this.PlayerChattedConn = PlayersService.PlayerChatted:connect(function(...)
          this:OnPlayerChatted(...)
        end)
    end
  end

  function this:IsPlayerBlocked(player)
    if blockingUtility then
      return player and blockingUtility:IsPlayerBlockedByUserId(player.userId)
    else
      return false
    end
  end

  function this:BlockPlayerAsync(playerToBlock)
    if playerToBlock and Player ~= playerToBlock then
      local blockUserId = playerToBlock.userId
      local playerToBlockName = playerToBlock.Name
      if blockUserId > 0 then
        if not this:IsPlayerBlocked(playerToBlock) then
          if blockingUtility then
            blockingUtility:BlockPlayerAsync(playerToBlock)
            this.ChatWindowWidget:AddSystemChatMessage(playerToBlockName .. " is now blocked.")
          end
        else
          this.ChatWindowWidget:AddSystemChatMessage(playerToBlockName .. " is already blocked.")
        end
      else
        this.ChatWindowWidget:AddSystemChatMessage("You cannot block guests.")
      end
    else
      this.ChatWindowWidget:AddSystemChatMessage("You cannot block yourself.")
    end
  end

  function this:UnblockPlayerAsync(playerToUnblock)
    if playerToUnblock then
      local unblockUserId = playerToUnblock.userId
      local playerToUnblockName = playerToUnblock.Name

      if this:IsPlayerBlocked(playerToUnblock) then
        if blockingUtility then
          this.ChatWindowWidget:AddSystemChatMessage(playerToUnblockName .. " is no longer blocked.")
          blockingUtility:UnblockPlayerAsync(playerToUnblock)
        end
      else
        this.ChatWindowWidget:AddSystemChatMessage(playerToUnblockName .. " is not blocked.")
      end
    end
  end

  function this:IsPlayerMuted(player)
    if blockingUtility then
      return player and blockingUtility:IsPlayerMutedByUserId(player.userId)
    else
      return false
    end
  end

  function this:MutePlayer(playerToMute)
    if playerToMute and playerToMute ~= Player then
      if playerToMute.UserId > 0 then
        if not this:IsPlayerMuted(playerToMute) then
          if blockingUtility then
            blockingUtility:MutePlayer(playerToMute)
            this.ChatWindowWidget:AddSystemChatMessage(playerToMute.Name .. " is now muted.")
          end
        else
          this.ChatWindowWidget:AddSystemChatMessage(playerToMute.Name .. " is already muted.")
        end
      else
        this.ChatWindowWidget:AddSystemChatMessage("You cannot mute guests.")
      end
    else
      this.ChatWindowWidget:AddSystemChatMessage("You cannot mute yourself.")
    end
  end

  function this:UnmutePlayer(playerToUnmute)
    if playerToUnmute then
      if this:IsPlayerMuted(playerToUnmute) then
        if blockingUtility then
          blockingUtility:UnmutePlayer(playerToUnmute)
          this.ChatWindowWidget:AddSystemChatMessage(playerToUnmute.Name .. " is no longer muted.")
        end
      else
        this.ChatWindowWidget:AddSystemChatMessage(playerToUnmute.Name .. " is not muted.")
      end
    end
  end

  function this:CreateTouchDeviceChatButton()
    return Util.Create'ImageButton'
    {
      Name = 'TouchDeviceChatButton';
      Size = UDim2.new(0, 128, 0, 32);
      Position = UDim2.new(0, 88, 0, 0);
      BackgroundTransparency = 1.0;
      Image = 'https://www.roblox.com/asset/?id=97078724';
    };
  end

  function this:PrintWelcome()
    if this.ChatWindowWidget then
      if Util.IsTouchDevice() then
        this.ChatWindowWidget:AddSystemChatMessage("Please press the '...' icon to chat", true)
      end
      if not allowChatLayoutChange then
        this.ChatWindowWidget:AddSystemChatMessage("Please chat '/?' for a list of commands", true)
      end
    end
  end

  local doOnceVRWelcome = false
  function this:PrintVRWelcome()
    if this.ChatWindowWidget and not doOnceVRWelcome then
      if InputService.VREnabled then
        this.ChatWindowWidget:AddSystemChatMessage("Press here to chat", true)
        doOnceVRWelcome = true
      end
    end
  end

  function this:PrintHelp()
    if this.ChatWindowWidget then
      this.ChatWindowWidget:AddSystemChatMessage("Help Menu")
      this.ChatWindowWidget:AddSystemChatMessage("Chat Commands:")
      this.ChatWindowWidget:AddSystemChatMessage("/w [PlayerName] or /whisper [PlayerName] - Whisper Chat")
      this.ChatWindowWidget:AddSystemChatMessage("/t or /team - Team Chat")
      this.ChatWindowWidget:AddSystemChatMessage("/a or /all - All Chat")

      this.ChatWindowWidget:AddSystemChatMessage("/block [PlayerName] - Block communications from Target Player")
      this.ChatWindowWidget:AddSystemChatMessage("/unblock [PlayerName] - Restore communications with Target Player")
      this.ChatWindowWidget:AddSystemChatMessage("/mute [PlayerName] - Mute in-game communications from Target Player")
      this.ChatWindowWidget:AddSystemChatMessage("/unmute [PlayerName] - Restore in-game communications with Target Player")
    end
  end

  local focusCount = 0
  function this:CreateGUI()
    if (FORCE_CHAT_GUI or
      (Player.ChatMode == Enum.ChatMode.TextAndMenu or RunService:IsStudio()) and
      game:GetService("UserInputService"):GetPlatform() ~= Enum.Platform.XBoxOne) then
      if NON_CORESCRIPT_MODE then
        local chatGui = Instance.new("ScreenGui")
        chatGui.Name = "RobloxGui"
        chatGui.Parent = Player:WaitForChild('PlayerGui')
        GuiRoot.Parent = chatGui
      end

      -- NOTE: eventually we will make multiple chat window frames
      this.ChatWindowWidget = CreateChatWindowWidget(this.Settings)
      this.ChatBarWidget = CreateChatBarWidget(this.Settings)
      this.CurrentWindowMessageCountChanged = this.ChatWindowWidget.MessageCountChanged

      this.ChatWindowWidget.FadeInSignal:connect(function()
          this.ChatBarWidget:FadeIn()
        end)
      this.ChatWindowWidget.FadeOutSignal:connect(function()
          this.ChatBarWidget:FadeOut()
        end)

      this.ChatWindowWidget:FadeOut(0)
      this.ChatBarWidget.ChatBarGainedFocusEvent:connect(function()
          focusCount = focusCount + 1
          this.ChatWindowWidget:FadeIn(0.25)
          this.ChatWindowWidget:SetFadeLock(true)
          this.ChatBarFocusChanged:fire(true)
        end)
      this.ChatBarWidget.ChatBarLostFocusEvent:connect(function()
          local focusNow = focusCount
          if Util:IsTouchDevice() then
            delay(2, function()
                if focusNow == focusCount then
                  this.ChatWindowWidget:SetFadeLock(false)
                end
              end)
          else
            this.ChatWindowWidget:SetFadeLock(false)
          end
          this.ChatBarFocusChanged:fire(false)
        end)
      this.ChatBarWidget.ChatBarFloodEvent:connect(function()
          if this.ChatWindowWidget then
            this.ChatWindowWidget:AddSystemChatMessage("Wait before sending another message.")
          end
        end)

      this.ChatBarWidget.ChatErrorEvent:connect(function(msg)
          if msg then
            this.ChatWindowWidget:AddSystemChatMessage(msg)
          end
        end)

      this.ChatBarWidget.ChatCommandEvent:connect(function(success, actionType, capture)
          if actionType == "Help" then
            this:PrintHelp()
          elseif actionType == "Block" then
            local blockPlayerName = capture and tostring(capture) or ""
            local playerToBlock = Util.GetPlayerByName(blockPlayerName)
            if playerToBlock then
              spawn(function() this:BlockPlayerAsync(playerToBlock) end)
            else
              this.ChatWindowWidget:AddSystemChatMessage("Cannot block " .. blockPlayerName .. " because they are not in the game.")
            end
          elseif actionType == "Unblock" then
            local unblockPlayerName = capture and tostring(capture) or ""
            local playerToBlock = Util.GetPlayerByName(unblockPlayerName)
            if playerToBlock then
              spawn(function() this:UnblockPlayerAsync(playerToBlock) end)
            else
              this.ChatWindowWidget:AddSystemChatMessage("Cannot unblock " .. unblockPlayerName .. " because they are not in the game.")
            end
          elseif actionType == "Mute" then
            local mutePlayerName = capture and tostring(capture) or ""
            local playerToMute = Util.GetPlayerByName(mutePlayerName)
            if playerToMute then
              this:MutePlayer(playerToMute)
            else
              this.ChatWindowWidget:AddSystemChatMessage("Cannot mute " .. mutePlayerName .. " because they are not in the game.")
            end
          elseif actionType == "Unmute" then
            local unmutePlayerName = capture and tostring(capture) or ""
            local playerToUnmute = Util.GetPlayerByName(unmutePlayerName)
            if playerToUnmute then
              this:UnmutePlayer(playerToUnmute)
            else
              this.ChatWindowWidget:AddSystemChatMessage("Cannot unmute " .. unmutePlayerName .. " because they are not in the game.")
            end
          elseif actionType == "Whisper" then
            if success == false then
              local playerName = capture and tostring(capture) or "Unknown"
              this.ChatWindowWidget:AddSystemChatMessage("Unable to Send a Whisper to Player: " .. playerName)
            end
          elseif actionType == "Unknown" then
            if success == false then
              local commandText = capture and tostring(capture) or "Unknown"
              this.ChatWindowWidget:AddSystemChatMessage("Invalid Slash Command: " .. commandText)
            end
          end
        end)

      if not NON_CORESCRIPT_MODE then
        local function onVREnabled()
          if InputService.VREnabled then
            self.Settings.TextStrokeTransparency = 1
            self:PrintVRWelcome()
            local Panel3D = require(RobloxGui.Modules.VR.Panel3D)

            local panel = Panel3D.Get(thisModuleName)
            panel:LinkTo("Keyboard")
            panel:SetType(Panel3D.Type.Fixed)
            panel:ResizePixels(300, 125)
            GuiRoot.Parent = panel:GetGUI()

            if this.ChatWindowWidget and this.ChatWindowWidget.ChatContainer then
              this.ChatWindowWidget.ChatContainer.MouseButton1Click:connect(function()
                  if this.ChatBarWidget then
                    if this.ChatBarWidget:WasFocused() then
                      this.ChatBarWidget:RemoveFocus()
                    else
                      self:FocusChatBar()
                    end
                  end
                end)
            end

            function panel:CalculateTransparency()
              return 0
            end

            VRHub.ModuleOpened.Event:connect(function(moduleName)
                local module = VRHub:GetModule(moduleName)
                if moduleName ~= thisModuleName and module.VRIsExclusive then
                  this:SetVisible(false)
                end
              end)
          else
            self.Settings.TextStrokeTransparency = 0.75
            GuiRoot.Parent = RobloxGui
          end
        end
        onVREnabled()
        InputService.Changed:connect(function(prop)
            if prop == 'VREnabled' then
              onVREnabled()
            end
          end)
      end
    end
  end

  local toggleCount = 0
  local function SetVisbility(newVisibility)
    this.Visible = newVisibility
    if this.ChatWindowWidget then
      this.ChatWindowWidget:ToggleVisibility(this.Visible)
      if this.Visible then
        toggleCount = toggleCount + 1
        local thisToggle = toggleCount
        local thisFocusCount = focusCount
        this.ChatWindowWidget:FadeIn()
        this.ChatWindowWidget:SetFadeLock(true)
        delay(5, function()
            if thisToggle == toggleCount and thisFocusCount == focusCount then
              this.ChatWindowWidget:SetFadeLock(false)
            end
          end)
      end
    end
    if this.ChatBarWidget then
      this.ChatBarWidget:ToggleVisibility(this.Visible)
      if this.Visible then
        this.ChatBarWidget:FadeIn()
      end
      if InputService.VREnabled and not this.Visible then
        this.ChatBarWidget:RemoveFocus()
      end
    end
    if IsPlayerDropDownEnabled and playerDropDown then
      if not this.Visible then
        playerDropDown:Hide()
      end
    end
    if InputService.VREnabled then
      local Panel3D = require(RobloxGui.Modules.VR.Panel3D)

      local panel = Panel3D.Get(thisModuleName)
      if this.Visible then
        local topbarPanel = Panel3D.Get("Topbar3D")
        panel.localCF = topbarPanel.localCF * CFrame.Angles(math.rad(-5), 0, 0) * CFrame.new(0, 4, 0) * CFrame.Angles(math.rad(-15), 0, 0)
        panel:SetVisible(true)
        panel:ForceShowUntilLookedAt()

        VRHub:FireModuleOpened(thisModuleName)
      else
        panel:SetVisible(this.Visible)

        VRHub:FireModuleClosed(thisModuleName)
      end
    end
    this.VisibilityStateChanged:fire(this.Visible)
  end

  function this:ToggleVisibility()
    SetVisbility(not self.Visible)
  end

  function this:SetVisible(visible)
    SetVisbility(visible)
  end

  function this:FocusChatBar()
    if self.ChatBarWidget and this.Visible then
      self.ChatBarWidget:FocusChatBar()
    end
  end

  function this:IsFocused(useWasFocused)
    if not self.ChatBarWidget then return false end
    return self.ChatBarWidget:IsFocused() or (useWasFocused and self.ChatBarWidget:WasFocused())
  end

  function this:GetCurrentWindowMessageCount()
    if this.ChatWindowWidget then
      return this.ChatWindowWidget:GetMessageCount()
    end
    return 0
  end

  function this:TopbarEnabledChanged(enabled)
    topbarEnabled = enabled
    -- Update coregui to reflect new topbar status
    self:CoreGuiChanged(Enum.CoreGuiType.Chat, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Chat))
  end

  function this:Initialize()
    --[[ Developer Customization API ]]--
    if not NON_CORESCRIPT_MODE then
      game:WaitForChild("StarterGui"):RegisterSetCore("ChatMakeSystemMessage", 	function(informationTable)
          if this.ChatWindowWidget then
            this.ChatWindowWidget:AddDeveloperSystemChatMessage(informationTable)
          end
        end)
      local function isUDim2Value(value)
        local success, value = pcall(function() return UDim2.new(value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset) end)
        return success and value or nil
      end

      local function isBubbleChatOn()
        return not PlayersService.ClassicChat and PlayersService.BubbleChat
      end

      if allowMoveChat then
        game.StarterGui:RegisterSetCore("ChatWindowPosition", 	function(value)
            if this.ChatWindowWidget and this.ChatBarWidget then
              value = isUDim2Value(value)
              if value ~= nil and not isBubbleChatOn() then
                chatRepositioned = true -- Prevent chat from moving back to the original position on screen resolution change
                this.ChatWindowWidget.ChatContainer.Position = value
                this.ChatBarWidget.ChatBarContainer.Position = value + UDim2.new(0, 0, this.ChatWindowWidget.ChatContainer.Size.Y.Scale, this.ChatWindowWidget.ChatContainer.Size.Y.Offset + 2)
              end
            end
          end)

        game.StarterGui:RegisterSetCore("ChatWindowSize", 	function(value)
            if this.ChatWindowWidget and this.ChatBarWidget then
              value = isUDim2Value(value)
              if value ~= nil and not isBubbleChatOn() then
                chatRepositioned = true
                this.ChatWindowWidget.ChatContainer.Size = value
                this.ChatBarWidget.ChatBarContainer.Size = UDim2.new(this.ChatWindowWidget.ChatContainer.Size.X.Scale, this.ChatWindowWidget.ChatContainer.Size.X.Offset, this.ChatBarWidget.ChatBarContainer.Size.Y.Scale, this.ChatBarWidget.ChatBarContainer.Size.Y.Offset)
                this.ChatBarWidget.ChatBarContainer.Position = this.ChatWindowWidget.ChatContainer.Position + UDim2.new(0, 0, this.ChatWindowWidget.ChatContainer.Size.Y.Scale, this.ChatWindowWidget.ChatContainer.Size.Y.Offset + 2)
              end
            end
          end)

      else
        game.StarterGui:RegisterSetCore("ChatWindowPosition", 	function() end)
        game.StarterGui:RegisterSetCore("ChatWindowSize",		function() end)
      end

      game.StarterGui:RegisterGetCore("ChatWindowPosition", 	function()
          if this.ChatWindowWidget then
            return this.ChatWindowWidget.ChatContainer.Position
          else
            return nil
          end
        end)

      game.StarterGui:RegisterGetCore("ChatWindowSize", 	function()
          if this.ChatWindowWidget then
            return this.ChatWindowWidget.ChatContainer.Size
          else
            return nil
          end
        end)

      if allowDisableChatBar then
        game.StarterGui:RegisterSetCore("ChatBarDisabled", 	function(value)
            if this.ChatBarWidget then
              if type(value) == "boolean" then
                chatBarDisabled = value
                if value == true then
                  this.ChatBarWidget:ToggleVisibility(false)
                end
              end
            end
          end)
      else
        game.StarterGui:RegisterSetCore("ChatBarDisabled", 	function() end)
      end

      game.StarterGui:RegisterGetCore("ChatBarDisabled", function() return chatBarDisabled end)
    end

    this:OnPlayerAdded(Player)
    -- Upsettingly, it seems everytime a player is added, you have to redo the connection
    -- NOTE: PlayerAdded only fires on the server, hence ChildAdded is used here
    PlayersService.ChildAdded:connect(function(child)
        if child:IsA('Player') then
          this:OnPlayerAdded(child)
        end
      end)
    this:CreateGUI()


    this:CoreGuiChanged(Enum.CoreGuiType.Chat, StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Chat))
    this.CoreGuiChangedConn = Util.DisconnectEvent(this.CoreGuiChangedConn)
    pcall(function()
        this.CoreGuiChangedConn = StarterGui.CoreGuiChangedSignal:connect(
          function(coreGuiType,enabled)
            this:CoreGuiChanged(coreGuiType, enabled)
          end)
      end)

    if not NON_CORESCRIPT_MODE then
      this:PrintWelcome()
    end

    --SetVisbility(true)
  end

  return this
end

local moduleApiTable = {}
-- Main Entry Point
do
  moduleApiTable.ModuleName = thisModuleName
  moduleApiTable.KeepVRTopbarOpen = true
  moduleApiTable.VRIsExclusive = true
  moduleApiTable.VRClosesNonExclusive = false
  VRHub:RegisterModule(moduleApiTable)

  VRHub.ModuleOpened.Event:connect(function(moduleName)
      if moduleName ~= thisModuleName then
        local module = VRHub:GetModule(moduleName)
        if module.VRIsExclusive then
          moduleApiTable:SetVisible(false)
        end
      end
    end)

  local ChatInstance = CreateChat()
  ChatInstance:Initialize()

  function moduleApiTable:ToggleVisibility()
    ChatInstance:ToggleVisibility()
  end

  function moduleApiTable:SetVisible(visible)
    ChatInstance:SetVisible(visible)
  end

  function moduleApiTable:FocusChatBar()
    ChatInstance:FocusChatBar()
  end

  function moduleApiTable:GetVisibility()
    return ChatInstance.Visible
  end

  function moduleApiTable:GetMessageCount()
    return ChatInstance:GetCurrentWindowMessageCount()
  end

  function moduleApiTable:TopbarEnabledChanged(...)
    return ChatInstance:TopbarEnabledChanged(...)
  end

  function moduleApiTable:IsFocused(useWasFocused)
    return ChatInstance:IsFocused(useWasFocused)
  end

  moduleApiTable.ChatBarFocusChanged = ChatInstance.ChatBarFocusChanged
  moduleApiTable.VisibilityStateChanged = ChatInstance.VisibilityStateChanged
  moduleApiTable.MessagesChanged = ChatInstance.CurrentWindowMessageCountChanged

end

return moduleApiTable
]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX4B620EC74FFD46DCBA14A6321E631E55">
			<Properties>
				<string name="Name">Sounds</string>
			</Properties>
		</Item>
		<Item class="Frame" referent="RBXC9D72C5C5A9A4E21B3BA54E1F3895B7B">
			<Properties>
				<bool name="Active">false</bool>
				<Vector2 name="AnchorPoint">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<Color3 name="BackgroundColor3">4278190080</Color3>
				<float name="BackgroundTransparency">1</float>
				<Color3 name="BorderColor3">4279970357</Color3>
				<int name="BorderSizePixel">0</int>
				<bool name="ClipsDescendants">false</bool>
				<bool name="Draggable">false</bool>
				<string name="Name">PurchaseDialog</string>
				<Ref name="NextSelectionDown">null</Ref>
				<Ref name="NextSelectionLeft">null</Ref>
				<Ref name="NextSelectionRight">null</Ref>
				<Ref name="NextSelectionUp">null</Ref>
				<UDim2 name="Position">
					<XS>0.5</XS>
					<XO>-162</XO>
					<YS>0</YS>
					<YO>-181</YO>
				</UDim2>
				<float name="Rotation">0</float>
				<bool name="Selectable">false</bool>
				<Ref name="SelectionImageObject">null</Ref>
				<UDim2 name="Size">
					<XS>0</XS>
					<XO>324</XO>
					<YS>0</YS>
					<YO>180</YO>
				</UDim2>
				<token name="SizeConstraint">0</token>
				<token name="Style">0</token>
				<bool name="Visible">false</bool>
				<int name="ZIndex">8</int>
			</Properties>
			<Item class="Frame" referent="RBX42150DC827544013BF15F64B0CAC5CFD">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4278190080</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ContainerFrame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">8</int>
				</Properties>
				<Item class="ImageLabel" referent="RBXFAC510CD67F543F8B88A1D53C346003B">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/Modal.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<string name="Name">ContainerImage</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>324</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX0DDE848B7FBC42CBB78D52E84459DECC">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><null></null></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<string name="Name">ItemPreviewImage</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>27</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>64</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX2D9B0389D06245A49C4886EE4712EA45">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">3</token>
						<token name="FontSize">6</token>
						<string name="Name">ItemDescriptionText</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>110</XO>
							<YS>0</YS>
							<YO>18</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>210</XO>
							<YS>0</YS>
							<YO>96</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"><![CDATA[Want to buy the assetType
itemName for]]></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">18</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX74289E84CF73445098EC396DAB59C039">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/RobuxIcon.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<string name="Name">RobuxIcon</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>20</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<bool name="Visible">false</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBXF05F35F9405D485BB2A38809370659D5">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/TixIcon.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<string name="Name">TixIcon</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>20</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<bool name="Visible">false</bool>
						<int name="ZIndex">9</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX21D4AEA550604040A4E41E2B8D26FC58">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">6</token>
						<string name="Name">CostText</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">18</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX3FB7BBEDF55F4C3FB3A39B8E933F7EF8">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">3</token>
						<token name="FontSize">5</token>
						<string name="Name">PostBalanceText</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>100</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>-20</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX7749801C3E1341AA9A3BC948D6304105">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/ButtonLeft.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">true</bool>
						<string name="Name">BuyButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>162</XO>
							<YS>0</YS>
							<YO>44</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextLabel" referent="RBXA47C1D5C822146BE8A975C2AF05B6839">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<string name="Name">BuyButtonText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Buy Now</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX4CB1DA96529D48D595DBA4311623DA69">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/AButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">ImageLabel</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-8</XO>
								<YS>1</YS>
								<YO>-8</YO>
							</UDim2>
							<token name="SizeConstraint">2</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBXC6036295BBC448DD8AD2212B81E39B51">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/ButtonRight.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">true</bool>
						<string name="Name">CancelButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>162</XO>
							<YS>0</YS>
							<YO>44</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextLabel" referent="RBX450692BA49074F7F863EFF3C15375261">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">7</token>
							<string name="Name">CancelButtonText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Cancel</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBXE5CF59C557D84E329B63A2C7F9781C44">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/BButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">ImageLabel</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-8</XO>
								<YS>1</YS>
								<YO>-8</YO>
							</UDim2>
							<token name="SizeConstraint">2</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBXE0FB7333C2DD4ACCB40FDD9B4AC9654A">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/ButtonLeft.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">true</bool>
						<string name="Name">BuyRobuxButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>162</XO>
							<YS>0</YS>
							<YO>44</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextLabel" referent="RBXC2759633A08540B9BFE9A016AA53C5FA">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<string name="Name">BuyRobuxButtonText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Buy R$</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX151651F21BDD4FA7A64A07DCCA9E3F54">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/AButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">ImageLabel</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-8</XO>
								<YS>1</YS>
								<YO>-8</YO>
							</UDim2>
							<token name="SizeConstraint">2</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBXBBD9FC39B2B740D58CBA080BC83EF96D">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/ButtonLeft.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">true</bool>
						<string name="Name">BuyBCButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>162</XO>
							<YS>0</YS>
							<YO>44</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextLabel" referent="RBX7245D0C217114DAEB76FA04077D313FE">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<string name="Name">BuyBCButtonText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Upgrade</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX099882D9CC614E48BA5470F08E896827">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/AButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">ImageLabel</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-8</XO>
								<YS>1</YS>
								<YO>-8</YO>
							</UDim2>
							<token name="SizeConstraint">2</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBX6920120ACBFF48C4A2BDFA0C9CF39FBF">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/ButtonLeft.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">true</bool>
						<string name="Name">FreeButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>162</XO>
							<YS>0</YS>
							<YO>44</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextLabel" referent="RBXD1FE948AF3E1421DA809C8F306A31188">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<string name="Name">FreeButtonText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Take Free</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBX84BFA249E26840E283E0A0595DD692F8">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/SingleButton.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">true</bool>
						<string name="Name">OkButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>2</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>320</XO>
							<YS>0</YS>
							<YO>44</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextLabel" referent="RBXDA36CFF4EAE74A8FB76DD9A8272B71DF">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">7</token>
							<string name="Name">OkButtonText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">OK</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX21B2E35BE41D4E3A89ADE2F0A6D53921">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/AButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">ImageLabel</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-8</XO>
								<YS>1</YS>
								<YO>-8</YO>
							</UDim2>
							<token name="SizeConstraint">2</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBX984C216F0A50451AA4842F68F6C74190">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/ui/SingleButton.png</url></Content>
						<Color3 name="ImageColor3">4294967295</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<bool name="Modal">true</bool>
						<string name="Name">OkPurchasedButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>2</XO>
							<YS>0</YS>
							<YO>136</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>320</XO>
							<YS>0</YS>
							<YO>44</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<token name="Style">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">8</int>
					</Properties>
					<Item class="TextLabel" referent="RBXFC1C344DFD7E4F7E861BA8CE4C36CBD6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">7</token>
							<string name="Name">OkPurchasedButtonText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">OK</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX06C5B54FA846478BAA17E20C54A57CB7">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/AButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">ImageLabel</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-8</XO>
								<YS>1</YS>
								<YO>-8</YO>
							</UDim2>
							<token name="SizeConstraint">2</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">false</bool>
							<int name="ZIndex">8</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ImageLabel" referent="RBX93FAB74BF25C465088B022210959827B">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<Content name="Image"><url>rbxasset://textures/ui/LoadingBKG.png</url></Content>
					<Color3 name="ImageColor3">4294967295</Color3>
					<Vector2 name="ImageRectOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector2 name="ImageRectSize">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<float name="ImageTransparency">0</float>
					<string name="Name">PurchaseFrame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<token name="ScaleType">0</token>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<Rect2D name="SliceCenter">
						<min>
							<X>0</X>
							<Y>0</Y>
						</min>
						<max>
							<X>0</X>
							<Y>0</Y>
						</max>
					</Rect2D>
					<bool name="Visible">false</bool>
					<int name="ZIndex">8</int>
				</Properties>
				<Item class="TextLabel" referent="RBXA8F6121CB8F14F129A1261FC03A16DD6">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">3</token>
						<token name="FontSize">8</token>
						<string name="Name">PurchaseText</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>-36</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Purchasing</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">36</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBXD8698540EC0B43F08CC8EF7E5C68C21E">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4286874756</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Loading</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-40</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>16</XO>
							<YS>0</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX53B4CD9F1F264AF69E7AF18C7AB984DE">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4286874756</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Loading</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-8</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>16</XO>
							<YS>0</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX711304A9965A45BB8BF895B812D39DA5">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4286874756</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Loading</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>24</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>16</XO>
							<YS>0</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">8</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Frame" referent="RBX49FA2BC5ADAA485798A42C6303D33930">
			<Properties>
				<bool name="Active">false</bool>
				<Vector2 name="AnchorPoint">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<Color3 name="BackgroundColor3">4278190080</Color3>
				<float name="BackgroundTransparency">1</float>
				<Color3 name="BorderColor3">4278190080</Color3>
				<int name="BorderSizePixel">0</int>
				<bool name="ClipsDescendants">false</bool>
				<bool name="Draggable">false</bool>
				<string name="Name">Backpack</string>
				<Ref name="NextSelectionDown">null</Ref>
				<Ref name="NextSelectionLeft">null</Ref>
				<Ref name="NextSelectionRight">null</Ref>
				<Ref name="NextSelectionUp">null</Ref>
				<UDim2 name="Position">
					<XS>0</XS>
					<XO>0</XO>
					<YS>0</YS>
					<YO>0</YO>
				</UDim2>
				<float name="Rotation">0</float>
				<bool name="Selectable">false</bool>
				<Ref name="SelectionImageObject">null</Ref>
				<UDim2 name="Size">
					<XS>1</XS>
					<XO>0</XO>
					<YS>1</YS>
					<YO>0</YO>
				</UDim2>
				<token name="SizeConstraint">0</token>
				<token name="Style">0</token>
				<bool name="Visible">false</bool>
				<int name="ZIndex">1</int>
			</Properties>
			<Item class="Frame" referent="RBX33A76A751F404AC99FD9CF1096CC1735">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4278190080</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4278190080</Color3>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">Hotbar</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-328</XO>
						<YS>1</YS>
						<YO>-70</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>655</XO>
						<YS>0</YS>
						<YO>70</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextButton" referent="RBX3A3DAF6D922A4A3485ECB6333962DACD">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">1</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>5</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBXDDE08F87ADB24610ACF281FF411CC597">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBXF02CE8B1D2264F9BA829E1D18EFB15E6">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBXA0BDF9919DDB42A98513122BBC9E4674">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX58D65A6232114EF494879246B447C720">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXBF3CD81EB3A444ACAAF58822D2C17E7F">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXD8DA1490935F439F803C3F6DEFC9E6D6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">1</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX47C5996FA11C4688BE6EAFE62FE04FD6">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">2</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>70</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBXD357287CFA55442BB4C73E931DDB4229">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX1D2B201384AF448A8709E7FEC845A937">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBX1C9FDA09089040C09AE1A21B07D97D4B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXC7305BD4AC4B47E6BB14ADB58EA09AF4">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXA87E49573A37473CACFE20A730014177">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXC48FAC82EF3D4FBCA30F04B22DDD2EBC">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">2</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX5A49B340DAD6433CB24DFDCAA80EF72D">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">3</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>135</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX0D17ACBD181643DC87E2A6817D7AD7E0">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX11010619226D420EA83D3A1D58AC26B3">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBXEFE21B69A8944177A7CC3017E78709E9">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXF1EC59112A344DF2BBC7CA75E3BE2161">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX63C569BA1A63493B932AB0B06F6788EC">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX3A8C93C797924E199A7A5AB65CCE66AD">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">3</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX4096C28E5AEA40408ABA81B68658394F">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">4</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX4EF1ABB4F96F451093C716D61B123CFA">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBXD32B3BCD82A24EAE885032A838737E48">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBXB91267CE2A714BCF87F16983B526C5E6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXDC2274AA37D54AA8AC5155236E6FB35C">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX5755CAC17BF1421194F9A170054763AF">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX5B2BDAF04D474DEC9C18000775D7B6E9">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">4</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX06E875AFA7E846A3920FCC73A5E8DC62">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">5</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>265</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBXFBE9A79229E44A8DB1D8837B347245A6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBXECADA07B7CA24B57898B20065F8C3A9B">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBX2ADB55D9135C4A4DB65B653591AD18F9">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX676EF27A950D46459B5755A5E06303A5">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX53131B4646F348A2A90547BA1C7BB929">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX90B92CB4DEA04683B1564678CE98FF64">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">5</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBXCB095A99B3B542D88C74EF394C47FAF6">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">6</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>330</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX655BF6733F6943368B0DBB97A2F7E51A">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBXF2ED76D4D4BC4F128F6E9C35241D7564">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBXF973588321D34165ADE1E5F5C09A21DD">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXF2EEB97618584CDDA38D5E2752250DF3">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX82BCE23576684736BD7739A9E8274F23">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX8CE6231111A24CE98DE92B554F1D9D25">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">6</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX483F91CC624149428069304D9A4C4333">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">7</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>395</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX62EC6E1740FB45CA87872AED32AC596F">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX800F2DF16F6B490DA433CBEA16BDBA64">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBXFB45D0E09C1C4ED992BB12553ECBC7CB">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX9703EFF2E9CA40D79C0C50C85FFAAD22">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX41378ECAEA2C4D84B2FCEE86BBB20D33">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX584FE110C89F4F0196358B6CDBD458B6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">7</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX3D6CF54745144681B4B185BEDC6E5D42">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">8</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>460</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX1F24A277560E45F3965A8E6E8BC1AAFC">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBXB414DDA3A88A4C44B0A17F75BCE029A8">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBXC0CDF8976D2749AF87E62CCDA4261E11">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX068901AAC80F4F37B0A44EBBE197DB2E">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX08C74E17952948CB89EE18E26DD48D87">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX8FA6441028C7444C909B69066BAA2392">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">8</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX169D0D8449FD43448FDC49459248E986">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">9</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>525</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBXC579D56599634A73AE733057B8FDBC0B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX266598FD64174D77B8D211E15513AECA">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBX6E7F66C76A8D40C1970D9F5C7A59AA78">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX70F4741DD8DB48BB88AEC8FC32646A4B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXDE325757D3FF4C3B8AAA778114430E2D">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX96BC924E52024B94B9633C25C038EC62">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">9</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX8BAE8CA1C79249B78B5F6A56BDBBD775">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoButtonColor">false</bool>
						<Color3 name="BackgroundColor3">4280229663</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">4294967295</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">4</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">10</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>590</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>60</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBXBB88B5BF99BD40B4B3FEB87BE233257F">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SelectionObjectClipper</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX9AE31A79C96A443580AAD403ADBFB4BB">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4278190080</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/Keyboard/key_selection_9slice.png</url></Content>
								<Color3 name="ImageColor3">4294967295</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<string name="Name">Selector</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<token name="ScaleType">1</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>12</X>
										<Y>12</Y>
									</min>
									<max>
										<X>52</X>
										<Y>52</Y>
									</max>
								</Rect2D>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageLabel" referent="RBX6C41355CAA894B86A027738EC98D49B9">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">Icon</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.100000001</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX11884CDEF42F4F0CACDCEB2D6D722D0E">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolName</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-2</XO>
								<YS>1</YS>
								<YO>-2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX19DFAAD791A54763A5F7462A98F0A5A7">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4284900966</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">ToolTip</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXA93900205FFE473FBF5330AA952AB5E7">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">5</token>
							<string name="Name">Number</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.150000006</XS>
								<XO>0</XO>
								<YS>0.150000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">0</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBXA45F1E73502D4683B666ECE0304A5EDC">
				<Properties>
					<bool name="Active">true</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4280229663</Color3>
					<float name="BackgroundTransparency">0.5</float>
					<Color3 name="BorderColor3">4278190080</Color3>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">Inventory</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-328</XO>
						<YS>1</YS>
						<YO>-390</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>655</XO>
						<YS>0</YS>
						<YO>320</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ScrollingFrame" referent="RBX6238A1196E6745D79056DE3EE399CCEC">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4278190080</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4278190080</Color3>
						<int name="BorderSizePixel">0</int>
						<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
						<Vector2 name="CanvasPosition">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<UDim2 name="CanvasSize">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<bool name="ClipsDescendants">true</bool>
						<bool name="Draggable">false</bool>
						<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
						<string name="Name">ScrollingFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>40</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<int name="ScrollBarThickness">12</int>
						<bool name="ScrollingEnabled">true</bool>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>13</XO>
							<YS>1</YS>
							<YO>-40</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX9D3B5204542F41D1BD824F78120909BD">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4284374622</Color3>
						<float name="BackgroundTransparency">0.150000006</float>
						<Color3 name="BorderColor3">4278190080</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Search</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-195</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>190</XO>
							<YS>0</YS>
							<YO>30</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextBox" referent="RBXB819F0AA26FE4F3CA747388AB4FF85D2">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClearTextOnFocus">false</bool>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<token name="FontSize">7</token>
							<bool name="MultiLine">false</bool>
							<string name="Name">TextBox</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>190</XO>
								<YS>0</YS>
								<YO>30</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">   Search</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX8A9B92D490D44D22A24B47D55F745658">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4284374622</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4278190080</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">X</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-30</XO>
								<YS>0.5</YS>
								<YO>-10</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>20</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">x</string>
							<Color3 name="TextColor3">4284124905</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">2</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX00610A1F086F493DAAFC44D7A5069967">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">GamepadHintsFrame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>655</XO>
						<YS>0</YS>
						<YO>60</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX38BF28620731463CB416382746B32A7E">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">HintFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-5</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX059D7A3C97314C38919BD2357312ACC5">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/XButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">HintImage</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>60</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXC5CF374ED441495EAD7DEDD3868EE232">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<string name="Name">HintText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>70</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Remove From Hotbar</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX8C37D132AD444BF0AAAA66DA726B6FBD">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">HintFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-5</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBXDA6B93535D3149C28C2A406FF9C39F6E">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/AButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">HintImage</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>60</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXD756B7AC75694B3583069EFA36C96E21">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<string name="Name">HintText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>70</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Select/Swap</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX36ECBC2672AB4AF0A2FC374BBB410866">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">HintFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-5</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX22163BAB768242E99895069984194281">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://textures/ui/Settings/Help/BButtonDark.png</url></Content>
							<Color3 name="ImageColor3">4294967295</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<string name="Name">HintImage</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>60</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX7974CA131704437FBC9BA546DA52743C">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">4</token>
							<token name="FontSize">7</token>
							<string name="Name">HintText</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>70</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-70</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Close Backpack</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">24</float>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>